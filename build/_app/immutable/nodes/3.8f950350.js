var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _a, _b;
import { C as noop$1, F as identity, s as safe_not_equal, f as element, g as claim_element, h as children, d as detach, j as attr, i as insert_hydration, G as listen, H as add_render_callback, I as getContext, J as assign$1, K as exclude_internal_props, y as create_slot, a as space, c as claim_space, L as null_to_empty, M as toggle_class, k as set_style, D as append_hydration, N as action_destroyer, z as update_slot_base, A as get_all_dirty_from_scope, B as get_slot_changes, O as run_all, P as compute_slots, Q as setContext, o as onMount, R as set_attributes, S as is_function, T as get_current_component, x as component_subscribe, r as createEventDispatcher, e as empty, l as text, m as claim_text, n as set_data, U as src_url_equal, p as binding_callbacks, v as add_flush_callback, E as destroy_each, V as set_input_value, W as to_number, u as get_svelte_dataset, q as construct_svelte_component, X as stop_propagation, Y as prevent_default, Z as set_store_value, _ as bubble, $ as svg_element, a0 as claim_svg_element, a1 as set_svg_attributes, a2 as init_binding_group, a3 as HtmlTagHydration, a4 as claim_html_tag, a5 as onDestroy, a6 as current_component, b as afterUpdate } from "../chunks/scheduler.3830f32a.js";
import { n as now, l as loop, h as create_rule, j as delete_rule, S as SvelteComponent, i as init, k as create_bidirectional_transition, g as group_outros, t as transition_out, c as check_outros, a as transition_in, b as create_component, d as claim_component, m as mount_component, e as destroy_component, f as bind, o as create_in_transition, p as create_out_transition } from "../chunks/index.9ba3e62c.js";
import { L as List$1, e as ensure_array_like, h as mdiArrowUp, i as mdiDelete, j as mdiArrowDown, k as mdiCheck, l as mdiAlert, n as mdiPlay, u as update_keyed_each, o as fix_and_outro_and_destroy_block, p as mdiTune, q as mdiImage, r as mdiChartLine, s as mdiTextBoxEdit, t as outro_and_destroy_block, m as mdiMenu, c as mdiCog, v as mdiLock, w as mdiLockOpenVariant } from "../chunks/index.e65992db.js";
import { w as writable, j as derived } from "../chunks/singletons.5c7e3f39.js";
import { p as page } from "../chunks/stores.b6b002cf.js";
import { b as homey, g as devices, s as scopes, i as flowFolders, k as advancedFlows, j as basicFlows, l as insights, w as webhookUrl, m as webhookId, e as dashboards$1 } from "../chunks/homey.5e8ce930.js";
import { t as twMerge, f as fade, b as trapFocus, c as fly, e as exclude, u as useActions, g as get_spread_update, h as forwardEventsBuilder, B as Button$1, i as close, I as Input, a as Icon$7, v as v4, j as chevron_down, s as slide, k as scale, l as unfold_more_horizontal, m as error, H as HoverBackground, n as check, o as account, S as Swap, p as upload, q as alert_circle, r as crossfade$1, w as arrow_back, x as arrow_forward, y as undo, z as redo, A as print, C as download, D as info, E as warn, F as check_circle, G as thumb_up, P as Progress$1, J as trending_neutral, K as trending_down, L as trending_up, M as sort, N as comment, O as cubicOut, d as dashboards } from "../chunks/Progress.157241c8.js";
import { M as Modal, e as editing, g as grid, d as dashboard } from "../chunks/index.5612947e.js";
import { P as Portal, b as Divider$2, T as Toggle, c as clickOutside, f as floatingUI, a as Dropdown, D as Drawer$2 } from "../chunks/index.a1b1182c.js";
import { h as handle_promise, u as update_await_block_branch, C as Card } from "../chunks/index.77c9f90d.js";
import { c as commonjsGlobal, g as getDefaultExportFromCjs } from "../chunks/_commonjsHelpers.7a7fcd32.js";
const globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);
function create_animation(node, from2, fn2, params) {
  if (!from2)
    return noop$1;
  const to2 = node.getBoundingClientRect();
  if (from2.left === to2.left && from2.right === to2.right && from2.top === to2.top && from2.bottom === to2.bottom)
    return noop$1;
  const {
    delay = 0,
    duration = 300,
    easing = identity,
    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?
    start: start_time = now() + delay,
    // @ts-ignore todo:
    end: end2 = start_time + duration,
    tick = noop$1,
    css
  } = fn2(node, { from: from2, to: to2 }, params);
  let running = true;
  let started = false;
  let name;
  function start2() {
    if (css) {
      name = create_rule(node, 0, 1, duration, delay, easing, css);
    }
    if (!delay) {
      started = true;
    }
  }
  function stop() {
    if (css)
      delete_rule(node, name);
    running = false;
  }
  loop((now2) => {
    if (!started && now2 >= start_time) {
      started = true;
    }
    if (started && now2 >= end2) {
      tick(1, 0);
      stop();
    }
    if (!running) {
      return false;
    }
    if (started) {
      const p = now2 - start_time;
      const t2 = 0 + 1 * easing(p / duration);
      tick(t2, 1 - t2);
    }
    return true;
  });
  start2();
  tick(0, 1);
  return stop;
}
function fix_position(node) {
  const style = getComputedStyle(node);
  if (style.position !== "absolute" && style.position !== "fixed") {
    const { width: width2, height } = style;
    const a3 = node.getBoundingClientRect();
    node.style.position = "absolute";
    node.style.width = width2;
    node.style.height = height;
    add_transform(node, a3);
  }
}
function add_transform(node, a3) {
  const b2 = node.getBoundingClientRect();
  if (a3.left !== b2.left || a3.top !== b2.top) {
    const style = getComputedStyle(node);
    const transform = style.transform === "none" ? "" : style.transform;
    node.style.transform = `${transform} translate(${a3.left - b2.left}px, ${a3.top - b2.top}px)`;
  }
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement$1(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement$1(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round$1 = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round$1(clientRect.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round$1(clientRect.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement$1(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y3 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width2 = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width: width2,
    height,
    top: y3,
    right: x2 + width2,
    bottom: y3 + height,
    left: x2,
    x: x2,
    y: y3
  };
}
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width2 = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width2) <= 1) {
    width2 = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width: width2,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}
function getDocumentElement(element2) {
  return ((isElement$1(element2) ? element2.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element2.document
  )) || window.document).documentElement;
}
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element2.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element2.parentNode || // DOM Element detected
    (isShadowRoot(element2) ? element2.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element2)
  );
}
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle$2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement$1(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x2 = _ref.x, y3 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$1(x2 * dpr) / dpr || 0,
    y: round$1(y3 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y3 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y3
  }) : {
    x: x2,
    y: y3
  };
  x2 = _ref3.x;
  y3 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y3 -= offsetY - popperRect.height;
      y3 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y3
  }, getWindow(popper2)) : {
    x: x2,
    y: y3
  };
  x2 = _ref4.x;
  y3 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y3 + "px)" : "translate3d(" + x2 + "px, " + y3 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y3 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement$1(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance2 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance2.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance2.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance2.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance2.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width2 = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y3 = 0;
  if (visualViewport) {
    width2 = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  return {
    width: width2,
    height,
    x: x2 + getWindowScrollBarX(element2),
    y: y3
  };
}
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width2 = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y3 = -winScroll.scrollTop;
  if (getComputedStyle$2(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width2;
  }
  return {
    width: width2,
    height,
    x: x2,
    y: y3
  };
}
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle$2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement$1(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$1(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement$1(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a3, b2) {
    return overflows[a3] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement$1(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip$1(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement$1(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement$1(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement$1(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check2) {
      return check2;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check2) {
            return check2;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip$2 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip$1,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement$1(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y3 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y3;
  }
  state.modifiersData[name] = data;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement$1(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round$1(rect.width) / element2.offsetWidth || 1;
  var scaleY = round$1(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$2(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve2) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve2(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance2 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m3) {
          return m3.enabled;
        });
        runModifierEffects();
        return instance2.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance: instance2
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce$2(function() {
        return new Promise(function(resolve2) {
          instance2.forceUpdate();
          resolve2(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance2;
    }
    instance2.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect3 = _ref.effect;
        if (typeof effect3 === "function") {
          var cleanupFn = effect3({
            state,
            name,
            instance: instance2,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance2;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$2, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function getValueAtIndexOrReturn(value, index2, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index2];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index2] : defaultValue : v;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce$1(fn2, ms) {
  if (ms === 0) {
    return fn2;
  }
  var timeout;
  return function(arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      fn2(arg);
    }, ms);
  };
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function(item, index2) {
    return arr.indexOf(item) === index2;
  });
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement(value) {
  return ["Element", "Fragment"].some(function(type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function(el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function(el) {
    if (el) {
      el.setAttribute("data-state", state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element2 = _normalizeToArray[0];
  return element2 != null && (_element$ownerDocumen = element2.ownerDocument) != null && _element$ownerDocumen.body ? element2.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref) {
    var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method](event, listener);
  });
}
function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now2 = performance.now();
  if (now2 - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now2;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance2 = activeElement._tippy;
    if (activeElement.blur && !instance2.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser ? (
  // @ts-ignore
  !!window.msCrypto
) : false;
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {
  },
  onBeforeUpdate: function onBeforeUpdate() {
  },
  onCreate: function onCreate() {
  },
  onDestroy: function onDestroy2() {
  },
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount2() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  onUntrigger: function onUntrigger() {
  },
  onClickOutside: function onClickOutside() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  var keys = Object.keys(partialProps);
  keys.forEach(function(key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins2 = passedProps.plugins || [];
  var pluginProps2 = plugins2.reduce(function(acc, plugin) {
    var name = plugin.name, defaultValue = plugin.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins2) {
  var propKeys = plugins2 ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins: plugins2
  }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key) {
    var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e2) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference2, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference2])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element2, html) {
  element2[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow2 = div();
  if (value === true) {
    arrow2.className = ARROW_CLASS;
  } else {
    arrow2.className = SVG_ARROW_CLASS;
    if (isElement(value)) {
      arrow2.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow2, value);
    }
  }
  return arrow2;
}
function setContent(content, props) {
  if (isElement(props.content)) {
    dangerouslySetInnerHTML(content, "");
    content.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function(node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance2) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute("data-state", "hidden");
  setContent(content, instance2.props);
  popper2.appendChild(box);
  box.appendChild(content);
  onUpdate(instance2.props, instance2.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow2 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent(content2, instance2.props);
    }
    if (nextProps.arrow) {
      if (!arrow2) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow2);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow2) {
      box2.removeChild(arrow2);
    }
  }
  return {
    popper: popper2,
    onUpdate
  };
}
render.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce$1(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id = idCounter++;
  var popperInstance = null;
  var plugins2 = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance2 = {
    // properties
    id,
    reference: reference2,
    popper: div(),
    popperInstance,
    props,
    state,
    plugins: plugins2,
    // methods
    clearDelayTimeouts,
    setProps,
    setContent: setContent2,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy
  };
  if (!props.render) {
    return instance2;
  }
  var _props$render = props.render(instance2), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance2.id;
  instance2.popper = popper2;
  reference2._tippy = instance2;
  popper2._tippy = instance2;
  var pluginsHooks = plugins2.map(function(plugin) {
    return plugin.fn(instance2);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance2]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance2.props.interactive && instance2.state.isVisible) {
      instance2.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance2.props.interactive && instance2.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance2;
  function getNormalizedTouchSettings() {
    var touch = instance2.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance2.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance2.state.isMounted && !instance2.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance2.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance2.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance2.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance2.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance2.props.aria;
    if (!aria.content) {
      return;
    }
    var attr2 = "aria-" + aria.content;
    var id2 = popper2.id;
    var nodes = normalizeToArray(instance2.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      var currentValue = node.getAttribute(attr2);
      if (instance2.state.isVisible) {
        node.setAttribute(attr2, currentValue ? currentValue + " " + id2 : id2);
      } else {
        var nextValue = currentValue && currentValue.replace(id2, "").trim();
        if (nextValue) {
          node.setAttribute(attr2, nextValue);
        } else {
          node.removeAttribute(attr2);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance2.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance2.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      if (instance2.props.interactive) {
        node.setAttribute("aria-expanded", instance2.state.isVisible && node === getCurrentTarget() ? "true" : "false");
      } else {
        node.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance2.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance2.props.triggerTarget || reference2).some(function(el) {
      return actualContains(el, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance2.state.isVisible && instance2.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance2, event]);
    }
    if (instance2.props.hideOnClick === true) {
      instance2.clearDelayTimeouts();
      instance2.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance2.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc = getDocument();
    doc.addEventListener("mousedown", onDocumentPress, true);
    doc.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc = getDocument();
    doc.removeEventListener("mousedown", onDocumentPress, true);
    doc.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback2) {
    onTransitionEnd(duration, function() {
      if (!instance2.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback2();
      }
    });
  }
  function onTransitionedIn(duration, callback2) {
    onTransitionEnd(duration, callback2);
  }
  function onTransitionEnd(duration, callback2) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback2();
      }
    }
    if (duration === 0) {
      return callback2();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance2.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node,
        eventType,
        handler,
        options
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on("touchstart", onTrigger2, {
        passive: true
      });
      on("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance2.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on("mouseleave", onMouseLeave);
          break;
        case "focus":
          on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function(_ref) {
      var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance2.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance2.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance2.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance2.props.hideOnClick !== false && instance2.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
      var _instance$popperInsta;
      var instance3 = popper3._tippy;
      var state2 = (_instance$popperInsta = instance3.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state2) {
        return {
          popperRect: popper3.getBoundingClientRect(),
          popperState: state2,
          props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance2.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance2.props.interactive) {
      instance2.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance2.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance2.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance2.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow2 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference2;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn2(_ref2) {
        var state2 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr2) {
            if (attr2 === "placement") {
              box.setAttribute("data-placement", state2.placement);
            } else {
              if (state2.attributes.popper["data-popper-" + attr2]) {
                box.setAttribute("data-" + attr2, "");
              } else {
                box.removeAttribute("data-" + attr2);
              }
            }
          });
          state2.attributes.popper = {};
        }
      }
    };
    var modifiers = [{
      name: "offset",
      options: {
        offset: offset2
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow2) {
      modifiers.push({
        name: "arrow",
        options: {
          element: arrow2,
          padding: 3
        }
      });
    }
    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance2.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers
    }));
  }
  function destroyPopperInstance() {
    if (instance2.popperInstance) {
      instance2.popperInstance.destroy();
      instance2.popperInstance = null;
    }
  }
  function mount() {
    var appendTo = instance2.props.appendTo;
    var parentNode;
    var node = getCurrentTarget();
    if (instance2.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode = node.parentNode;
    } else {
      parentNode = invokeWithArgsOrReturn(appendTo, [node]);
    }
    if (!parentNode.contains(popper2)) {
      parentNode.appendChild(popper2);
    }
    instance2.state.isMounted = true;
    createPopperInstance();
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance2.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance2, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance2.show();
      }, delay);
    } else {
      instance2.show();
    }
  }
  function scheduleHide(event) {
    instance2.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance2, event]);
    if (!instance2.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance2.props.trigger.indexOf("mouseenter") >= 0 && instance2.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance2.state.isVisible) {
          instance2.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance2.hide();
      });
    }
  }
  function enable() {
    instance2.state.isEnabled = true;
  }
  function disable() {
    instance2.hide();
    instance2.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    if (instance2.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance2, partialProps]);
    removeListeners();
    var prevProps = instance2.props;
    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance2.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce$1(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
        node.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance2.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance2, partialProps]);
  }
  function setContent2(content) {
    instance2.setProps({
      content
    });
  }
  function show() {
    var isAlreadyVisible = instance2.state.isVisible;
    var isDestroyed = instance2.state.isDestroyed;
    var isDisabled = !instance2.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance2.props.touch;
    var duration = getValueAtIndexOrReturn(instance2.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance2], false);
    if (instance2.props.onShow(instance2) === false) {
      return;
    }
    instance2.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance2.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance2.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance2.props.moveTransition;
      if (getIsDefaultRenderFn() && instance2.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance2);
      (_instance$popperInsta2 = instance2.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance2]);
      if (instance2.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance2.state.isShown = true;
          invokeHook("onShown", [instance2]);
        });
      }
    };
    mount();
  }
  function hide2() {
    var isAlreadyHidden = !instance2.state.isVisible;
    var isDestroyed = instance2.state.isDestroyed;
    var isDisabled = !instance2.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance2.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance2], false);
    if (instance2.props.onHide(instance2) === false) {
      return;
    }
    instance2.state.isVisible = false;
    instance2.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
      if (instance2.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance2.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance2.unmount);
      }
    } else {
      instance2.unmount();
    }
  }
  function hideWithInteractivity(event) {
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    if (instance2.state.isVisible) {
      instance2.hide();
    }
    if (!instance2.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i2) {
      return i2 !== instance2;
    });
    instance2.state.isMounted = false;
    invokeHook("onHidden", [instance2]);
  }
  function destroy() {
    if (instance2.state.isDestroyed) {
      return;
    }
    instance2.clearDelayTimeouts();
    instance2.unmount();
    removeListeners();
    delete reference2._tippy;
    instance2.state.isDestroyed = true;
    invokeHook("onDestroy", [instance2]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins2 = defaultProps.plugins.concat(optionalProps.plugins || []);
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins: plugins2
  });
  var elements2 = getArrayOfElements(targets);
  var instances2 = elements2.reduce(function(acc, reference2) {
    var instance2 = reference2 && createTippy(reference2, passedProps);
    if (instance2) {
      acc.push(instance2);
    }
    return acc;
  }, []);
  return isElement(targets) ? instances2[0] : instances2;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
Object.assign({}, applyStyles$1, {
  effect: function effect2(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
  }
});
tippy.setDefaultProps({
  render
});
function tooltip(node, { allowHTML, animation, appendTo, arrow: arrow2, content, delay, disabled, duration, hideOnClick, ignoreAttributes, inertia, interactive, maxWidth, moveTransition, offset: offset2, placement, theme, trigger, triggerTarget, zIndex }) {
  const tip = tippy(node, {
    allowHTML: allowHTML || false,
    animation,
    appendTo,
    arrow: arrow2,
    content,
    delay,
    duration,
    hideOnClick,
    ignoreAttributes,
    inertia,
    interactive,
    maxWidth,
    moveTransition,
    offset: offset2,
    placement,
    theme,
    trigger,
    triggerTarget,
    zIndex
  });
  if (disabled) {
    tip.disable();
  } else {
    tip.enable();
  }
  return {
    // If the props change, let's update the Tippy instance:
    update: (newConfig) => {
      if (newConfig.disabled) {
        tip.disable();
      } else {
        tip.enable();
      }
      return tip.setProps({ content, ...newConfig });
    },
    // Clean up the Tippy instance on unmount:
    destroy: () => tip.destroy()
  };
}
const thisYearFormat = {
  month: "short",
  day: "numeric",
  hour: "numeric",
  minute: "2-digit",
  hour12: true
};
const lastYearOrOlderFormat = {
  year: "2-digit",
  month: "short",
  day: "numeric",
  hour: "numeric",
  minute: "2-digit",
  hour12: true
};
function formatDate(date) {
  const now2 = /* @__PURE__ */ new Date();
  const msBetweenDatesNonAbs = date.getTime() - now2.getTime();
  const negative = msBetweenDatesNonAbs < 0;
  const msBetweenDates = Math.abs(date.getTime() - now2.getTime());
  let minutesBetweenDates = msBetweenDates / (60 * 1e3);
  let hoursBetweenDates = msBetweenDates / (60 * 60 * 1e3);
  const dateYear = date.getFullYear();
  const nowYear = now2.getFullYear();
  if (hoursBetweenDates < 2) {
    if (negative)
      minutesBetweenDates = minutesBetweenDates * -1;
    return new Intl.RelativeTimeFormat("default", { style: "long" }).format(minutesBetweenDates, "minutes");
  } else if (hoursBetweenDates < 24) {
    if (negative)
      hoursBetweenDates = hoursBetweenDates * -1;
    return new Intl.RelativeTimeFormat("default", {
      style: "long"
    }).format(hoursBetweenDates, "hours");
  } else if (dateYear === nowYear) {
    return new Intl.DateTimeFormat("default", thisYearFormat).format(date);
  } else {
    return new Intl.DateTimeFormat("default", lastYearOrOlderFormat).format(date);
  }
}
function create_fragment$33(ctx) {
  let button;
  let button_style_value;
  let button_transition;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", {
        class: true,
        style: true,
        type: true,
        tabindex: true
      });
      children(button).forEach(detach);
      this.h();
    },
    h() {
      attr(
        button,
        "class",
        /*finalClass*/
        ctx[0]
      );
      attr(button, "style", button_style_value = /*$$props*/
      ctx[3].style);
      attr(button, "type", "button");
      attr(button, "tabindex", "-1");
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*disableOverlayClose*/
          ctx[2] ? void 0 : (
            /*handleClose*/
            ctx[1]
          )
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*finalClass*/
      1) {
        attr(
          button,
          "class",
          /*finalClass*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$$props*/
      8 && button_style_value !== (button_style_value = /*$$props*/
      ctx2[3].style)) {
        attr(button, "style", button_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!button_transition)
            button_transition = create_bidirectional_transition(button, fade, {}, true);
          button_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!button_transition)
          button_transition = create_bidirectional_transition(button, fade, {}, false);
        button_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (detaching && button_transition)
        button_transition.end();
      mounted = false;
      dispose();
    }
  };
}
const defaultClass$27 = "fixed inset-0 bg-background bg-opacity-10 backdrop-blur-sm transition-opacity pointer-events-auto";
function instance$31($$self, $$props, $$invalidate) {
  let finalClass;
  const handleClose = getContext("drawer-handleClose");
  const disableOverlayClose = getContext("drawer-disableOverlayClose");
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
  };
  $$self.$$.update = () => {
    $$invalidate(0, finalClass = twMerge(defaultClass$27, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [finalClass, handleClose, disableOverlayClose, $$props];
}
class Backdrop extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$31, create_fragment$33, safe_not_equal, {});
  }
}
const Drawer_svelte_svelte_type_style_lang = "";
const get_footer_slot_changes$1 = (dirty) => ({});
const get_footer_slot_context$1 = (ctx) => ({});
const get_content_slot_changes$4 = (dirty) => ({});
const get_content_slot_context$4 = (ctx) => ({});
const get_header_slot_changes$2 = (dirty) => ({});
const get_header_slot_context$2 = (ctx) => ({});
const get_backdrop_slot_changes = (dirty) => ({});
const get_backdrop_slot_context = (ctx) => ({});
function create_else_block$C(ctx) {
  let backdrop;
  let current;
  backdrop = new Backdrop({});
  return {
    c() {
      create_component(backdrop.$$.fragment);
    },
    l(nodes) {
      claim_component(backdrop.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(backdrop, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(backdrop.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(backdrop.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(backdrop, detaching);
    }
  };
}
function create_if_block$1e(ctx) {
  let current;
  const backdrop_slot_template = (
    /*#slots*/
    ctx[12].backdrop
  );
  const backdrop_slot = create_slot(
    backdrop_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_backdrop_slot_context
  );
  return {
    c() {
      if (backdrop_slot)
        backdrop_slot.c();
    },
    l(nodes) {
      if (backdrop_slot)
        backdrop_slot.l(nodes);
    },
    m(target, anchor) {
      if (backdrop_slot) {
        backdrop_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (backdrop_slot) {
        if (backdrop_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            backdrop_slot,
            backdrop_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              backdrop_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_backdrop_slot_changes
            ),
            get_backdrop_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(backdrop_slot, local);
      current = true;
    },
    o(local) {
      transition_out(backdrop_slot, local);
      current = false;
    },
    d(detaching) {
      if (backdrop_slot)
        backdrop_slot.d(detaching);
    }
  };
}
function create_fragment$32(ctx) {
  let div5;
  let current_block_type_index;
  let if_block;
  let t0;
  let div4;
  let div3;
  let div2;
  let div1;
  let div0;
  let button;
  let t1;
  let t2;
  let t3;
  let t4;
  let div0_class_value;
  let div0_style_value;
  let div1_class_value;
  let div1_transition;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$1e, create_else_block$C];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[6].backdrop
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const header_slot_template = (
    /*#slots*/
    ctx[12].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_header_slot_context$2
  );
  const content_slot_template = (
    /*#slots*/
    ctx[12].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_content_slot_context$4
  );
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    null
  );
  const footer_slot_template = (
    /*#slots*/
    ctx[12].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_footer_slot_context$1
  );
  return {
    c() {
      div5 = element("div");
      if_block.c();
      t0 = space();
      div4 = element("div");
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      button = element("button");
      t1 = space();
      if (header_slot)
        header_slot.c();
      t2 = space();
      if (content_slot)
        content_slot.c();
      t3 = space();
      if (default_slot)
        default_slot.c();
      t4 = space();
      if (footer_slot)
        footer_slot.c();
      this.h();
    },
    l(nodes) {
      div5 = claim_element(nodes, "DIV", { class: true, role: true });
      var div5_nodes = children(div5);
      if_block.l(div5_nodes);
      t0 = claim_space(div5_nodes);
      div4 = claim_element(div5_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", {
        class: true,
        style: true,
        "data-dialog": true,
        "data-placement": true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
      var div0_nodes = children(div0);
      button = claim_element(div0_nodes, "BUTTON", { class: true });
      children(button).forEach(detach);
      t1 = claim_space(div0_nodes);
      if (header_slot)
        header_slot.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      if (content_slot)
        content_slot.l(div0_nodes);
      t3 = claim_space(div0_nodes);
      if (default_slot)
        default_slot.l(div0_nodes);
      t4 = claim_space(div0_nodes);
      if (footer_slot)
        footer_slot.l(div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      div3_nodes.forEach(detach);
      div4_nodes.forEach(detach);
      div5_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "class", "h-0 w-0 border-none outline-none ring-0 focus:border-none focus:outline-none focus:ring-0");
      attr(div0, "class", div0_class_value = null_to_empty(
        /*finalClass*/
        ctx[3]
      ) + " svelte-sgu5l5");
      attr(div0, "style", div0_style_value = /*$$props*/
      ctx[5].style);
      toggle_class(
        div0,
        "left",
        /*placement*/
        ctx[0] === "left"
      );
      toggle_class(
        div0,
        "right",
        /*placement*/
        ctx[0] === "right"
      );
      toggle_class(
        div0,
        "top",
        /*placement*/
        ctx[0] === "top"
      );
      toggle_class(
        div0,
        "bottom",
        /*placement*/
        ctx[0] === "bottom"
      );
      attr(div1, "class", div1_class_value = null_to_empty(
        /*finalPanelClass*/
        ctx[2]
      ) + " svelte-sgu5l5");
      set_style(div1, "opactiy", "1");
      attr(div1, "data-dialog", "");
      attr(
        div1,
        "data-placement",
        /*placement*/
        ctx[0]
      );
      toggle_class(
        div1,
        "left",
        /*placement*/
        ctx[0] === "left"
      );
      toggle_class(
        div1,
        "right",
        /*placement*/
        ctx[0] === "right"
      );
      toggle_class(
        div1,
        "top",
        /*placement*/
        ctx[0] === "top"
      );
      toggle_class(
        div1,
        "bottom",
        /*placement*/
        ctx[0] === "bottom"
      );
      toggle_class(
        div1,
        "shadow-2xl",
        /*placement*/
        ctx[0] !== "bottom"
      );
      toggle_class(
        div1,
        "shadow-negative-2xl",
        /*placement*/
        ctx[0] === "bottom"
      );
      attr(div2, "class", "pointer-events-none fixed flex max-w-full drawer svelte-sgu5l5");
      toggle_class(
        div2,
        "left",
        /*placement*/
        ctx[0] === "left"
      );
      toggle_class(
        div2,
        "right",
        /*placement*/
        ctx[0] === "right"
      );
      toggle_class(
        div2,
        "top",
        /*placement*/
        ctx[0] === "top"
      );
      toggle_class(
        div2,
        "bottom",
        /*placement*/
        ctx[0] === "bottom"
      );
      attr(div3, "class", "absolute inset-0 overflow-hidden pointer-events-none");
      attr(div4, "class", "fixed inset-0 overflow-hidden pointer-events-none");
      attr(div5, "class", "relative z-10");
      attr(div5, "role", "dialog");
    },
    m(target, anchor) {
      insert_hydration(target, div5, anchor);
      if_blocks[current_block_type_index].m(div5, null);
      append_hydration(div5, t0);
      append_hydration(div5, div4);
      append_hydration(div4, div3);
      append_hydration(div3, div2);
      append_hydration(div2, div1);
      append_hydration(div1, div0);
      append_hydration(div0, button);
      append_hydration(div0, t1);
      if (header_slot) {
        header_slot.m(div0, null);
      }
      append_hydration(div0, t2);
      if (content_slot) {
        content_slot.m(div0, null);
      }
      append_hydration(div0, t3);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_hydration(div0, t4);
      if (footer_slot) {
        footer_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            window,
            "keydown",
            /*captureEscapeEvent*/
            ctx[4]
          ),
          action_destroyer(trapFocus.call(null, div1))
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div5, t0);
      }
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx,
            /*$$scope*/
            ctx[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[11]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx[11],
              dirty,
              get_header_slot_changes$2
            ),
            get_header_slot_context$2
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx,
            /*$$scope*/
            ctx[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[11]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx[11],
              dirty,
              get_content_slot_changes$4
            ),
            get_content_slot_context$4
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[11]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[11],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx,
            /*$$scope*/
            ctx[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[11]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx[11],
              dirty,
              get_footer_slot_changes$1
            ),
            get_footer_slot_context$1
          );
        }
      }
      if (!current || dirty & /*finalClass*/
      8 && div0_class_value !== (div0_class_value = null_to_empty(
        /*finalClass*/
        ctx[3]
      ) + " svelte-sgu5l5")) {
        attr(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*$$props*/
      32 && div0_style_value !== (div0_style_value = /*$$props*/
      ctx[5].style)) {
        attr(div0, "style", div0_style_value);
      }
      if (!current || dirty & /*finalClass, placement*/
      9) {
        toggle_class(
          div0,
          "left",
          /*placement*/
          ctx[0] === "left"
        );
      }
      if (!current || dirty & /*finalClass, placement*/
      9) {
        toggle_class(
          div0,
          "right",
          /*placement*/
          ctx[0] === "right"
        );
      }
      if (!current || dirty & /*finalClass, placement*/
      9) {
        toggle_class(
          div0,
          "top",
          /*placement*/
          ctx[0] === "top"
        );
      }
      if (!current || dirty & /*finalClass, placement*/
      9) {
        toggle_class(
          div0,
          "bottom",
          /*placement*/
          ctx[0] === "bottom"
        );
      }
      if (!current || dirty & /*finalPanelClass*/
      4 && div1_class_value !== (div1_class_value = null_to_empty(
        /*finalPanelClass*/
        ctx[2]
      ) + " svelte-sgu5l5")) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*placement*/
      1) {
        attr(
          div1,
          "data-placement",
          /*placement*/
          ctx[0]
        );
      }
      if (!current || dirty & /*finalPanelClass, placement*/
      5) {
        toggle_class(
          div1,
          "left",
          /*placement*/
          ctx[0] === "left"
        );
      }
      if (!current || dirty & /*finalPanelClass, placement*/
      5) {
        toggle_class(
          div1,
          "right",
          /*placement*/
          ctx[0] === "right"
        );
      }
      if (!current || dirty & /*finalPanelClass, placement*/
      5) {
        toggle_class(
          div1,
          "top",
          /*placement*/
          ctx[0] === "top"
        );
      }
      if (!current || dirty & /*finalPanelClass, placement*/
      5) {
        toggle_class(
          div1,
          "bottom",
          /*placement*/
          ctx[0] === "bottom"
        );
      }
      if (!current || dirty & /*finalPanelClass, placement*/
      5) {
        toggle_class(
          div1,
          "shadow-2xl",
          /*placement*/
          ctx[0] !== "bottom"
        );
      }
      if (!current || dirty & /*finalPanelClass, placement*/
      5) {
        toggle_class(
          div1,
          "shadow-negative-2xl",
          /*placement*/
          ctx[0] === "bottom"
        );
      }
      if (!current || dirty & /*placement*/
      1) {
        toggle_class(
          div2,
          "left",
          /*placement*/
          ctx[0] === "left"
        );
      }
      if (!current || dirty & /*placement*/
      1) {
        toggle_class(
          div2,
          "right",
          /*placement*/
          ctx[0] === "right"
        );
      }
      if (!current || dirty & /*placement*/
      1) {
        toggle_class(
          div2,
          "top",
          /*placement*/
          ctx[0] === "top"
        );
      }
      if (!current || dirty & /*placement*/
      1) {
        toggle_class(
          div2,
          "bottom",
          /*placement*/
          ctx[0] === "bottom"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(header_slot, local);
      transition_in(content_slot, local);
      transition_in(default_slot, local);
      transition_in(footer_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div1_transition)
            div1_transition = create_bidirectional_transition(
              div1,
              fly,
              /*flyConfig*/
              ctx[1],
              true
            );
          div1_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(header_slot, local);
      transition_out(content_slot, local);
      transition_out(default_slot, local);
      transition_out(footer_slot, local);
      if (local) {
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(
            div1,
            fly,
            /*flyConfig*/
            ctx[1],
            false
          );
        div1_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
      }
      if_blocks[current_block_type_index].d();
      if (header_slot)
        header_slot.d(detaching);
      if (content_slot)
        content_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (footer_slot)
        footer_slot.d(detaching);
      if (detaching && div1_transition)
        div1_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$26 = "flex inner-panel flex-col bg-surface overflow-hidden";
const defaultPanelClass = "pointer-events-auto panel transition-transform duration-200";
function instance$30($$self, $$props, $$invalidate) {
  let finalClass;
  let finalPanelClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { handleClose = void 0 } = $$props;
  let { placement = "right" } = $$props;
  let { disableEscClose = false } = $$props;
  let { disableOverlayClose = false } = $$props;
  let { panelClass = "" } = $$props;
  function captureEscapeEvent(e2) {
    if (e2.key === "Escape" && e2.code === "Escape" && !e2.shiftKey && !disableEscClose && handleClose) {
      onClose();
      e2.preventDefault();
      e2.stopPropagation();
    }
  }
  function onClose() {
    const dialogs = document.querySelectorAll(`[data-placement=${placement}]`);
    let offset2 = 0;
    for (let i2 = dialogs.length - 1; i2 >= 0; i2--) {
      if (i2 !== dialogs.length - 1) {
        if (placement === "left") {
          dialogs[i2].style.transform = `translateX(${offset2}px)`;
          offset2 -= 180;
        } else if (placement === "top") {
          dialogs[i2].style.transform = `translateY(${offset2}px)`;
          offset2 -= 180;
        } else if (placement === "bottom") {
          dialogs[i2].style.transform = `translateY(${offset2}px)`;
          offset2 += 180;
        } else {
          dialogs[i2].style.transform = `translateX(${offset2}px)`;
          offset2 += 180;
        }
      }
    }
    if (handleClose) {
      handleClose();
    }
  }
  let flyConfig = { x: 448 };
  if (placement === "left") {
    flyConfig = { x: -448 };
  } else if (placement === "top") {
    flyConfig = { y: -448 };
  } else if (placement === "bottom") {
    flyConfig = { y: 448 };
  }
  function shiftDrawers() {
    const dialogs = document.querySelectorAll(`[data-placement=${placement}]`);
    let offset2 = 0;
    for (let i2 = 0; i2 < dialogs.length; i2++) {
      if (i2 !== dialogs.length - 1) {
        if (placement === "left") {
          offset2 += 180;
          dialogs[i2].style.transform = `translateX(${offset2}px)`;
        } else if (placement === "top") {
          offset2 += 180;
          dialogs[i2].style.transform = `translateY(${offset2}px)`;
        } else if (placement === "bottom") {
          offset2 -= 180;
          dialogs[i2].style.transform = `translateY(${offset2}px)`;
        } else {
          offset2 -= 180;
          dialogs[i2].style.transform = `translateX(${offset2}px)`;
        }
      }
    }
  }
  setContext("drawer-handleClose", onClose);
  setContext("drawer-disableOverlayClose", disableOverlayClose);
  onMount(() => {
    shiftDrawers();
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("handleClose" in $$new_props)
      $$invalidate(7, handleClose = $$new_props.handleClose);
    if ("placement" in $$new_props)
      $$invalidate(0, placement = $$new_props.placement);
    if ("disableEscClose" in $$new_props)
      $$invalidate(8, disableEscClose = $$new_props.disableEscClose);
    if ("disableOverlayClose" in $$new_props)
      $$invalidate(9, disableOverlayClose = $$new_props.disableOverlayClose);
    if ("panelClass" in $$new_props)
      $$invalidate(10, panelClass = $$new_props.panelClass);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(3, finalClass = twMerge(defaultClass$26, $$props.class));
    if ($$self.$$.dirty & /*panelClass*/
    1024) {
      $$invalidate(2, finalPanelClass = twMerge(defaultPanelClass, panelClass));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    placement,
    flyConfig,
    finalPanelClass,
    finalClass,
    captureEscapeEvent,
    $$props,
    $$slots,
    handleClose,
    disableEscClose,
    disableOverlayClose,
    panelClass,
    $$scope,
    slots
  ];
}
let Drawer$1 = class Drawer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$30, create_fragment$32, safe_not_equal, {
      handleClose: 7,
      placement: 0,
      disableEscClose: 8,
      disableOverlayClose: 9,
      panelClass: 10
    });
  }
};
function create_if_block$1d(ctx) {
  let div2;
  let button;
  let current;
  button = new Button$1({
    props: {
      ariaLabel: "close",
      type: "ghost",
      shape: "circle",
      $$slots: { icon: [create_icon_slot$3] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*handleClose*/
    ctx[3]
  );
  return {
    c() {
      div2 = element("div");
      create_component(button.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      claim_component(button.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "ml-3 flex items-center");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(button, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope*/
      64) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(button);
    }
  };
}
function create_icon_slot$3(ctx) {
  let button_icon;
  let current;
  button_icon = new Button$1.Icon({ props: { slot: "icon", data: close } });
  return {
    c() {
      create_component(button_icon.$$.fragment);
    },
    l(nodes) {
      claim_component(button_icon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button_icon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(button_icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button_icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button_icon, detaching);
    }
  };
}
function create_fragment$31(ctx) {
  let div1;
  let div0;
  let h22;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let if_block = (
    /*handleClose*/
    ctx[3] && create_if_block$1d(ctx)
  );
  let div1_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let div_data_1 = {};
  for (let i2 = 0; i2 < div1_levels.length; i2 += 1) {
    div_data_1 = assign$1(div_data_1, div1_levels[i2]);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      h22 = element("h2");
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      h22 = claim_element(div0_nodes, "H2", {});
      var h2_nodes = children(h22);
      if (default_slot)
        default_slot.l(h2_nodes);
      h2_nodes.forEach(detach);
      t2 = claim_space(div0_nodes);
      if (if_block)
        if_block.l(div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "flex items-start justify-between");
      set_attributes(div1, div_data_1);
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      append_hydration(div1, div0);
      append_hydration(div0, h22);
      if (default_slot) {
        default_slot.m(h22, null);
      }
      append_hydration(div0, t2);
      if (if_block)
        if_block.m(div0, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div1,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*handleClose*/
        ctx2[3]
      )
        if_block.p(ctx2, dirty);
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$25 = "px-4 sm:px-6 py-4 shadow-md flex-shrink text-lg font-medium text-content border-b border-border";
function instance$2$($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const handleClose = getContext("drawer-handleClose");
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$25, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, handleClose, $$props, slots, $$scope];
}
let Header$3 = class Header extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2$, create_fragment$31, safe_not_equal, { use: 0 });
  }
};
function create_fragment$30(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$24 = "relative flex-grow text-content p-4";
function instance$2_($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$24, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Content$5 = class Content extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2_, create_fragment$30, safe_not_equal, { use: 0 });
  }
};
function create_fragment$2$(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$23 = "px-4 sm:px-6 py-4 text-content shadow-negative-md flex-shrink border-t border-border";
function instance$2Z($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$23, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Footer$2 = class Footer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2Z, create_fragment$2$, safe_not_equal, { use: 0 });
  }
};
const Drawer2 = Drawer$1;
Drawer2.Backdrop = Backdrop;
Drawer2.Header = Header$3;
Drawer2.Content = Content$5;
Drawer2.Footer = Footer$2;
function get_each_context$h(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  return child_ctx;
}
function create_else_block$B(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*placeholder*/
        ctx[1]
      );
    },
    l(nodes) {
      t2 = claim_text(
        nodes,
        /*placeholder*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*placeholder*/
      2)
        set_data(
          t2,
          /*placeholder*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_2$x(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Device not found");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Device not found");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$O(ctx) {
  let promise;
  let t0;
  let t1_value = (
    /*selected*/
    ctx[5].name + ""
  );
  let t1;
  let info2 = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1$1,
    then: create_then_block_1$1,
    catch: create_catch_block_1$1,
    value: 19
  };
  handle_promise(promise = /*$homey*/
  ctx[6].baseUrl, info2);
  return {
    c() {
      info2.block.c();
      t0 = space();
      t1 = text(t1_value);
    },
    l(nodes) {
      info2.block.l(nodes);
      t0 = claim_space(nodes);
      t1 = claim_text(nodes, t1_value);
    },
    m(target, anchor) {
      info2.block.m(target, info2.anchor = anchor);
      info2.mount = () => t0.parentNode;
      info2.anchor = t0;
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info2.ctx = ctx;
      if (dirty & /*$homey*/
      64 && promise !== (promise = /*$homey*/
      ctx[6].baseUrl) && handle_promise(promise, info2))
        ;
      else {
        update_await_block_branch(info2, ctx, dirty);
      }
      if (dirty & /*selected*/
      32 && t1_value !== (t1_value = /*selected*/
      ctx[5].name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      info2.block.d(detaching);
      info2.token = null;
      info2 = null;
    }
  };
}
function create_catch_block_1$1(ctx) {
  return {
    c: noop$1,
    l: noop$1,
    m: noop$1,
    p: noop$1,
    d: noop$1
  };
}
function create_then_block_1$1(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", { src: true, alt: true, class: true });
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*url*/
      ctx[19] + /*selected*/
      ctx[5].iconObj.url))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*selected*/
      ctx[5].name);
      attr(img, "class", "h-6 w-6 mr-2");
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$homey, selected*/
      96 && !src_url_equal(img.src, img_src_value = /*url*/
      ctx2[19] + /*selected*/
      ctx2[5].iconObj.url)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*selected*/
      32 && img_alt_value !== (img_alt_value = /*selected*/
      ctx2[5].name)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_pending_block_1$1(ctx) {
  return {
    c: noop$1,
    l: noop$1,
    m: noop$1,
    p: noop$1,
    d: noop$1
  };
}
function create_default_slot_4$9(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*selected*/
      ctx2[5] !== void 0
    )
      return create_if_block_1$O;
    if (
      /*deviceId*/
      ctx2[0] !== void 0
    )
      return create_if_block_2$x;
    return create_else_block$B;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_if_block$1c(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      handleClose: (
        /*func*/
        ctx[13]
      ),
      $$slots: { content: [create_content_slot$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    l(nodes) {
      claim_component(modal.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & /*open*/
      8)
        modal_changes.handleClose = /*func*/
        ctx2[13];
      if (dirty & /*$$scope, filtered, $homey, search*/
      1048660) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_catch_block$4(ctx) {
  return {
    c: noop$1,
    l: noop$1,
    m: noop$1,
    p: noop$1,
    d: noop$1
  };
}
function create_then_block$4(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", { src: true, alt: true, class: true });
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*url*/
      ctx[19] + /*device*/
      ctx[16].iconObj.url))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*device*/
      ctx[16].name);
      attr(img, "class", "h-6 w-6 mr-2");
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$homey, filtered*/
      80 && !src_url_equal(img.src, img_src_value = /*url*/
      ctx2[19] + /*device*/
      ctx2[16].iconObj.url)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*filtered*/
      16 && img_alt_value !== (img_alt_value = /*device*/
      ctx2[16].name)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_pending_block$4(ctx) {
  return {
    c: noop$1,
    l: noop$1,
    m: noop$1,
    p: noop$1,
    d: noop$1
  };
}
function create_default_slot_3$b(ctx) {
  let promise;
  let t0;
  let t1_value = (
    /*device*/
    ctx[16].name + ""
  );
  let t1;
  let t2;
  let info2 = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$4,
    then: create_then_block$4,
    catch: create_catch_block$4,
    value: 19
  };
  handle_promise(promise = /*$homey*/
  ctx[6].baseUrl, info2);
  return {
    c() {
      info2.block.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
    },
    l(nodes) {
      info2.block.l(nodes);
      t0 = claim_space(nodes);
      t1 = claim_text(nodes, t1_value);
      t2 = claim_space(nodes);
    },
    m(target, anchor) {
      info2.block.m(target, info2.anchor = anchor);
      info2.mount = () => t0.parentNode;
      info2.anchor = t0;
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, t2, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info2.ctx = ctx;
      if (dirty & /*$homey*/
      64 && promise !== (promise = /*$homey*/
      ctx[6].baseUrl) && handle_promise(promise, info2))
        ;
      else {
        update_await_block_branch(info2, ctx, dirty);
      }
      if (dirty & /*filtered*/
      16 && t1_value !== (t1_value = /*device*/
      ctx[16].name + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      info2.block.d(detaching);
      info2.token = null;
      info2 = null;
    }
  };
}
function create_title_slot$4(ctx) {
  let list_item_content_title;
  let current;
  list_item_content_title = new List$1.Item.Content.Title({
    props: {
      slot: "title",
      class: "flex",
      $$slots: { default: [create_default_slot_3$b] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list_item_content_title.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item_content_title.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item_content_title, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_item_content_title_changes = {};
      if (dirty & /*$$scope, filtered, $homey*/
      1048656) {
        list_item_content_title_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list_item_content_title.$set(list_item_content_title_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item_content_title.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item_content_title.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item_content_title, detaching);
    }
  };
}
function create_content_slot_1$3(ctx) {
  let list_item_content;
  let current;
  list_item_content = new List$1.Item.Content({
    props: {
      slot: "content",
      $$slots: { title: [create_title_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list_item_content.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item_content.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item_content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_item_content_changes = {};
      if (dirty & /*$$scope, filtered, $homey*/
      1048656) {
        list_item_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list_item_content.$set(list_item_content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item_content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item_content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item_content, detaching);
    }
  };
}
function create_each_block$h(ctx) {
  let list_item;
  let current;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[12](
        /*device*/
        ctx[16]
      )
    );
  }
  list_item = new List$1.Item({
    props: {
      class: "cursor-pointer",
      $$slots: { content: [create_content_slot_1$3] },
      $$scope: { ctx }
    }
  });
  list_item.$on("click", click_handler_1);
  return {
    c() {
      create_component(list_item.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const list_item_changes = {};
      if (dirty & /*$$scope, filtered, $homey*/
      1048656) {
        list_item_changes.$$scope = { dirty, ctx };
      }
      list_item.$set(list_item_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item, detaching);
    }
  };
}
function create_default_slot_2$d(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*filtered*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$h(get_each_context$h(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*onDevice, filtered, $homey*/
      208) {
        each_value = ensure_array_like(
          /*filtered*/
          ctx2[4]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$h(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$h(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_1$g(ctx) {
  let div0;
  let input;
  let updating_value;
  let t2;
  let div1;
  let list;
  let current;
  function input_value_binding(value) {
    ctx[11](value);
  }
  let input_props = { name: "search", placeholder: "Search" };
  if (
    /*search*/
    ctx[2] !== void 0
  ) {
    input_props.value = /*search*/
    ctx[2];
  }
  input = new Input({ props: input_props });
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  list = new List$1({
    props: {
      $$slots: { default: [create_default_slot_2$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div0 = element("div");
      create_component(input.$$.fragment);
      t2 = space();
      div1 = element("div");
      create_component(list.$$.fragment);
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", {});
      var div0_nodes = children(div0);
      claim_component(input.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t2 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(list.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div1, "class", "flex-grow overflow-auto");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      mount_component(input, div0, null);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, div1, anchor);
      mount_component(list, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const input_changes = {};
      if (!updating_value && dirty & /*search*/
      4) {
        updating_value = true;
        input_changes.value = /*search*/
        ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
      const list_changes = {};
      if (dirty & /*$$scope, filtered, $homey*/
      1048656) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t2);
        detach(div1);
      }
      destroy_component(input);
      destroy_component(list);
    }
  };
}
function create_body_slot$5(ctx) {
  let modal_content_body;
  let current;
  modal_content_body = new Modal.Content.Body({
    props: {
      slot: "body",
      class: "h-full",
      $$slots: { default: [create_default_slot_1$g] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal_content_body.$$.fragment);
    },
    l(nodes) {
      claim_component(modal_content_body.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal_content_body, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_content_body_changes = {};
      if (dirty & /*$$scope, filtered, $homey, search*/
      1048660) {
        modal_content_body_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal_content_body.$set(modal_content_body_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal_content_body.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal_content_body.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal_content_body, detaching);
    }
  };
}
function create_content_slot$6(ctx) {
  let modal_content;
  let current;
  modal_content = new Modal.Content({
    props: {
      slot: "content",
      $$slots: { body: [create_body_slot$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal_content.$$.fragment);
    },
    l(nodes) {
      claim_component(modal_content.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal_content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_content_changes = {};
      if (dirty & /*$$scope, filtered, $homey, search*/
      1048660) {
        modal_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal_content.$set(modal_content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal_content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal_content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal_content, detaching);
    }
  };
}
function create_default_slot$l(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*open*/
    ctx[3] && create_if_block$1c(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*open*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1c(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$2_(ctx) {
  let button;
  let t2;
  let portal;
  let current;
  button = new Button$1({
    props: {
      class: "w-full justify-start",
      $$slots: { default: [create_default_slot_4$9] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[10]
  );
  portal = new Portal({
    props: {
      $$slots: { default: [create_default_slot$l] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(button.$$.fragment);
      t2 = space();
      create_component(portal.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(portal.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      insert_hydration(target, t2, anchor);
      mount_component(portal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button_changes = {};
      if (dirty & /*$$scope, selected, $homey, deviceId, placeholder*/
      1048675) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      const portal_changes = {};
      if (dirty & /*$$scope, open, filtered, $homey, search*/
      1048668) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal.$set(portal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      transition_in(portal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      transition_out(portal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(button, detaching);
      destroy_component(portal, detaching);
    }
  };
}
function instance$2Y($$self, $$props, $$invalidate) {
  let sorted;
  let $homey;
  component_subscribe($$self, homey, ($$value) => $$invalidate(6, $homey = $$value));
  let { deviceId } = $$props;
  let { devices: devices2 = [] } = $$props;
  let { placeholder = "Select device" } = $$props;
  const dispatch = createEventDispatcher();
  let open = false;
  let search = "";
  let filtered = [];
  let selected;
  function filterDevices(value, s3) {
    const normalized = value.toLowerCase();
    if (value.length > 0) {
      $$invalidate(4, filtered = sorted.filter((d3) => d3.name.toLowerCase().includes(normalized)));
    } else {
      $$invalidate(4, filtered = sorted);
    }
  }
  function onDevice(device) {
    $$invalidate(0, deviceId = device.id);
    $$invalidate(3, open = false);
    dispatch("deviceId", deviceId);
  }
  const click_handler = () => $$invalidate(3, open = true);
  function input_value_binding(value) {
    search = value;
    $$invalidate(2, search);
  }
  const click_handler_1 = (device) => onDevice(device);
  const func = () => $$invalidate(3, open = false);
  $$self.$$set = ($$props2) => {
    if ("deviceId" in $$props2)
      $$invalidate(0, deviceId = $$props2.deviceId);
    if ("devices" in $$props2)
      $$invalidate(8, devices2 = $$props2.devices);
    if ("placeholder" in $$props2)
      $$invalidate(1, placeholder = $$props2.placeholder);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*devices*/
    256) {
      $$invalidate(9, sorted = (devices2 ?? []).sort((a3, b2) => {
        if (a3.name === b2.name)
          return 0;
        if (a3.name < b2.name)
          return -1;
        return 1;
      }));
    }
    if ($$self.$$.dirty & /*deviceId, devices*/
    257) {
      $$invalidate(5, selected = deviceId !== void 0 ? devices2.find((d3) => d3.id === deviceId) : void 0);
    }
    if ($$self.$$.dirty & /*search, sorted*/
    516) {
      filterDevices(search);
    }
  };
  return [
    deviceId,
    placeholder,
    search,
    open,
    filtered,
    selected,
    $homey,
    onDevice,
    devices2,
    sorted,
    click_handler,
    input_value_binding,
    click_handler_1,
    func
  ];
}
class DevicePicker extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2Y, create_fragment$2_, safe_not_equal, { deviceId: 0, devices: 8, placeholder: 1 });
  }
}
function get_each_context$g(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  return child_ctx;
}
function create_else_block$A(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*placeholder*/
        ctx[1]
      );
    },
    l(nodes) {
      t2 = claim_text(
        nodes,
        /*placeholder*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*placeholder*/
      2)
        set_data(
          t2,
          /*placeholder*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_3$u(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Capability not found");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Capability not found");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_2$w(ctx) {
  let promise;
  let t0;
  let t1_value = (
    /*selected*/
    ctx[5].title + ""
  );
  let t1;
  let info2 = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block_1,
    then: create_then_block_1,
    catch: create_catch_block_1,
    value: 19
  };
  handle_promise(promise = /*$homey*/
  ctx[6].baseUrl, info2);
  return {
    c() {
      info2.block.c();
      t0 = space();
      t1 = text(t1_value);
    },
    l(nodes) {
      info2.block.l(nodes);
      t0 = claim_space(nodes);
      t1 = claim_text(nodes, t1_value);
    },
    m(target, anchor) {
      info2.block.m(target, info2.anchor = anchor);
      info2.mount = () => t0.parentNode;
      info2.anchor = t0;
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info2.ctx = ctx;
      if (dirty & /*$homey*/
      64 && promise !== (promise = /*$homey*/
      ctx[6].baseUrl) && handle_promise(promise, info2))
        ;
      else {
        update_await_block_branch(info2, ctx, dirty);
      }
      if (dirty & /*selected*/
      32 && t1_value !== (t1_value = /*selected*/
      ctx[5].title + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      info2.block.d(detaching);
      info2.token = null;
      info2 = null;
    }
  };
}
function create_catch_block_1(ctx) {
  return {
    c: noop$1,
    l: noop$1,
    m: noop$1,
    p: noop$1,
    d: noop$1
  };
}
function create_then_block_1(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", { src: true, alt: true, class: true });
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*url*/
      ctx[19] + /*selected*/
      ctx[5].iconObj.url))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*selected*/
      ctx[5].title);
      attr(img, "class", "h-6 w-6 mr-2");
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$homey, selected*/
      96 && !src_url_equal(img.src, img_src_value = /*url*/
      ctx2[19] + /*selected*/
      ctx2[5].iconObj.url)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*selected*/
      32 && img_alt_value !== (img_alt_value = /*selected*/
      ctx2[5].title)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_pending_block_1(ctx) {
  return {
    c: noop$1,
    l: noop$1,
    m: noop$1,
    p: noop$1,
    d: noop$1
  };
}
function create_default_slot_5$6(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*selected*/
      ctx2[5] !== void 0
    )
      return create_if_block_2$w;
    if (
      /*capabilityId*/
      ctx2[0] !== void 0
    )
      return create_if_block_3$u;
    return create_else_block$A;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_if_block$1b(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      handleClose: (
        /*func*/
        ctx[13]
      ),
      $$slots: { content: [create_content_slot$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    l(nodes) {
      claim_component(modal.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & /*open*/
      8)
        modal_changes.handleClose = /*func*/
        ctx2[13];
      if (dirty & /*$$scope, filtered, $homey, search*/
      1048660) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_catch_block$3(ctx) {
  return {
    c: noop$1,
    l: noop$1,
    m: noop$1,
    p: noop$1,
    d: noop$1
  };
}
function create_then_block$3(ctx) {
  var _a2;
  let if_block_anchor;
  let if_block = (
    /*capability*/
    ((_a2 = ctx[16].iconObj) == null ? void 0 : _a2.url) && create_if_block_1$N(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      var _a3;
      if (
        /*capability*/
        (_a3 = ctx2[16].iconObj) == null ? void 0 : _a3.url
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$N(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_1$N(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", { src: true, alt: true, class: true });
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*url*/
      ctx[19] + /*capability*/
      ctx[16].iconObj.url))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*capability*/
      ctx[16].title);
      attr(img, "class", "h-6 w-6 mr-2");
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$homey, filtered*/
      80 && !src_url_equal(img.src, img_src_value = /*url*/
      ctx2[19] + /*capability*/
      ctx2[16].iconObj.url)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*filtered*/
      16 && img_alt_value !== (img_alt_value = /*capability*/
      ctx2[16].title)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_pending_block$3(ctx) {
  return {
    c: noop$1,
    l: noop$1,
    m: noop$1,
    p: noop$1,
    d: noop$1
  };
}
function create_default_slot_4$8(ctx) {
  let promise;
  let t0;
  let t1_value = (
    /*capability*/
    ctx[16].title + ""
  );
  let t1;
  let t2;
  let info2 = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$3,
    then: create_then_block$3,
    catch: create_catch_block$3,
    value: 19
  };
  handle_promise(promise = /*$homey*/
  ctx[6].baseUrl, info2);
  return {
    c() {
      info2.block.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
    },
    l(nodes) {
      info2.block.l(nodes);
      t0 = claim_space(nodes);
      t1 = claim_text(nodes, t1_value);
      t2 = claim_space(nodes);
    },
    m(target, anchor) {
      info2.block.m(target, info2.anchor = anchor);
      info2.mount = () => t0.parentNode;
      info2.anchor = t0;
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, t2, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info2.ctx = ctx;
      if (dirty & /*$homey*/
      64 && promise !== (promise = /*$homey*/
      ctx[6].baseUrl) && handle_promise(promise, info2))
        ;
      else {
        update_await_block_branch(info2, ctx, dirty);
      }
      if (dirty & /*filtered*/
      16 && t1_value !== (t1_value = /*capability*/
      ctx[16].title + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
      info2.block.d(detaching);
      info2.token = null;
      info2 = null;
    }
  };
}
function create_title_slot$3(ctx) {
  let list_item_content_title;
  let current;
  list_item_content_title = new List$1.Item.Content.Title({
    props: {
      slot: "title",
      class: "flex",
      $$slots: { default: [create_default_slot_4$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list_item_content_title.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item_content_title.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item_content_title, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_item_content_title_changes = {};
      if (dirty & /*$$scope, filtered, $homey*/
      1048656) {
        list_item_content_title_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list_item_content_title.$set(list_item_content_title_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item_content_title.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item_content_title.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item_content_title, detaching);
    }
  };
}
function create_default_slot_3$a(ctx) {
  var _a2, _b2;
  let span;
  let t0_value = (
    /*capability*/
    ((_a2 = ctx[16]) == null ? void 0 : _a2.value) + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*capability*/
    (((_b2 = ctx[16]) == null ? void 0 : _b2.units) ?? "") + ""
  );
  let t2;
  let t3;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, t0_value);
      t1 = claim_space(span_nodes);
      t2 = claim_text(span_nodes, t2_value);
      span_nodes.forEach(detach);
      t3 = claim_space(nodes);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, t0);
      append_hydration(span, t1);
      append_hydration(span, t2);
      insert_hydration(target, t3, anchor);
    },
    p(ctx2, dirty) {
      var _a3, _b3;
      if (dirty & /*filtered*/
      16 && t0_value !== (t0_value = /*capability*/
      ((_a3 = ctx2[16]) == null ? void 0 : _a3.value) + ""))
        set_data(t0, t0_value);
      if (dirty & /*filtered*/
      16 && t2_value !== (t2_value = /*capability*/
      (((_b3 = ctx2[16]) == null ? void 0 : _b3.units) ?? "") + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t3);
      }
    }
  };
}
function create_description_slot$2(ctx) {
  let list_item_content_description;
  let current;
  list_item_content_description = new List$1.Item.Content.Description({
    props: {
      slot: "description",
      class: "w-full flex justify-between",
      $$slots: { default: [create_default_slot_3$a] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list_item_content_description.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item_content_description.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item_content_description, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_item_content_description_changes = {};
      if (dirty & /*$$scope, filtered*/
      1048592) {
        list_item_content_description_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list_item_content_description.$set(list_item_content_description_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item_content_description.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item_content_description.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item_content_description, detaching);
    }
  };
}
function create_content_slot_1$2(ctx) {
  let list_item_content;
  let current;
  list_item_content = new List$1.Item.Content({
    props: {
      slot: "content",
      $$slots: {
        description: [create_description_slot$2],
        title: [create_title_slot$3]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list_item_content.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item_content.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item_content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_item_content_changes = {};
      if (dirty & /*$$scope, filtered, $homey*/
      1048656) {
        list_item_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list_item_content.$set(list_item_content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item_content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item_content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item_content, detaching);
    }
  };
}
function create_each_block$g(ctx) {
  let list_item;
  let current;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[12](
        /*capability*/
        ctx[16]
      )
    );
  }
  list_item = new List$1.Item({
    props: {
      class: "cursor-pointer",
      $$slots: { content: [create_content_slot_1$2] },
      $$scope: { ctx }
    }
  });
  list_item.$on("click", click_handler_1);
  return {
    c() {
      create_component(list_item.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const list_item_changes = {};
      if (dirty & /*$$scope, filtered, $homey*/
      1048656) {
        list_item_changes.$$scope = { dirty, ctx };
      }
      list_item.$set(list_item_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item, detaching);
    }
  };
}
function create_default_slot_2$c(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*filtered*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$g(get_each_context$g(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*onCapability, filtered, $homey*/
      208) {
        each_value = ensure_array_like(
          /*filtered*/
          ctx2[4]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$g(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$g(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_1$f(ctx) {
  let div0;
  let input;
  let updating_value;
  let t2;
  let div1;
  let list;
  let current;
  function input_value_binding(value) {
    ctx[11](value);
  }
  let input_props = { name: "search", placeholder: "Search" };
  if (
    /*search*/
    ctx[2] !== void 0
  ) {
    input_props.value = /*search*/
    ctx[2];
  }
  input = new Input({ props: input_props });
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  list = new List$1({
    props: {
      $$slots: { default: [create_default_slot_2$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div0 = element("div");
      create_component(input.$$.fragment);
      t2 = space();
      div1 = element("div");
      create_component(list.$$.fragment);
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", {});
      var div0_nodes = children(div0);
      claim_component(input.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t2 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(list.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div1, "class", "flex-grow overflow-auto");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      mount_component(input, div0, null);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, div1, anchor);
      mount_component(list, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const input_changes = {};
      if (!updating_value && dirty & /*search*/
      4) {
        updating_value = true;
        input_changes.value = /*search*/
        ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
      const list_changes = {};
      if (dirty & /*$$scope, filtered, $homey*/
      1048656) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t2);
        detach(div1);
      }
      destroy_component(input);
      destroy_component(list);
    }
  };
}
function create_body_slot$4(ctx) {
  let modal_content_body;
  let current;
  modal_content_body = new Modal.Content.Body({
    props: {
      slot: "body",
      class: "h-full flex flex-col",
      $$slots: { default: [create_default_slot_1$f] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal_content_body.$$.fragment);
    },
    l(nodes) {
      claim_component(modal_content_body.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal_content_body, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_content_body_changes = {};
      if (dirty & /*$$scope, filtered, $homey, search*/
      1048660) {
        modal_content_body_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal_content_body.$set(modal_content_body_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal_content_body.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal_content_body.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal_content_body, detaching);
    }
  };
}
function create_content_slot$5(ctx) {
  let modal_content;
  let current;
  modal_content = new Modal.Content({
    props: {
      slot: "content",
      $$slots: { body: [create_body_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal_content.$$.fragment);
    },
    l(nodes) {
      claim_component(modal_content.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal_content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_content_changes = {};
      if (dirty & /*$$scope, filtered, $homey, search*/
      1048660) {
        modal_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal_content.$set(modal_content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal_content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal_content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal_content, detaching);
    }
  };
}
function create_default_slot$k(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*open*/
    ctx[3] && create_if_block$1b(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*open*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1b(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$2Z(ctx) {
  let button;
  let t2;
  let portal;
  let current;
  button = new Button$1({
    props: {
      class: "w-full justify-start",
      $$slots: { default: [create_default_slot_5$6] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[10]
  );
  portal = new Portal({
    props: {
      $$slots: { default: [create_default_slot$k] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(button.$$.fragment);
      t2 = space();
      create_component(portal.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(portal.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      insert_hydration(target, t2, anchor);
      mount_component(portal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button_changes = {};
      if (dirty & /*$$scope, selected, $homey, capabilityId, placeholder*/
      1048675) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      const portal_changes = {};
      if (dirty & /*$$scope, open, filtered, $homey, search*/
      1048668) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal.$set(portal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      transition_in(portal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      transition_out(portal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(button, detaching);
      destroy_component(portal, detaching);
    }
  };
}
function instance$2X($$self, $$props, $$invalidate) {
  let sorted;
  let $homey;
  component_subscribe($$self, homey, ($$value) => $$invalidate(6, $homey = $$value));
  let { capabilityId } = $$props;
  let { capabilities = [] } = $$props;
  let { placeholder = "Select capability" } = $$props;
  const dispatch = createEventDispatcher();
  let open = false;
  let search = "";
  let filtered = [];
  let selected;
  function filterCapabilities(value, s3) {
    const normalized = value.toLowerCase();
    if (value.length > 0) {
      $$invalidate(4, filtered = sorted.filter((d3) => d3.title.toLowerCase().includes(normalized)));
    } else {
      $$invalidate(4, filtered = sorted);
    }
  }
  function onCapability(capability) {
    $$invalidate(0, capabilityId = capability.id);
    $$invalidate(3, open = false);
    dispatch("capabilityId", capabilityId);
  }
  const click_handler = () => $$invalidate(3, open = true);
  function input_value_binding(value) {
    search = value;
    $$invalidate(2, search);
  }
  const click_handler_1 = (capability) => onCapability(capability);
  const func = () => $$invalidate(3, open = false);
  $$self.$$set = ($$props2) => {
    if ("capabilityId" in $$props2)
      $$invalidate(0, capabilityId = $$props2.capabilityId);
    if ("capabilities" in $$props2)
      $$invalidate(8, capabilities = $$props2.capabilities);
    if ("placeholder" in $$props2)
      $$invalidate(1, placeholder = $$props2.placeholder);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*capabilities*/
    256) {
      $$invalidate(9, sorted = (capabilities ?? []).sort((a3, b2) => {
        if (a3.title === b2.title)
          return 0;
        if (a3.title < b2.title)
          return -1;
        return 1;
      }));
    }
    if ($$self.$$.dirty & /*capabilityId, capabilities*/
    257) {
      $$invalidate(5, selected = capabilityId !== void 0 ? capabilities.find((d3) => d3.id === capabilityId) : void 0);
    }
    if ($$self.$$.dirty & /*search, sorted*/
    516) {
      filterCapabilities(search);
    }
  };
  return [
    capabilityId,
    placeholder,
    search,
    open,
    filtered,
    selected,
    $homey,
    onCapability,
    capabilities,
    sorted,
    click_handler,
    input_value_binding,
    click_handler_1,
    func
  ];
}
class CapabilityPicker extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2X, create_fragment$2Z, safe_not_equal, {
      capabilityId: 0,
      capabilities: 8,
      placeholder: 1
    });
  }
}
function get_each_context$f(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i2];
  child_ctx[24] = i2;
  return child_ctx;
}
function create_if_block$1a(ctx) {
  let div0;
  let capabilitypicker;
  let updating_capabilityId;
  let t0;
  let divider;
  let t1;
  let div1;
  let list;
  let current;
  function capabilitypicker_capabilityId_binding(value) {
    ctx[14](value);
  }
  let capabilitypicker_props = {
    capabilities: (
      /*flatCapabilities*/
      ctx[4]
    ),
    placeholder: "Add capability"
  };
  if (
    /*selectedCapability*/
    ctx[2] !== void 0
  ) {
    capabilitypicker_props.capabilityId = /*selectedCapability*/
    ctx[2];
  }
  capabilitypicker = new CapabilityPicker({ props: capabilitypicker_props });
  binding_callbacks.push(() => bind(capabilitypicker, "capabilityId", capabilitypicker_capabilityId_binding));
  divider = new Divider$2({
    props: {
      $$slots: { label: [create_label_slot$2] },
      $$scope: { ctx }
    }
  });
  list = new List$1({
    props: {
      $$slots: { default: [create_default_slot$j] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div0 = element("div");
      create_component(capabilitypicker.$$.fragment);
      t0 = space();
      create_component(divider.$$.fragment);
      t1 = space();
      div1 = element("div");
      create_component(list.$$.fragment);
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", {});
      var div0_nodes = children(div0);
      claim_component(capabilitypicker.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t0 = claim_space(nodes);
      claim_component(divider.$$.fragment, nodes);
      t1 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      claim_component(list.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      mount_component(capabilitypicker, div0, null);
      insert_hydration(target, t0, anchor);
      mount_component(divider, target, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, div1, anchor);
      mount_component(list, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const capabilitypicker_changes = {};
      if (dirty & /*flatCapabilities*/
      16)
        capabilitypicker_changes.capabilities = /*flatCapabilities*/
        ctx2[4];
      if (!updating_capabilityId && dirty & /*selectedCapability*/
      4) {
        updating_capabilityId = true;
        capabilitypicker_changes.capabilityId = /*selectedCapability*/
        ctx2[2];
        add_flush_callback(() => updating_capabilityId = false);
      }
      capabilitypicker.$set(capabilitypicker_changes);
      const divider_changes = {};
      if (dirty & /*$$scope*/
      67108864) {
        divider_changes.$$scope = { dirty, ctx: ctx2 };
      }
      divider.$set(divider_changes);
      const list_changes = {};
      if (dirty & /*$$scope, capabilities, $homey*/
      67108936) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(capabilitypicker.$$.fragment, local);
      transition_in(divider.$$.fragment, local);
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(capabilitypicker.$$.fragment, local);
      transition_out(divider.$$.fragment, local);
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(t1);
        detach(div1);
      }
      destroy_component(capabilitypicker);
      destroy_component(divider, detaching);
      destroy_component(list);
    }
  };
}
function create_default_slot_5$5(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Capabilities");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Capabilities");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_label_slot$2(ctx) {
  let divider_label;
  let current;
  divider_label = new Divider$2.Label({
    props: {
      slot: "label",
      $$slots: { default: [create_default_slot_5$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(divider_label.$$.fragment);
    },
    l(nodes) {
      claim_component(divider_label.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(divider_label, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const divider_label_changes = {};
      if (dirty & /*$$scope*/
      67108864) {
        divider_label_changes.$$scope = { dirty, ctx: ctx2 };
      }
      divider_label.$set(divider_label_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(divider_label.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(divider_label.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(divider_label, detaching);
    }
  };
}
function create_catch_block$2(ctx) {
  return {
    c: noop$1,
    l: noop$1,
    m: noop$1,
    p: noop$1,
    d: noop$1
  };
}
function create_then_block$2(ctx) {
  var _a2;
  let if_block_anchor;
  let if_block = (
    /*capability*/
    ((_a2 = ctx[22].iconObj) == null ? void 0 : _a2.url) && create_if_block_3$t(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      var _a3;
      if (
        /*capability*/
        (_a3 = ctx2[22].iconObj) == null ? void 0 : _a3.url
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3$t(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_3$t(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", { src: true, alt: true, class: true });
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*url*/
      ctx[25] + /*capability*/
      ctx[22].iconObj.url))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*capability*/
      ctx[22].title);
      attr(img, "class", "h-6 w-6 mr-2");
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$homey, capabilities*/
      72 && !src_url_equal(img.src, img_src_value = /*url*/
      ctx2[25] + /*capability*/
      ctx2[22].iconObj.url)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*capabilities*/
      8 && img_alt_value !== (img_alt_value = /*capability*/
      ctx2[22].title)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_pending_block$2(ctx) {
  return {
    c: noop$1,
    l: noop$1,
    m: noop$1,
    p: noop$1,
    d: noop$1
  };
}
function create_if_block_2$v(ctx) {
  let button;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[15](
        /*capability*/
        ctx[22]
      )
    );
  }
  button = new Button$1({
    props: {
      shape: "circle",
      $$slots: { default: [create_default_slot_4$7] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*$$scope*/
      67108864) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_4$7(ctx) {
  let button_icon;
  let current;
  button_icon = new Button$1.Icon({ props: { data: mdiArrowUp } });
  return {
    c() {
      create_component(button_icon.$$.fragment);
    },
    l(nodes) {
      claim_component(button_icon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button_icon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(button_icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button_icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button_icon, detaching);
    }
  };
}
function create_else_block$z(ctx) {
  let button;
  let current;
  button = new Button$1({ props: { shape: "circle" } });
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_if_block_1$M(ctx) {
  let button;
  let current;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[16](
        /*capability*/
        ctx[22]
      )
    );
  }
  button = new Button$1({
    props: {
      shape: "circle",
      $$slots: { default: [create_default_slot_3$9] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler_1);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*$$scope*/
      67108864) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_3$9(ctx) {
  let button_icon;
  let current;
  button_icon = new Button$1.Icon({ props: { data: mdiArrowDown } });
  return {
    c() {
      create_component(button_icon.$$.fragment);
    },
    l(nodes) {
      claim_component(button_icon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button_icon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(button_icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button_icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button_icon, detaching);
    }
  };
}
function create_default_slot_2$b(ctx) {
  let button_icon;
  let current;
  button_icon = new Button$1.Icon({ props: { data: mdiDelete } });
  return {
    c() {
      create_component(button_icon.$$.fragment);
    },
    l(nodes) {
      claim_component(button_icon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button_icon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(button_icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button_icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button_icon, detaching);
    }
  };
}
function create_default_slot_1$e(ctx) {
  let promise;
  let t0;
  let div0;
  let t1_value = (
    /*capability*/
    ctx[22].title + ""
  );
  let t1;
  let t2;
  let div1;
  let t3;
  let t4;
  let current_block_type_index;
  let if_block1;
  let t5;
  let button;
  let t6;
  let current;
  let info2 = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$2,
    then: create_then_block$2,
    catch: create_catch_block$2,
    value: 25
  };
  handle_promise(promise = /*$homey*/
  ctx[6].baseUrl, info2);
  let if_block0 = (
    /*i*/
    ctx[24] > 0 && create_if_block_2$v(ctx)
  );
  const if_block_creators = [create_if_block_1$M, create_else_block$z];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*i*/
      ctx2[24] < /*capabilities*/
      ctx2[3].length - 1
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[17](
        /*capability*/
        ctx[22]
      )
    );
  }
  button = new Button$1({
    props: {
      shape: "circle",
      $$slots: { default: [create_default_slot_2$b] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler_2);
  return {
    c() {
      info2.block.c();
      t0 = space();
      div0 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div1 = element("div");
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      if_block1.c();
      t5 = space();
      create_component(button.$$.fragment);
      t6 = space();
      this.h();
    },
    l(nodes) {
      info2.block.l(nodes);
      t0 = claim_space(nodes);
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, t1_value);
      div0_nodes.forEach(detach);
      t2 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { style: true });
      children(div1).forEach(detach);
      t3 = claim_space(nodes);
      if (if_block0)
        if_block0.l(nodes);
      t4 = claim_space(nodes);
      if_block1.l(nodes);
      t5 = claim_space(nodes);
      claim_component(button.$$.fragment, nodes);
      t6 = claim_space(nodes);
      this.h();
    },
    h() {
      attr(div0, "class", "my-auto");
      set_style(div1, "flex-grow", "1");
    },
    m(target, anchor) {
      info2.block.m(target, info2.anchor = anchor);
      info2.mount = () => t0.parentNode;
      info2.anchor = t0;
      insert_hydration(target, t0, anchor);
      insert_hydration(target, div0, anchor);
      append_hydration(div0, t1);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, div1, anchor);
      insert_hydration(target, t3, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration(target, t4, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, t5, anchor);
      mount_component(button, target, anchor);
      insert_hydration(target, t6, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info2.ctx = ctx;
      if (dirty & /*$homey*/
      64 && promise !== (promise = /*$homey*/
      ctx[6].baseUrl) && handle_promise(promise, info2))
        ;
      else {
        update_await_block_branch(info2, ctx, dirty);
      }
      if ((!current || dirty & /*capabilities*/
      8) && t1_value !== (t1_value = /*capability*/
      ctx[22].title + ""))
        set_data(t1, t1_value);
      if (
        /*i*/
        ctx[24] > 0
      )
        if_block0.p(ctx, dirty);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block1.c();
        } else {
          if_block1.p(ctx, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(t5.parentNode, t5);
      }
      const button_changes = {};
      if (dirty & /*$$scope*/
      67108864) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div0);
        detach(t2);
        detach(div1);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
      }
      info2.block.d(detaching);
      info2.token = null;
      info2 = null;
      if (if_block0)
        if_block0.d(detaching);
      if_blocks[current_block_type_index].d(detaching);
      destroy_component(button, detaching);
    }
  };
}
function create_each_block$f(ctx) {
  let list_item;
  let current;
  list_item = new List$1.Item({
    props: {
      class: "pt-1 pb-1",
      $$slots: { default: [create_default_slot_1$e] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list_item.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_item_changes = {};
      if (dirty & /*$$scope, capabilities, $homey*/
      67108936) {
        list_item_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list_item.$set(list_item_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item, detaching);
    }
  };
}
function create_default_slot$j(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*capabilities*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$f(get_each_context$f(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*remove, capabilities, mdiDelete, moveDown, mdiArrowDown, moveUp, mdiArrowUp, $homey*/
      968) {
        each_value = ensure_array_like(
          /*capabilities*/
          ctx2[3]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$f(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$f(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$2Y(ctx) {
  let div2;
  let devicepicker;
  let updating_deviceId;
  let t2;
  let if_block_anchor;
  let current;
  function devicepicker_deviceId_binding(value) {
    ctx[13](value);
  }
  let devicepicker_props = { devices: (
    /*flatDevices*/
    ctx[5]
  ) };
  if (
    /*deviceId*/
    ctx[0] !== void 0
  ) {
    devicepicker_props.deviceId = /*deviceId*/
    ctx[0];
  }
  devicepicker = new DevicePicker({ props: devicepicker_props });
  binding_callbacks.push(() => bind(devicepicker, "deviceId", devicepicker_deviceId_binding));
  let if_block = (
    /*device*/
    ctx[1] && create_if_block$1a(ctx)
  );
  return {
    c() {
      div2 = element("div");
      create_component(devicepicker.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div_nodes = children(div2);
      claim_component(devicepicker.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      t2 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(devicepicker, div2, null);
      insert_hydration(target, t2, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const devicepicker_changes = {};
      if (dirty & /*flatDevices*/
      32)
        devicepicker_changes.devices = /*flatDevices*/
        ctx2[5];
      if (!updating_deviceId && dirty & /*deviceId*/
      1) {
        updating_deviceId = true;
        devicepicker_changes.deviceId = /*deviceId*/
        ctx2[0];
        add_flush_callback(() => updating_deviceId = false);
      }
      devicepicker.$set(devicepicker_changes);
      if (
        /*device*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*device*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1a(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(devicepicker.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(devicepicker.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t2);
        detach(if_block_anchor);
      }
      destroy_component(devicepicker);
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$2W($$self, $$props, $$invalidate) {
  let flatDevices;
  let flatCapabilities;
  let $devices;
  let $homey;
  component_subscribe($$self, devices, ($$value) => $$invalidate(12, $devices = $$value));
  component_subscribe($$self, homey, ($$value) => $$invalidate(6, $homey = $$value));
  const dispatch = createEventDispatcher();
  let { settings } = $$props;
  let deviceId;
  let capabilityIds;
  let device;
  let capabilities;
  let selectedCapability;
  function onSettings(s3) {
    $$invalidate(0, deviceId = s3 == null ? void 0 : s3.deviceId);
    $$invalidate(11, capabilityIds = [...(s3 == null ? void 0 : s3.capabilityIds) ?? []]);
  }
  function onDevice(id) {
    if (id !== settings.deviceId) {
      $$invalidate(0, deviceId = id);
      dispatch("settings", {
        ...settings,
        deviceId: id,
        capabilityIds: []
      });
    }
  }
  function onCapability(id) {
    if (id === void 0) {
      return;
    }
    capabilityIds.push(id);
    dispatch("settings", { ...settings, capabilityIds });
    $$invalidate(2, selectedCapability = void 0);
  }
  function moveUp(capabilityId) {
    const index2 = capabilityIds.indexOf(capabilityId);
    if (index2 < 1) {
      return;
    }
    const idPrevious = capabilityIds[index2 - 1];
    const copy = [...capabilityIds];
    copy[index2 - 1] = capabilityId;
    copy[index2] = idPrevious;
    $$invalidate(11, capabilityIds = copy);
    dispatch("settings", { ...settings, capabilityIds });
  }
  function moveDown(capabilityId) {
    const index2 = capabilityIds.indexOf(capabilityId);
    if (index2 == capabilityIds.length - 1) {
      return;
    }
    const idNext = capabilityIds[index2 + 1];
    const copy = [...capabilityIds];
    copy[index2 + 1] = capabilityId;
    copy[index2] = idNext;
    $$invalidate(11, capabilityIds = copy);
    dispatch("settings", { ...settings, capabilityIds });
  }
  function remove(capabilityId) {
    $$invalidate(11, capabilityIds = capabilityIds.filter((cId) => cId !== capabilityId));
    dispatch("settings", { ...settings, capabilityIds });
  }
  function devicepicker_deviceId_binding(value) {
    deviceId = value;
    $$invalidate(0, deviceId);
  }
  function capabilitypicker_capabilityId_binding(value) {
    selectedCapability = value;
    $$invalidate(2, selectedCapability);
  }
  const click_handler = (capability) => moveUp(capability.id);
  const click_handler_1 = (capability) => moveDown(capability.id);
  const click_handler_2 = (capability) => remove(capability.id);
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(10, settings = $$props2.settings);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*settings*/
    1024) {
      onSettings(settings);
    }
    if ($$self.$$.dirty & /*deviceId, $devices*/
    4097) {
      $$invalidate(1, device = deviceId ? $devices[deviceId] : void 0);
    }
    if ($$self.$$.dirty & /*device, capabilityIds*/
    2050) {
      $$invalidate(3, capabilities = (device == null ? void 0 : device.capabilitiesObj) ? capabilityIds.map((cId) => device == null ? void 0 : device.capabilitiesObj[cId]).filter((c2) => c2 !== void 0) : []);
    }
    if ($$self.$$.dirty & /*$devices*/
    4096) {
      $$invalidate(5, flatDevices = Object.values($devices));
    }
    if ($$self.$$.dirty & /*device, capabilityIds*/
    2050) {
      $$invalidate(4, flatCapabilities = ((device == null ? void 0 : device.capabilitiesObj) ? Object.values(device.capabilitiesObj) : []).filter((c2) => !capabilityIds.includes(c2.id)).sort((a3, b2) => {
        if (a3.title === b2.title)
          return 0;
        if (a3.title < b2.title)
          return -1;
        return 1;
      }));
    }
    if ($$self.$$.dirty & /*deviceId*/
    1) {
      onDevice(deviceId);
    }
    if ($$self.$$.dirty & /*selectedCapability*/
    4) {
      onCapability(selectedCapability);
    }
  };
  return [
    deviceId,
    device,
    selectedCapability,
    capabilities,
    flatCapabilities,
    flatDevices,
    $homey,
    moveUp,
    moveDown,
    remove,
    settings,
    capabilityIds,
    $devices,
    devicepicker_deviceId_binding,
    capabilitypicker_capabilityId_binding,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
class CapabilityEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2W, create_fragment$2Y, safe_not_equal, { settings: 10 });
  }
}
function create_if_block$19(ctx) {
  return { c: noop$1, l: noop$1, m: noop$1, d: noop$1 };
}
function create_fragment$2X(ctx) {
  let div2;
  let input;
  let t2;
  let div_style_value;
  let mounted;
  let dispose;
  let if_block = (
    /*showStep*/
    ctx[4] && create_if_block$19()
  );
  return {
    c() {
      div2 = element("div");
      input = element("input");
      t2 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div2);
      input = claim_element(div_nodes, "INPUT", {
        type: true,
        min: true,
        max: true,
        step: true,
        class: true
      });
      t2 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(input, "type", "range");
      attr(
        input,
        "min",
        /*min*/
        ctx[1]
      );
      attr(
        input,
        "max",
        /*max*/
        ctx[2]
      );
      attr(
        input,
        "step",
        /*step*/
        ctx[3]
      );
      input.disabled = /*disabled*/
      ctx[5];
      attr(
        input,
        "class",
        /*finalClass*/
        ctx[6]
      );
      toggle_class(
        input,
        "default",
        /*disabled*/
        ctx[5]
      );
      attr(
        div2,
        "class",
        /*finalContainerClass*/
        ctx[7]
      );
      attr(div2, "style", div_style_value = /*$$props*/
      ctx[8].style);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, input);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      append_hydration(div2, t2);
      if (if_block)
        if_block.m(div2, null);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_input_handler*/
            ctx[15]
          ),
          listen(
            input,
            "input",
            /*input_change_input_handler*/
            ctx[15]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*min*/
      2) {
        attr(
          input,
          "min",
          /*min*/
          ctx2[1]
        );
      }
      if (dirty & /*max*/
      4) {
        attr(
          input,
          "max",
          /*max*/
          ctx2[2]
        );
      }
      if (dirty & /*step*/
      8) {
        attr(
          input,
          "step",
          /*step*/
          ctx2[3]
        );
      }
      if (dirty & /*disabled*/
      32) {
        input.disabled = /*disabled*/
        ctx2[5];
      }
      if (dirty & /*finalClass*/
      64) {
        attr(
          input,
          "class",
          /*finalClass*/
          ctx2[6]
        );
      }
      if (dirty & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (dirty & /*finalClass, disabled*/
      96) {
        toggle_class(
          input,
          "default",
          /*disabled*/
          ctx2[5]
        );
      }
      if (
        /*showStep*/
        ctx2[4]
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$19();
          if_block.c();
          if_block.m(div2, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*finalContainerClass*/
      128) {
        attr(
          div2,
          "class",
          /*finalContainerClass*/
          ctx2[7]
        );
      }
      if (dirty & /*$$props*/
      256 && div_style_value !== (div_style_value = /*$$props*/
      ctx2[8].style)) {
        attr(div2, "style", div_style_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
const containerClass = "w-full ";
function instance$2V($$self, $$props, $$invalidate) {
  let finalContainerClass;
  let finalClass;
  let { value = 0 } = $$props;
  let { min: min2 = 0 } = $$props;
  let { max: max2 = 100 } = $$props;
  let { step = 1 } = $$props;
  let { showStep = false } = $$props;
  let { type = "info" } = $$props;
  let { disabled = false } = $$props;
  let defaultClass2 = "[&::-moz-range-thumb]:cursor-pointer ";
  defaultClass2 += "[&::-moz-range-thumb]:rounded-full ";
  defaultClass2 += "[&::-moz-range-thumb]:top-2/4 ";
  defaultClass2 += "[&::-moz-range-thumb]:translate-y-[-50%] ";
  defaultClass2 += "[&::-moz-range-thumb]:h-4 ";
  defaultClass2 += "[&::-moz-range-thumb]:w-4 ";
  defaultClass2 += "[&::-moz-range-thumb]:border-none ";
  defaultClass2 += "[&::-moz-range-thumb]:relative ";
  defaultClass2 += "[&::-moz-range-thumb]:bg-content ";
  defaultClass2 += "[&::-moz-range-thumb]:[&::-webkit-appearance]:none ";
  defaultClass2 += "[&::-moz-range-thumb]:bg-surface ";
  defaultClass2 += "[&::-webkit-slider-thumb]:top-2/4 ";
  defaultClass2 += "[&::-webkit-slider-thumb]:translate-y-[-50%] ";
  defaultClass2 += "[&::-webkit-slider-thumb]:cursor-pointer ";
  defaultClass2 += "[&::-webkit-slider-thumb]:border-none ";
  defaultClass2 += "[&::-webkit-slider-thumb]:rounded-full ";
  defaultClass2 += "[&::-webkit-slider-thumb]:[&::-webkit-appearance]:none ";
  defaultClass2 += "[&::-webkit-slider-thumb]:relative ";
  defaultClass2 += "[&::-webkit-slider-thumb]:h-4 ";
  defaultClass2 += "[&::-webkit-slider-thumb]:w-4 ";
  defaultClass2 += "[&::-webkit-slider-thumb]:bg-content ";
  defaultClass2 += "[&::-webkit-slider-thumb]:appearance-none ";
  defaultClass2 += "[&::-webkit-slider-thumb]:bg-surface ";
  defaultClass2 += "[&::-moz-range-track]:h-6 ";
  defaultClass2 += "[&::-moz-range-track]:w-full ";
  defaultClass2 += "[&::-moz-range-track]:rounded-lg ";
  defaultClass2 += "[&::-moz-range-track]:mr-2 ";
  defaultClass2 += "[&::-moz-range-track]:rounded-lg ";
  defaultClass2 += "[&::-webkit-slider-runnable-track]:h-6 ";
  defaultClass2 += "[&::-webkit-slider-runnable-track]:w-full ";
  defaultClass2 += "[&::-webkit-slider-runnable-track]:rounded-lg ";
  defaultClass2 += "[&::-webkit-slider-runnable-track]:mr-2 ";
  defaultClass2 += "[&::-webkit-slider-runnable-track]:rounded-lg ";
  defaultClass2 += "[&::-webkit-slider-thumb]:ml-1 ";
  defaultClass2 += "[&::-moz-range-thumb]:ml-1 ";
  defaultClass2 += 'before:content-[""] ';
  defaultClass2 += "before:bg-default ";
  defaultClass2 += "before:w-full ";
  defaultClass2 += "before:h-2 ";
  defaultClass2 += "before:rounded-lg ";
  defaultClass2 += "before:top-2/4 ";
  defaultClass2 += "before:translate-y-[-50%] ";
  defaultClass2 += "before:absolute ";
  defaultClass2 += "relative ";
  defaultClass2 += "rounded-3xl ";
  defaultClass2 += "bg-transparent ";
  defaultClass2 += "overflow-hidden ";
  defaultClass2 += "w-full ";
  defaultClass2 += "appearance-none ";
  defaultClass2 += "[&::-webkit-slider-thumb]:ring-4 ";
  defaultClass2 += "[&::-moz-range-thumb]:ring-4 ";
  let infoProgressClass = "[&::-webkit-slider-thumb]:text-info ";
  infoProgressClass += "[&::-moz-range-thumb]:text-info ";
  infoProgressClass += "[&::-webkit-slider-thumb]:shadow-inset-info ";
  infoProgressClass += "[&::-moz-range-thumb]:shadow-inset-info ";
  infoProgressClass += "[&::-webkit-slider-thumb]:ring-info ";
  infoProgressClass += "[&::-moz-range-thumb]:ring-info ";
  infoProgressClass += "[&::-webkit-slider-thumb]:shadow-[var(--focus-shadow),0_0)] ";
  infoProgressClass += "[&::-moz-range-thumb]:shadow-[var(--focus-shadow),0_0)] ";
  infoProgressClass += "[&::-webkit-slider-thumb]:shadow-[calc(100rem_*_-1_-_0.5rem)_0_0_100rem] ";
  infoProgressClass += "[&::-moz-range-thumb]:shadow-[calc(100rem_*_-1_-_0.5rem)_0_0_100rem] ";
  let warnProgressClass = "[&::-webkit-slider-thumb]:text-warn ";
  warnProgressClass += "[&::-moz-range-thumb]:text-warn ";
  warnProgressClass += "[&::-webkit-slider-thumb]:shadow-inset-warn ";
  warnProgressClass += "[&::-moz-range-thumb]:shadow-inset-warn ";
  warnProgressClass += "[&::-webkit-slider-thumb]:ring-warn ";
  warnProgressClass += "[&::-moz-range-thumb]:ring-warn ";
  warnProgressClass += "[&::-webkit-slider-thumb]:shadow-[var(--focus-shadow),0_0)] ";
  warnProgressClass += "[&::-moz-range-thumb]:shadow-[var(--focus-shadow),0_0)] ";
  warnProgressClass += "[&::-webkit-slider-thumb]:shadow-[calc(100rem_*_-1_-_0.5rem)_0_0_100rem] ";
  warnProgressClass += "[&::-moz-range-thumb]:shadow-[calc(100rem_*_-1_-_0.5rem)_0_0_100rem] ";
  let errorProgressClass = "[&::-webkit-slider-thumb]:text-error ";
  errorProgressClass += "[&::-moz-range-thumb]:text-error ";
  errorProgressClass += "[&::-webkit-slider-thumb]:shadow-inset-error ";
  errorProgressClass += "[&::-moz-range-thumb]:shadow-inset-error ";
  errorProgressClass += "[&::-webkit-slider-thumb]:ring-error ";
  errorProgressClass += "[&::-moz-range-thumb]:ring-error ";
  errorProgressClass += "[&::-webkit-slider-thumb]:shadow-[var(--focus-shadow),0_0)] ";
  errorProgressClass += "[&::-moz-range-thumb]:shadow-[var(--focus-shadow),0_0)] ";
  errorProgressClass += "[&::-webkit-slider-thumb]:shadow-[calc(100rem_*_-1_-_0.5rem)_0_0_100rem] ";
  errorProgressClass += "[&::-moz-range-thumb]:shadow-[calc(100rem_*_-1_-_0.5rem)_0_0_100rem] ";
  let successProgressClass = "[&::-webkit-slider-thumb]:text-success ";
  successProgressClass += "[&::-moz-range-thumb]:text-success ";
  successProgressClass += "[&::-webkit-slider-thumb]:shadow-inset-success ";
  successProgressClass += "[&::-moz-range-thumb]:shadow-inset-success ";
  successProgressClass += "[&::-webkit-slider-thumb]:ring-success ";
  successProgressClass += "[&::-moz-range-thumb]:ring-success ";
  successProgressClass += "[&::-webkit-slider-thumb]:shadow-[var(--focus-shadow),0_0)] ";
  successProgressClass += "[&::-moz-range-thumb]:shadow-[var(--focus-shadow),0_0)] ";
  successProgressClass += "[&::-webkit-slider-thumb]:shadow-[calc(100rem_*_-1_-_0.5rem)_0_0_100rem] ";
  successProgressClass += "[&::-moz-range-thumb]:shadow-[calc(100rem_*_-1_-_0.5rem)_0_0_100rem] ";
  function input_change_input_handler() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$new_props)
      $$invalidate(1, min2 = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(2, max2 = $$new_props.max);
    if ("step" in $$new_props)
      $$invalidate(3, step = $$new_props.step);
    if ("showStep" in $$new_props)
      $$invalidate(4, showStep = $$new_props.showStep);
    if ("type" in $$new_props)
      $$invalidate(9, type = $$new_props.type);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
  };
  $$self.$$.update = () => {
    $$invalidate(7, finalContainerClass = twMerge(containerClass, $$props.class));
    $$invalidate(6, finalClass = twMerge(
      defaultClass2,
      type === "info" && !disabled ? infoProgressClass : false,
      type === "warn" && !disabled ? warnProgressClass : false,
      type === "error" && !disabled ? errorProgressClass : false,
      type === "success" && !disabled ? successProgressClass : false,
      // type === undefined && color === undefined && !disabled ? defaultProgressClass : false,
      // color !== undefined && !disabled ? customProgressClass : false,
      $$props.class
    ));
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    min2,
    max2,
    step,
    showStep,
    disabled,
    finalClass,
    finalContainerClass,
    $$props,
    type,
    defaultClass2,
    infoProgressClass,
    warnProgressClass,
    errorProgressClass,
    successProgressClass,
    input_change_input_handler
  ];
}
class Slider extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2V, create_fragment$2X, safe_not_equal, {
      value: 0,
      min: 1,
      max: 2,
      step: 3,
      showStep: 4,
      type: 9,
      disabled: 5
    });
  }
}
function create_else_block$y(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Null");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Null");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block$18(ctx) {
  let slider;
  let updating_value;
  let current;
  function slider_value_binding(value) {
    ctx[5](value);
  }
  let slider_props = {
    style: "flex-grow: 1; align-self: center; max-width: 100px;",
    min: (
      /*capability*/
      ctx[0].min
    ),
    max: (
      /*capability*/
      ctx[0].max
    ),
    step: Math.pow(10, -1 * /*capability*/
    ctx[0].decimals),
    disabled: (
      /*disabled*/
      ctx[2]
    )
  };
  if (
    /*value*/
    ctx[1] !== void 0
  ) {
    slider_props.value = /*value*/
    ctx[1];
  }
  slider = new Slider({ props: slider_props });
  binding_callbacks.push(() => bind(slider, "value", slider_value_binding));
  return {
    c() {
      create_component(slider.$$.fragment);
    },
    l(nodes) {
      claim_component(slider.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(slider, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const slider_changes = {};
      if (dirty & /*capability*/
      1)
        slider_changes.min = /*capability*/
        ctx2[0].min;
      if (dirty & /*capability*/
      1)
        slider_changes.max = /*capability*/
        ctx2[0].max;
      if (dirty & /*capability*/
      1)
        slider_changes.step = Math.pow(10, -1 * /*capability*/
        ctx2[0].decimals);
      if (dirty & /*disabled*/
      4)
        slider_changes.disabled = /*disabled*/
        ctx2[2];
      if (!updating_value && dirty & /*value*/
      2) {
        updating_value = true;
        slider_changes.value = /*value*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      slider.$set(slider_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(slider.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(slider.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(slider, detaching);
    }
  };
}
function create_fragment$2W(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$18, create_else_block$y];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*capability*/
      ctx2[0] !== null && /*capability*/
      ctx2[0] !== void 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$2U($$self, $$props, $$invalidate) {
  let disabled;
  let $editing;
  component_subscribe($$self, editing, ($$value) => $$invalidate(4, $editing = $$value));
  const dispatcher = createEventDispatcher();
  let { capability } = $$props;
  let { controllable } = $$props;
  let value;
  function onCapability(c2) {
    $$invalidate(1, value = c2.value);
  }
  function onValue(v) {
    if (v !== (capability == null ? void 0 : capability.value)) {
      if (!disabled) {
        dispatcher("value", v);
      }
    }
  }
  function slider_value_binding(value$1) {
    value = value$1;
    $$invalidate(1, value);
  }
  $$self.$$set = ($$props2) => {
    if ("capability" in $$props2)
      $$invalidate(0, capability = $$props2.capability);
    if ("controllable" in $$props2)
      $$invalidate(3, controllable = $$props2.controllable);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*controllable, $editing*/
    24) {
      $$invalidate(2, disabled = !controllable || $editing);
    }
    if ($$self.$$.dirty & /*capability*/
    1) {
      onCapability(capability);
    }
    if ($$self.$$.dirty & /*value*/
    2) {
      onValue(value);
    }
  };
  return [capability, value, disabled, controllable, $editing, slider_value_binding];
}
class Slider_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2U, create_fragment$2W, safe_not_equal, { capability: 0, controllable: 3 });
  }
}
function create_if_block$17(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$L, create_if_block_3$s, create_else_block_1$7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty & /*capability*/
    1)
      show_if = null;
    if (show_if == null)
      show_if = !!/*capability*/
      ctx2[0].id.startsWith("alarm_");
    if (show_if)
      return 0;
    if (
      /*capability*/
      ctx2[0].type === "boolean"
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block_1$7(ctx) {
  var _a2;
  let span;
  let t0;
  let t1;
  let t2_value = (
    /*capability*/
    (((_a2 = ctx[0]) == null ? void 0 : _a2.units) ?? "") + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t0 = text(
        /*value*/
        ctx[1]
      );
      t1 = space();
      t2 = text(t2_value);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(
        span_nodes,
        /*value*/
        ctx[1]
      );
      t1 = claim_space(span_nodes);
      t2 = claim_text(span_nodes, t2_value);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "whitespace-nowrap");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, t0);
      append_hydration(span, t1);
      append_hydration(span, t2);
    },
    p(ctx2, dirty) {
      var _a3;
      if (dirty & /*value*/
      2)
        set_data(
          t0,
          /*value*/
          ctx2[1]
        );
      if (dirty & /*capability*/
      1 && t2_value !== (t2_value = /*capability*/
      (((_a3 = ctx2[0]) == null ? void 0 : _a3.units) ?? "") + ""))
        set_data(t2, t2_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_3$s(ctx) {
  let span;
  let t_value = (
    /*value*/
    ctx[1] ? "Yes" : "No"
  );
  let t2;
  return {
    c() {
      span = element("span");
      t2 = text(t_value);
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t2 = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*value*/
      2 && t_value !== (t_value = /*value*/
      ctx2[1] ? "Yes" : "No"))
        set_data(t2, t_value);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1$L(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2$u, create_else_block$x];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*value*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$x(ctx) {
  let icon;
  let current;
  icon = new Icon$7({ props: { data: mdiCheck } });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    l(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_if_block_2$u(ctx) {
  let icon;
  let current;
  icon = new Icon$7({
    props: { style: "color: red;", data: mdiAlert }
  });
  return {
    c() {
      create_component(icon.$$.fragment);
    },
    l(nodes) {
      claim_component(icon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(icon, detaching);
    }
  };
}
function create_fragment$2V(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*capability*/
    ctx[0] !== void 0 && create_if_block$17(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*capability*/
        ctx2[0] !== void 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*capability*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$17(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$2T($$self, $$props, $$invalidate) {
  let value;
  let { capability } = $$props;
  let { controllable } = $$props;
  $$self.$$set = ($$props2) => {
    if ("capability" in $$props2)
      $$invalidate(0, capability = $$props2.capability);
    if ("controllable" in $$props2)
      $$invalidate(2, controllable = $$props2.controllable);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*capability*/
    1) {
      $$invalidate(1, value = capability == null ? void 0 : capability.value);
    }
  };
  return [capability, value, controllable];
}
class Sensor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2T, create_fragment$2V, safe_not_equal, { capability: 0, controllable: 2 });
  }
}
function create_else_block$w(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Null");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Null");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block$16(ctx) {
  let toggle;
  let updating_on;
  let current;
  function toggle_on_binding(value) {
    ctx[4](value);
  }
  let toggle_props = { name: "toggle" };
  if (
    /*value*/
    ctx[1] !== void 0
  ) {
    toggle_props.on = /*value*/
    ctx[1];
  }
  toggle = new Toggle({ props: toggle_props });
  binding_callbacks.push(() => bind(toggle, "on", toggle_on_binding));
  return {
    c() {
      create_component(toggle.$$.fragment);
    },
    l(nodes) {
      claim_component(toggle.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(toggle, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const toggle_changes = {};
      if (!updating_on && dirty & /*value*/
      2) {
        updating_on = true;
        toggle_changes.on = /*value*/
        ctx2[1];
        add_flush_callback(() => updating_on = false);
      }
      toggle.$set(toggle_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toggle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toggle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toggle, detaching);
    }
  };
}
function create_fragment$2U(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$16, create_else_block$w];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*capability*/
      ctx2[0] !== null && /*capability*/
      ctx2[0] !== void 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$2S($$self, $$props, $$invalidate) {
  let disabled;
  let $editing;
  component_subscribe($$self, editing, ($$value) => $$invalidate(3, $editing = $$value));
  const dispatcher = createEventDispatcher();
  let { capability } = $$props;
  let { controllable } = $$props;
  let value;
  function onCapability(c2) {
    $$invalidate(1, value = c2.value);
  }
  function onValue(v) {
    if (v !== (capability == null ? void 0 : capability.value)) {
      if (!disabled) {
        dispatcher("value", v);
      }
    }
  }
  function toggle_on_binding(value$1) {
    value = value$1;
    $$invalidate(1, value);
  }
  $$self.$$set = ($$props2) => {
    if ("capability" in $$props2)
      $$invalidate(0, capability = $$props2.capability);
    if ("controllable" in $$props2)
      $$invalidate(2, controllable = $$props2.controllable);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*controllable, $editing*/
    12) {
      disabled = !controllable || $editing;
    }
    if ($$self.$$.dirty & /*capability*/
    1) {
      onCapability(capability);
    }
    if ($$self.$$.dirty & /*value*/
    2) {
      onValue(value);
    }
  };
  return [capability, value, controllable, $editing, toggle_on_binding];
}
class Toggle_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2S, create_fragment$2U, safe_not_equal, { capability: 0, controllable: 2 });
  }
}
function create_if_block$15(ctx) {
  let button;
  let current;
  button = new Button$1({
    props: {
      type: "primary",
      disabled: (
        /*disabled*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot$i] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[5]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*disabled*/
      2)
        button_changes.disabled = /*disabled*/
        ctx2[1];
      if (dirty & /*$$scope, capability*/
      129) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot$i(ctx) {
  let t_value = (
    /*capability*/
    ctx[0].title + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    l(nodes) {
      t2 = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*capability*/
      1 && t_value !== (t_value = /*capability*/
      ctx2[0].title + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$2T(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*capability*/
    ctx[0] && create_if_block$15(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*capability*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*capability*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$15(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$2R($$self, $$props, $$invalidate) {
  let disabled;
  let $editing;
  component_subscribe($$self, editing, ($$value) => $$invalidate(4, $editing = $$value));
  const dispatcher = createEventDispatcher();
  let { capability } = $$props;
  let { controllable } = $$props;
  function setValue(value) {
    dispatcher("value", value);
  }
  const click_handler = () => setValue(true);
  $$self.$$set = ($$props2) => {
    if ("capability" in $$props2)
      $$invalidate(0, capability = $$props2.capability);
    if ("controllable" in $$props2)
      $$invalidate(3, controllable = $$props2.controllable);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*controllable, $editing*/
    24) {
      $$invalidate(1, disabled = !controllable || $editing);
    }
  };
  return [capability, disabled, setValue, controllable, $editing, click_handler];
}
class Button_1 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2R, create_fragment$2T, safe_not_equal, { capability: 0, controllable: 3 });
  }
}
function get_each_context$e(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  return child_ctx;
}
function create_else_block_1$6(ctx) {
  var _a2;
  let promise;
  let t0;
  let span;
  let t1_value = (
    /*device*/
    ((_a2 = ctx[1]) == null ? void 0 : _a2.name) + ""
  );
  let t1;
  let info2 = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$1,
    then: create_then_block$1,
    catch: create_catch_block$1,
    value: 16
  };
  handle_promise(promise = /*$homey*/
  ctx[4].baseUrl, info2);
  return {
    c() {
      info2.block.c();
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      this.h();
    },
    l(nodes) {
      info2.block.l(nodes);
      t0 = claim_space(nodes);
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "w-full overflow-hidden overflow-ellipsis");
    },
    m(target, anchor) {
      info2.block.m(target, info2.anchor = anchor);
      info2.mount = () => t0.parentNode;
      info2.anchor = t0;
      insert_hydration(target, t0, anchor);
      insert_hydration(target, span, anchor);
      append_hydration(span, t1);
    },
    p(new_ctx, dirty) {
      var _a3;
      ctx = new_ctx;
      info2.ctx = ctx;
      if (dirty & /*$homey*/
      16 && promise !== (promise = /*$homey*/
      ctx[4].baseUrl) && handle_promise(promise, info2))
        ;
      else {
        update_await_block_branch(info2, ctx, dirty);
      }
      if (dirty & /*device*/
      2 && t1_value !== (t1_value = /*device*/
      ((_a3 = ctx[1]) == null ? void 0 : _a3.name) + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(span);
      }
      info2.block.d(detaching);
      info2.token = null;
      info2 = null;
    }
  };
}
function create_if_block_3$r(ctx) {
  var _a2;
  let if_block_anchor;
  let if_block = (
    /*settings*/
    ((_a2 = ctx[0]) == null ? void 0 : _a2.deviceId) !== void 0 && create_if_block_4$l()
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      var _a3;
      if (
        /*settings*/
        ((_a3 = ctx2[0]) == null ? void 0 : _a3.deviceId) !== void 0
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_4$l();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_catch_block$1(ctx) {
  return {
    c: noop$1,
    l: noop$1,
    m: noop$1,
    p: noop$1,
    d: noop$1
  };
}
function create_then_block$1(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
      this.h();
    },
    h() {
      var _a2, _b2;
      attr(img, "class", "w-8 h-8 m-1");
      if (!src_url_equal(img.src, img_src_value = /*url*/
      ctx[16] + /*device*/
      ((_a2 = ctx[1]) == null ? void 0 : _a2.iconObj.url)))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*device*/
      (_b2 = ctx[1]) == null ? void 0 : _b2.icon);
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      if (dirty & /*$homey, device*/
      18 && !src_url_equal(img.src, img_src_value = /*url*/
      ctx2[16] + /*device*/
      ((_a2 = ctx2[1]) == null ? void 0 : _a2.iconObj.url))) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*device*/
      2 && img_alt_value !== (img_alt_value = /*device*/
      (_b2 = ctx2[1]) == null ? void 0 : _b2.icon)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_pending_block$1(ctx) {
  let t2;
  return {
    c() {
      t2 = text("...");
    },
    l(nodes) {
      t2 = claim_text(nodes, "...");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_4$l(ctx) {
  let span;
  let textContent = "Error";
  return {
    c() {
      span = element("span");
      span.textContent = textContent;
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-1azd6s8")
        span.textContent = textContent;
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_else_block$v(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*capabilities*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$e(get_each_context$e(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*getComponent, capabilities, controllable, setCapabilityValue, undefined*/
      108) {
        each_value = ensure_array_like(
          /*capabilities*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$e(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$e(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block$14(ctx) {
  let if_block_anchor;
  let if_block = (
    /*settings*/
    ctx[0].deviceId !== void 0 && create_if_block_1$K()
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (
        /*settings*/
        ctx2[0].deviceId !== void 0
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_1$K();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_2$t(ctx) {
  let div1;
  let div0;
  let t0_value = (
    /*capability*/
    ctx[13].title + ""
  );
  let t0;
  let t1;
  let switch_instance;
  let t2;
  let current;
  function value_handler(...args) {
    return (
      /*value_handler*/
      ctx[10](
        /*capability*/
        ctx[13],
        ...args
      )
    );
  }
  var switch_value = (
    /*getComponent*/
    ctx[6](
      /*capability*/
      ctx[13]
    )
  );
  function switch_props(ctx2) {
    return {
      props: {
        capability: (
          /*capability*/
          ctx2[13]
        ),
        controllable: (
          /*controllable*/
          ctx2[3]
        )
      }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    switch_instance.$on("value", value_handler);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t2 = space();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, t0_value);
      div0_nodes.forEach(detach);
      t1 = claim_space(div1_nodes);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div1_nodes);
      t2 = claim_space(div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "font-extralight overflow-clip overflow-ellipsis whitespace-nowrap");
      attr(div1, "class", "flex items-center justify-between w-full pl-1 pr-1 leading-none");
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      append_hydration(div1, div0);
      append_hydration(div0, t0);
      append_hydration(div1, t1);
      if (switch_instance)
        mount_component(switch_instance, div1, null);
      append_hydration(div1, t2);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /*capabilities*/
      4) && t0_value !== (t0_value = /*capability*/
      ctx[13].title + ""))
        set_data(t0, t0_value);
      const switch_instance_changes = {};
      if (dirty & /*capabilities*/
      4)
        switch_instance_changes.capability = /*capability*/
        ctx[13];
      if (dirty & /*controllable*/
      8)
        switch_instance_changes.controllable = /*controllable*/
        ctx[3];
      if (dirty & /*capabilities*/
      4 && switch_value !== (switch_value = /*getComponent*/
      ctx[6](
        /*capability*/
        ctx[13]
      ))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
          switch_instance.$on("value", value_handler);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div1, t2);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (switch_instance)
        destroy_component(switch_instance);
    }
  };
}
function create_each_block$e(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*capability*/
    ctx[13] !== void 0 && create_if_block_2$t(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*capability*/
        ctx2[13] !== void 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*capabilities*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$t(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_1$K(ctx) {
  let span;
  let textContent = "Device not found.";
  return {
    c() {
      span = element("span");
      span.textContent = textContent;
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-1kvxnjf")
        span.textContent = textContent;
      this.h();
    },
    h() {
      attr(span, "class", "w-full h-8 overflow-hidden overflow-ellipsis");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$2S(ctx) {
  let div0;
  let t2;
  let div1;
  let current_block_type_index;
  let if_block1;
  let current;
  function select_block_type(ctx2, dirty) {
    if (
      /*device*/
      ctx2[1] == void 0
    )
      return create_if_block_3$r;
    return create_else_block_1$6;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type(ctx);
  const if_block_creators = [create_if_block$14, create_else_block$v];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*device*/
      ctx2[1] === void 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div0 = element("div");
      if_block0.c();
      t2 = space();
      div1 = element("div");
      if_block1.c();
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block0.l(div0_nodes);
      div0_nodes.forEach(detach);
      t2 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if_block1.l(div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "flex items-center h-12");
      attr(div1, "class", "flex flex-col flex-grow w-full justify-evenly");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      if_block0.m(div0, null);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, div1, anchor);
      if_blocks[current_block_type_index].m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block1.c();
        } else {
          if_block1.p(ctx2, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(div1, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t2);
        detach(div1);
      }
      if_block0.d();
      if_blocks[current_block_type_index].d();
    }
  };
}
function instance$2Q($$self, $$props, $$invalidate) {
  let latestDevice;
  let controllable;
  let $scopes;
  let $devices;
  let $homey;
  component_subscribe($$self, scopes, ($$value) => $$invalidate(8, $scopes = $$value));
  component_subscribe($$self, devices, ($$value) => $$invalidate(9, $devices = $$value));
  component_subscribe($$self, homey, ($$value) => $$invalidate(4, $homey = $$value));
  let { settings } = $$props;
  let device;
  let capabilities = [];
  function onDevice(d3) {
    if (device !== void 0) {
      d3.off("capability", updateCapability);
    }
    if (d3 !== void 0) {
      $$invalidate(1, device = d3);
      $$invalidate(2, capabilities = (settings == null ? void 0 : settings.capabilityIds) !== void 0 ? settings.capabilityIds.map((cId) => device.capabilitiesObj[cId]) : []);
      d3.on("capability", updateCapability);
    }
  }
  function updateCapability(event) {
    if (device !== void 0) {
      const capability = device.capabilitiesObj[event.capabilityId];
      if (capability !== void 0) {
        $$invalidate(2, capabilities = [...capabilities]);
      }
    }
  }
  async function setCapabilityValue(capabilityId, value) {
    await device.setCapabilityValue({ deviceId: device.id, capabilityId, value });
  }
  function getComponent(capability) {
    if (capability === void 0) {
      return Sensor;
    }
    if (capability.setable) {
      switch (capability.type) {
        case "boolean":
          return capability.getable ? Toggle_1 : Button_1;
        case "number":
          return Slider_1;
        case "string":
        default:
          return Sensor;
      }
    }
    if (capability.getable) {
      switch (capability.type) {
        case "boolean":
        case "number":
        case "string":
        default:
          return Sensor;
      }
    }
    return Sensor;
  }
  const value_handler = (capability, e2) => setCapabilityValue(capability.id, e2.detail);
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(0, settings = $$props2.settings);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$devices, settings*/
    513) {
      $$invalidate(7, latestDevice = $devices[settings.deviceId ?? ""]);
    }
    if ($$self.$$.dirty & /*$scopes*/
    256) {
      $$invalidate(3, controllable = $scopes.includes("homey") || $scopes.includes("homey.device") || $scopes.includes("homey.device.control"));
    }
    if ($$self.$$.dirty & /*latestDevice*/
    128) {
      onDevice(latestDevice);
    }
  };
  return [
    settings,
    device,
    capabilities,
    controllable,
    $homey,
    setCapabilityValue,
    getComponent,
    latestDevice,
    $scopes,
    $devices,
    value_handler
  ];
}
class CapabilityWidget extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2Q, create_fragment$2S, safe_not_equal, { settings: 0 });
  }
}
function create$1() {
  return {
    id: v4(),
    type: "capability",
    version: 2
  };
}
function migrate$1(settings) {
  switch (settings.version) {
    case 2:
      return settings;
    case 1:
    default:
      return migrate_v1_v2$1(settings);
  }
}
function migrate_v1_v2$1(v1) {
  const settings = {
    id: v1.id,
    type: v1.type,
    version: 2,
    deviceId: v1.deviceId,
    capabilityIds: v1.capabilityId ? [v1.capabilityId] : []
  };
  return settings;
}
function get_each_context$d(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i2];
  return child_ctx;
}
function create_else_block$u(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*placeholder*/
        ctx[1]
      );
    },
    l(nodes) {
      t2 = claim_text(
        nodes,
        /*placeholder*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*placeholder*/
      2)
        set_data(
          t2,
          /*placeholder*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_2$s(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Flow not found");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Flow not found");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$J(ctx) {
  let t0_value = (
    /*selected*/
    ctx[5].folders + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*selected*/
    ctx[5].flow.name + ""
  );
  let t2;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" - ");
      t2 = text(t2_value);
    },
    l(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_text(nodes, " - ");
      t2 = claim_text(nodes, t2_value);
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*selected*/
      32 && t0_value !== (t0_value = /*selected*/
      ctx2[5].folders + ""))
        set_data(t0, t0_value);
      if (dirty & /*selected*/
      32 && t2_value !== (t2_value = /*selected*/
      ctx2[5].flow.name + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_default_slot_5$4(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*selected*/
      ctx2[5] !== void 0
    )
      return create_if_block_1$J;
    if (
      /*flowId*/
      ctx2[0] !== void 0
    )
      return create_if_block_2$s;
    return create_else_block$u;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_if_block$13(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      handleClose: (
        /*func*/
        ctx[12]
      ),
      $$slots: { content: [create_content_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    l(nodes) {
      claim_component(modal.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & /*open*/
      8)
        modal_changes.handleClose = /*func*/
        ctx2[12];
      if (dirty & /*$$scope, filtered, search*/
      1048596) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_default_slot_4$6(ctx) {
  let t0_value = (
    /*item*/
    ctx[17].folders + ""
  );
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
    },
    l(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*filtered*/
      16 && t0_value !== (t0_value = /*item*/
      ctx2[17].folders + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_title_slot$2(ctx) {
  let list_item_content_title;
  let current;
  list_item_content_title = new List$1.Item.Content.Title({
    props: {
      slot: "title",
      class: "flex",
      $$slots: { default: [create_default_slot_4$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list_item_content_title.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item_content_title.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item_content_title, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_item_content_title_changes = {};
      if (dirty & /*$$scope, filtered*/
      1048592) {
        list_item_content_title_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list_item_content_title.$set(list_item_content_title_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item_content_title.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item_content_title.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item_content_title, detaching);
    }
  };
}
function create_default_slot_3$8(ctx) {
  let t0_value = (
    /*item*/
    ctx[17].flow.name + ""
  );
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
    },
    l(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*filtered*/
      16 && t0_value !== (t0_value = /*item*/
      ctx2[17].flow.name + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_description_slot$1(ctx) {
  let list_item_content_description;
  let current;
  list_item_content_description = new List$1.Item.Content.Description({
    props: {
      slot: "description",
      $$slots: { default: [create_default_slot_3$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list_item_content_description.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item_content_description.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item_content_description, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_item_content_description_changes = {};
      if (dirty & /*$$scope, filtered*/
      1048592) {
        list_item_content_description_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list_item_content_description.$set(list_item_content_description_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item_content_description.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item_content_description.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item_content_description, detaching);
    }
  };
}
function create_content_slot_1$1(ctx) {
  let list_item_content;
  let current;
  list_item_content = new List$1.Item.Content({
    props: {
      slot: "content",
      $$slots: {
        description: [create_description_slot$1],
        title: [create_title_slot$2]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list_item_content.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item_content.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item_content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_item_content_changes = {};
      if (dirty & /*$$scope, filtered*/
      1048592) {
        list_item_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list_item_content.$set(list_item_content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item_content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item_content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item_content, detaching);
    }
  };
}
function create_each_block$d(ctx) {
  let list_item;
  let current;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[11](
        /*item*/
        ctx[17]
      )
    );
  }
  list_item = new List$1.Item({
    props: {
      class: "cursor-pointer",
      $$slots: { content: [create_content_slot_1$1] },
      $$scope: { ctx }
    }
  });
  list_item.$on("click", click_handler_1);
  return {
    c() {
      create_component(list_item.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const list_item_changes = {};
      if (dirty & /*$$scope, filtered*/
      1048592) {
        list_item_changes.$$scope = { dirty, ctx };
      }
      list_item.$set(list_item_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item, detaching);
    }
  };
}
function create_default_slot_2$a(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*filtered*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$d(get_each_context$d(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*onFlow, filtered*/
      80) {
        each_value = ensure_array_like(
          /*filtered*/
          ctx2[4]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$d(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$d(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_1$d(ctx) {
  let div0;
  let input;
  let updating_value;
  let t2;
  let div1;
  let list;
  let current;
  function input_value_binding(value) {
    ctx[10](value);
  }
  let input_props = { name: "search", placeholder: "Search" };
  if (
    /*search*/
    ctx[2] !== void 0
  ) {
    input_props.value = /*search*/
    ctx[2];
  }
  input = new Input({ props: input_props });
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  list = new List$1({
    props: {
      $$slots: { default: [create_default_slot_2$a] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div0 = element("div");
      create_component(input.$$.fragment);
      t2 = space();
      div1 = element("div");
      create_component(list.$$.fragment);
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", {});
      var div0_nodes = children(div0);
      claim_component(input.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t2 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(list.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div1, "class", "flex-grow overflow-auto");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      mount_component(input, div0, null);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, div1, anchor);
      mount_component(list, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const input_changes = {};
      if (!updating_value && dirty & /*search*/
      4) {
        updating_value = true;
        input_changes.value = /*search*/
        ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
      const list_changes = {};
      if (dirty & /*$$scope, filtered*/
      1048592) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t2);
        detach(div1);
      }
      destroy_component(input);
      destroy_component(list);
    }
  };
}
function create_body_slot$3(ctx) {
  let modal_content_body;
  let current;
  modal_content_body = new Modal.Content.Body({
    props: {
      slot: "body",
      class: "h-full flex flex-col",
      $$slots: { default: [create_default_slot_1$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal_content_body.$$.fragment);
    },
    l(nodes) {
      claim_component(modal_content_body.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal_content_body, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_content_body_changes = {};
      if (dirty & /*$$scope, filtered, search*/
      1048596) {
        modal_content_body_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal_content_body.$set(modal_content_body_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal_content_body.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal_content_body.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal_content_body, detaching);
    }
  };
}
function create_content_slot$4(ctx) {
  let modal_content;
  let current;
  modal_content = new Modal.Content({
    props: {
      slot: "content",
      $$slots: { body: [create_body_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal_content.$$.fragment);
    },
    l(nodes) {
      claim_component(modal_content.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal_content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_content_changes = {};
      if (dirty & /*$$scope, filtered, search*/
      1048596) {
        modal_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal_content.$set(modal_content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal_content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal_content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal_content, detaching);
    }
  };
}
function create_default_slot$h(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*open*/
    ctx[3] && create_if_block$13(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*open*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$2R(ctx) {
  let button;
  let t2;
  let portal;
  let current;
  button = new Button$1({
    props: {
      class: "w-full justify-start",
      $$slots: { default: [create_default_slot_5$4] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[9]
  );
  portal = new Portal({
    props: {
      $$slots: { default: [create_default_slot$h] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(button.$$.fragment);
      t2 = space();
      create_component(portal.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(portal.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      insert_hydration(target, t2, anchor);
      mount_component(portal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button_changes = {};
      if (dirty & /*$$scope, selected, flowId, placeholder*/
      1048611) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      const portal_changes = {};
      if (dirty & /*$$scope, open, filtered, search*/
      1048604) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal.$set(portal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      transition_in(portal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      transition_out(portal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(button, detaching);
      destroy_component(portal, detaching);
    }
  };
}
function instance$2P($$self, $$props, $$invalidate) {
  let sorted;
  let $flowFolders;
  component_subscribe($$self, flowFolders, ($$value) => $$invalidate(13, $flowFolders = $$value));
  let { flowId } = $$props;
  let { flows = [] } = $$props;
  let { placeholder = "Select flow" } = $$props;
  const dispatch = createEventDispatcher();
  let open = false;
  let search = "";
  let filtered = [];
  let selected;
  function filterFlows(value, s3) {
    const normalized = value.toLowerCase();
    if (value.length > 0) {
      $$invalidate(4, filtered = sorted.filter((d3) => d3.searchString.includes(normalized)));
    } else {
      $$invalidate(4, filtered = sorted);
    }
  }
  function onFlow(flow) {
    $$invalidate(0, flowId = flow.id);
    $$invalidate(3, open = false);
    dispatch("flowId", flowId);
  }
  function getFolders(folderId) {
    const folder = $flowFolders[folderId];
    if ((folder == null ? void 0 : folder.parent) !== void 0 && folder.parent !== null) {
      return getFolders(folder.parent) + "/" + folder.name;
    }
    return (folder == null ? void 0 : folder.name) ?? "";
  }
  const click_handler = () => $$invalidate(3, open = true);
  function input_value_binding(value) {
    search = value;
    $$invalidate(2, search);
  }
  const click_handler_1 = (item) => onFlow(item.flow);
  const func = () => $$invalidate(3, open = false);
  $$self.$$set = ($$props2) => {
    if ("flowId" in $$props2)
      $$invalidate(0, flowId = $$props2.flowId);
    if ("flows" in $$props2)
      $$invalidate(7, flows = $$props2.flows);
    if ("placeholder" in $$props2)
      $$invalidate(1, placeholder = $$props2.placeholder);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*flows*/
    128) {
      $$invalidate(8, sorted = (flows ?? []).map((flow) => {
        const folders = getFolders(flow.folder);
        return {
          flow,
          folders,
          searchString: `${folders} - ${flow.name}`.toLowerCase()
        };
      }).sort((a3, b2) => {
        if (a3.searchString === b2.searchString)
          return 0;
        if (a3.searchString < b2.searchString)
          return -1;
        return 1;
      }));
    }
    if ($$self.$$.dirty & /*flowId, sorted*/
    257) {
      $$invalidate(5, selected = flowId !== void 0 ? sorted.find((f) => f.flow.id === flowId) : void 0);
    }
    if ($$self.$$.dirty & /*search, sorted*/
    260) {
      filterFlows(search);
    }
  };
  return [
    flowId,
    placeholder,
    search,
    open,
    filtered,
    selected,
    onFlow,
    flows,
    sorted,
    click_handler,
    input_value_binding,
    click_handler_1,
    func
  ];
}
class FlowPicker extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2P, create_fragment$2R, safe_not_equal, { flowId: 0, flows: 7, placeholder: 1 });
  }
}
function create_fragment$2Q(ctx) {
  let flowpicker;
  let updating_flowId;
  let current;
  function flowpicker_flowId_binding(value) {
    ctx[5](value);
  }
  let flowpicker_props = { flows: (
    /*flows*/
    ctx[1]
  ) };
  if (
    /*flowId*/
    ctx[0] !== void 0
  ) {
    flowpicker_props.flowId = /*flowId*/
    ctx[0];
  }
  flowpicker = new FlowPicker({ props: flowpicker_props });
  binding_callbacks.push(() => bind(flowpicker, "flowId", flowpicker_flowId_binding));
  return {
    c() {
      create_component(flowpicker.$$.fragment);
    },
    l(nodes) {
      claim_component(flowpicker.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(flowpicker, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const flowpicker_changes = {};
      if (dirty & /*flows*/
      2)
        flowpicker_changes.flows = /*flows*/
        ctx2[1];
      if (!updating_flowId && dirty & /*flowId*/
      1) {
        updating_flowId = true;
        flowpicker_changes.flowId = /*flowId*/
        ctx2[0];
        add_flush_callback(() => updating_flowId = false);
      }
      flowpicker.$set(flowpicker_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(flowpicker.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(flowpicker.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(flowpicker, detaching);
    }
  };
}
function instance$2O($$self, $$props, $$invalidate) {
  let flows;
  let $advancedFlows;
  let $basicFlows;
  component_subscribe($$self, advancedFlows, ($$value) => $$invalidate(3, $advancedFlows = $$value));
  component_subscribe($$self, basicFlows, ($$value) => $$invalidate(4, $basicFlows = $$value));
  let { settings } = $$props;
  const dispatch = createEventDispatcher();
  let flowId;
  onMount(() => {
    if (settings.flowId) {
      $$invalidate(0, flowId = settings.flowId);
    }
  });
  function onFlow(value) {
    if (value === void 0 || value === settings.flowId) {
      return;
    }
    $$invalidate(2, settings.flowId = value, settings);
    dispatch("settings", settings);
  }
  function flowpicker_flowId_binding(value) {
    flowId = value;
    $$invalidate(0, flowId);
  }
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(2, settings = $$props2.settings);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$basicFlows, $advancedFlows*/
    24) {
      $$invalidate(1, flows = Object.values($basicFlows).concat(Object.values($advancedFlows)).filter((f) => f.triggerable).sort((a3, b2) => {
        if (a3.name === b2.name)
          return 0;
        if (a3.name < b2.name)
          return -1;
        return 1;
      }));
    }
    if ($$self.$$.dirty & /*flowId*/
    1) {
      onFlow(flowId);
    }
  };
  return [
    flowId,
    flows,
    settings,
    $advancedFlows,
    $basicFlows,
    flowpicker_flowId_binding
  ];
}
class FlowEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2O, create_fragment$2Q, safe_not_equal, { settings: 2 });
  }
}
function create_else_block$t(ctx) {
  let div1;
  let button;
  let t0;
  let div0;
  let t1_value = (
    /*flow*/
    ctx[0].name + ""
  );
  let t1;
  let current;
  button = new Button$1({
    props: {
      class: "my-auto ml-1",
      type: "primary",
      shape: "circle",
      size: "fab",
      $$slots: { icon: [create_icon_slot$2] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[5]
  );
  return {
    c() {
      div1 = element("div");
      create_component(button.$$.fragment);
      t0 = space();
      div0 = element("div");
      t1 = text(t1_value);
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(button.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, t1_value);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "my-auto ml-3 mr-1");
      attr(div1, "class", "flex content-center h-full");
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      mount_component(button, div1, null);
      append_hydration(div1, t0);
      append_hydration(div1, div0);
      append_hydration(div0, t1);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope*/
      256) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      if ((!current || dirty & /*flow*/
      1) && t1_value !== (t1_value = /*flow*/
      ctx2[0].name + ""))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(button);
    }
  };
}
function create_if_block$12(ctx) {
  let span;
  let textContent = "Error";
  return {
    c() {
      span = element("span");
      span.textContent = textContent;
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-1azd6s8")
        span.textContent = textContent;
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_icon_slot$2(ctx) {
  let button_icon;
  let current;
  button_icon = new Button$1.Icon({ props: { slot: "icon", data: mdiPlay } });
  return {
    c() {
      create_component(button_icon.$$.fragment);
    },
    l(nodes) {
      claim_component(button_icon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button_icon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(button_icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button_icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button_icon, detaching);
    }
  };
}
function create_fragment$2P(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$12, create_else_block$t];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*flow*/
      ctx2[0] === void 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$2N($$self, $$props, $$invalidate) {
  let flow;
  let $homey;
  let $advancedFlows;
  let $basicFlows;
  let $editing;
  component_subscribe($$self, homey, ($$value) => $$invalidate(6, $homey = $$value));
  component_subscribe($$self, advancedFlows, ($$value) => $$invalidate(3, $advancedFlows = $$value));
  component_subscribe($$self, basicFlows, ($$value) => $$invalidate(4, $basicFlows = $$value));
  component_subscribe($$self, editing, ($$value) => $$invalidate(7, $editing = $$value));
  let { settings } = $$props;
  async function triggerFlow() {
    if (!$editing && flow !== void 0) {
      if ($basicFlows[flow.id]) {
        await $homey.flow.triggerFlow({ id: flow.id });
      } else if ($advancedFlows[flow.id]) {
        await $homey.flow.triggerAdvancedFlow({ id: flow.id });
      }
    }
  }
  const click_handler = () => triggerFlow();
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(2, settings = $$props2.settings);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*settings, $basicFlows, $advancedFlows*/
    28) {
      $$invalidate(0, flow = (settings == null ? void 0 : settings.flowId) !== void 0 ? $basicFlows[settings.flowId] ?? $advancedFlows[settings.flowId] : void 0);
    }
  };
  return [flow, triggerFlow, settings, $advancedFlows, $basicFlows, click_handler];
}
class FlowWidget extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2N, create_fragment$2P, safe_not_equal, { settings: 2 });
  }
}
function create_else_block$s(ctx) {
  let t2;
  let await_block_anchor;
  let promise;
  let if_block = !/*hideTitle*/
  ctx[4] && create_if_block_3$q(ctx);
  let info2 = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 10
  };
  handle_promise(promise = /*$homey*/
  ctx[6].baseUrl, info2);
  return {
    c() {
      if (if_block)
        if_block.c();
      t2 = space();
      await_block_anchor = empty();
      info2.block.c();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      t2 = claim_space(nodes);
      await_block_anchor = empty();
      info2.block.l(nodes);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, await_block_anchor, anchor);
      info2.block.m(target, info2.anchor = anchor);
      info2.mount = () => await_block_anchor.parentNode;
      info2.anchor = await_block_anchor;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!/*hideTitle*/
      ctx[4]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_3$q(ctx);
          if_block.c();
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      info2.ctx = ctx;
      if (dirty & /*$homey*/
      64 && promise !== (promise = /*$homey*/
      ctx[6].baseUrl) && handle_promise(promise, info2))
        ;
      else {
        update_await_block_branch(info2, ctx, dirty);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(await_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      info2.block.d(detaching);
      info2.token = null;
      info2 = null;
    }
  };
}
function create_if_block$11(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*device*/
      ctx2[0] === void 0
    )
      return create_if_block_1$I;
    if (
      /*image*/
      ctx2[5] === void 0
    )
      return create_if_block_2$r;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type_1(ctx2))) {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) {
        if_block.d(detaching);
      }
    }
  };
}
function create_if_block_3$q(ctx) {
  var _a2, _b2;
  let div2;
  let div0;
  let t0_value = (
    /*device*/
    ((_a2 = ctx[0]) == null ? void 0 : _a2.name) + ""
  );
  let t0;
  let t1;
  let div1;
  let t2_value = (
    /*image*/
    ((_b2 = ctx[5]) == null ? void 0 : _b2.title) + ""
  );
  let t2;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", {});
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, t0_value);
      div0_nodes.forEach(detach);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(div1_nodes, t2_value);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div1, "class", "ml-4 font-extralight");
      attr(div2, "class", "flex pl-2 pb-2 absolute left-0 bottom-0 w-full rounded-bl-md rounded-br-md");
      set_style(
        div2,
        "color",
        /*fontColor*/
        ctx[3]
      );
      toggle_class(
        div2,
        "backdrop-blur",
        /*fontBlur*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, div0);
      append_hydration(div0, t0);
      append_hydration(div2, t1);
      append_hydration(div2, div1);
      append_hydration(div1, t2);
    },
    p(ctx2, dirty) {
      var _a3, _b3;
      if (dirty & /*device*/
      1 && t0_value !== (t0_value = /*device*/
      ((_a3 = ctx2[0]) == null ? void 0 : _a3.name) + ""))
        set_data(t0, t0_value);
      if (dirty & /*image*/
      32 && t2_value !== (t2_value = /*image*/
      ((_b3 = ctx2[5]) == null ? void 0 : _b3.title) + ""))
        set_data(t2, t2_value);
      if (dirty & /*fontColor*/
      8) {
        set_style(
          div2,
          "color",
          /*fontColor*/
          ctx2[3]
        );
      }
      if (dirty & /*fontBlur*/
      4) {
        toggle_class(
          div2,
          "backdrop-blur",
          /*fontBlur*/
          ctx2[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_catch_block(ctx) {
  return {
    c: noop$1,
    l: noop$1,
    m: noop$1,
    p: noop$1,
    d: noop$1
  };
}
function create_then_block(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
      this.h();
    },
    h() {
      attr(img, "class", "w-full h-full rounded-md");
      if (!src_url_equal(img.src, img_src_value = /*url*/
      ctx[10] + /*image*/
      ctx[5].imageObj.url + "?v=" + /*refreshSlug*/
      ctx[1]))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*image*/
      ctx[5].title + " refreshed: " + /*refreshSlug*/
      ctx[1]);
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*$homey, image, refreshSlug*/
      98 && !src_url_equal(img.src, img_src_value = /*url*/
      ctx2[10] + /*image*/
      ctx2[5].imageObj.url + "?v=" + /*refreshSlug*/
      ctx2[1])) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*image, refreshSlug*/
      34 && img_alt_value !== (img_alt_value = /*image*/
      ctx2[5].title + " refreshed: " + /*refreshSlug*/
      ctx2[1])) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_pending_block(ctx) {
  let t2;
  return {
    c() {
      t2 = text("...");
    },
    l(nodes) {
      t2 = claim_text(nodes, "...");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_2$r(ctx) {
  let span;
  let textContent = "Error: image not found";
  return {
    c() {
      span = element("span");
      span.textContent = textContent;
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-6jz0ye")
        span.textContent = textContent;
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1$I(ctx) {
  let span;
  let textContent = "Error: device not found";
  return {
    c() {
      span = element("span");
      span.textContent = textContent;
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-413me7")
        span.textContent = textContent;
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$2O(ctx) {
  let div2;
  function select_block_type(ctx2, dirty) {
    if (
      /*device*/
      ctx2[0] === void 0 || /*image*/
      ctx2[5] === void 0
    )
      return create_if_block$11;
    return create_else_block$s;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "relative w-full h-full");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if_block.m(div2, null);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div2, null);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if_block.d();
    }
  };
}
function instance$2M($$self, $$props, $$invalidate) {
  let device;
  let image;
  let hideTitle;
  let fontColor;
  let fontBlur;
  let $devices;
  let $homey;
  component_subscribe($$self, devices, ($$value) => $$invalidate(9, $devices = $$value));
  component_subscribe($$self, homey, ($$value) => $$invalidate(6, $homey = $$value));
  let { settings } = $$props;
  let refreshSlug = 0;
  let refreshClear;
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(7, settings = $$props2.settings);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$devices, settings*/
    640) {
      $$invalidate(0, device = $devices[settings.deviceId ?? ""]);
    }
    if ($$self.$$.dirty & /*device, settings*/
    129) {
      $$invalidate(5, image = device == null ? void 0 : device.images.find((image2) => image2.id === settings.imageId));
    }
    if ($$self.$$.dirty & /*refreshClear, settings*/
    384) {
      {
        if (refreshClear !== void 0)
          clearInterval(refreshClear);
        if (settings.refresh !== void 0 && settings.refresh > 0) {
          $$invalidate(8, refreshClear = setInterval(
            () => {
              $$invalidate(1, refreshSlug = Date.now());
            },
            settings.refresh * 1e3
          ));
        }
      }
    }
    if ($$self.$$.dirty & /*settings*/
    128) {
      $$invalidate(4, hideTitle = (settings == null ? void 0 : settings.hideTitle) ?? false);
    }
    if ($$self.$$.dirty & /*settings*/
    128) {
      $$invalidate(3, fontColor = (settings == null ? void 0 : settings.fontColor) ? settings.fontColor : "black");
    }
    if ($$self.$$.dirty & /*settings*/
    128) {
      $$invalidate(2, fontBlur = (settings == null ? void 0 : settings.fontBlur) ?? false);
    }
  };
  return [
    device,
    refreshSlug,
    fontBlur,
    fontColor,
    hideTitle,
    image,
    $homey,
    settings,
    refreshClear,
    $devices
  ];
}
class ImageWidget extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2M, create_fragment$2O, safe_not_equal, { settings: 7 });
  }
}
function create_fragment$2N(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$22 = "rounded-md divide-y divide-border border border-border";
function instance$2L($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$22, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Accordion$1 = class Accordion extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2L, create_fragment$2N, safe_not_equal, { use: 0 });
  }
};
const get_content_slot_changes$3 = (dirty) => ({});
const get_content_slot_context$3 = (ctx) => ({});
const get_title_slot_changes$8 = (dirty) => ({});
const get_title_slot_context$8 = (ctx) => ({});
function create_if_block$10(ctx) {
  let current;
  const content_slot_template = (
    /*#slots*/
    ctx[6].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_content_slot_context$3
  );
  return {
    c() {
      if (content_slot)
        content_slot.c();
    },
    l(nodes) {
      if (content_slot)
        content_slot.l(nodes);
    },
    m(target, anchor) {
      if (content_slot) {
        content_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (content_slot) {
        if (content_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_content_slot_changes$3
            ),
            get_content_slot_context$3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(content_slot, local);
      current = true;
    },
    o(local) {
      transition_out(content_slot, local);
      current = false;
    },
    d(detaching) {
      if (content_slot)
        content_slot.d(detaching);
    }
  };
}
function create_fragment$2M(ctx) {
  let div2;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[6].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_title_slot_context$8
  );
  let if_block = (
    /*open*/
    ctx[1] && create_if_block$10(ctx)
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (title_slot)
        title_slot.c();
      t2 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (title_slot)
        title_slot.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (title_slot) {
        title_slot.m(div2, null);
      }
      append_hydration(div2, t2);
      if (if_block)
        if_block.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_title_slot_changes$8
            ),
            get_title_slot_context$8
          );
        }
      }
      if (
        /*open*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$10(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (title_slot)
        title_slot.d(detaching);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$21 = "bg-surface first-of-type:rounded-t-md last-of-type:rounded-b-md overflow-hidden outline-none focus:outline-none";
function instance$2K($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { open = false } = $$props;
  const itemOpen = writable(open);
  setContext("accordion-open", itemOpen);
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("open" in $$new_props)
      $$invalidate(1, open = $$new_props.open);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*open*/
    2) {
      itemOpen.set(open);
    }
    $$invalidate(2, finalClass = twMerge(defaultClass$21, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, open, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Item$4 = class Item extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2K, create_fragment$2M, safe_not_equal, { use: 0, open: 1 });
  }
};
function create_fragment$2L(ctx) {
  let button;
  let t2;
  let span;
  let icon;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  icon = new Icon$7({ props: { data: chevron_down } });
  let button_levels = [
    { "aria-label": "Accordion Item Toggle" },
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    { type: "button" },
    exclude(
      /*$$props*/
      ctx[5],
      ["use", "class"]
    )
  ];
  let button_data = {};
  for (let i2 = 0; i2 < button_levels.length; i2 += 1) {
    button_data = assign$1(button_data, button_levels[i2]);
  }
  return {
    c() {
      button = element("button");
      if (default_slot)
        default_slot.c();
      t2 = space();
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", {
        "aria-label": true,
        class: true,
        type: true
      });
      var button_nodes = children(button);
      if (default_slot)
        default_slot.l(button_nodes);
      t2 = claim_space(button_nodes);
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "transition-transform duration-300");
      toggle_class(
        span,
        "-rotate-180",
        /*$open*/
        ctx[2]
      );
      set_attributes(button, button_data);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      append_hydration(button, t2);
      append_hydration(button, span);
      mount_component(icon, span, null);
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            button,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, button)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$open*/
      4) {
        toggle_class(
          span,
          "-rotate-180",
          /*$open*/
          ctx2[2]
        );
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { "aria-label": "Accordion Item Toggle" },
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        { type: "button" },
        dirty & /*$$props*/
        32 && exclude(
          /*$$props*/
          ctx2[5],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(icon);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$20 = "relative flex items-center w-full py-4 px-5 text-base text-content hover:text-primary text-left bg-surface border-0 rounded-none justify-between outline-none focus:outline-none";
function instance$2J($$self, $$props, $$invalidate) {
  let finalClass;
  let $open;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const open = getContext("accordion-open");
  component_subscribe($$self, open, (value) => $$invalidate(2, $open = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$20, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, $open, forwardEvents, open, $$props, $$scope, slots];
}
let Title$9 = class Title extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2J, create_fragment$2L, safe_not_equal, { use: 0 });
  }
};
function create_fragment$2K(ctx) {
  let div2;
  let useActions_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, slide, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, slide, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1$ = "border-t border-border text-secondary-content";
function instance$2I($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1$, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Content$4 = class Content2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2I, create_fragment$2K, safe_not_equal, { use: 0 });
  }
};
const Accordion2 = Accordion$1;
Accordion2.Item = Item$4;
Accordion2.Item.Title = Title$9;
Accordion2.Item.Content = Content$4;
const get_extra_slot_changes$6 = (dirty) => ({});
const get_extra_slot_context$6 = (ctx) => ({});
const get_description_slot_changes$7 = (dirty) => ({});
const get_description_slot_context$7 = (ctx) => ({});
const get_title_slot_changes$7 = (dirty) => ({});
const get_title_slot_context$7 = (ctx) => ({});
const get_leading_slot_changes$9 = (dirty) => ({});
const get_leading_slot_context$9 = (ctx) => ({});
function create_if_block_1$H(ctx) {
  let div2;
  let current;
  const leading_slot_template = (
    /*#slots*/
    ctx[8].leading
  );
  const leading_slot = create_slot(
    leading_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_leading_slot_context$9
  );
  return {
    c() {
      div2 = element("div");
      if (leading_slot)
        leading_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (leading_slot)
        leading_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(
        div2,
        "class",
        /*finalLeadingClass*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (leading_slot) {
        leading_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (leading_slot) {
        if (leading_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            leading_slot,
            leading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              leading_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_leading_slot_changes$9
            ),
            get_leading_slot_context$9
          );
        }
      }
      if (!current || dirty & /*finalLeadingClass*/
      2) {
        attr(
          div2,
          "class",
          /*finalLeadingClass*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leading_slot, local);
      current = true;
    },
    o(local) {
      transition_out(leading_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (leading_slot)
        leading_slot.d(detaching);
    }
  };
}
function create_if_block$$(ctx) {
  let div2;
  let t2;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[8].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_title_slot_context$7
  );
  const description_slot_template = (
    /*#slots*/
    ctx[8].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_description_slot_context$7
  );
  return {
    c() {
      div2 = element("div");
      if (title_slot)
        title_slot.c();
      t2 = space();
      if (description_slot)
        description_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (title_slot)
        title_slot.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (description_slot)
        description_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "flex items-start flex-col w-full");
      toggle_class(
        div2,
        "ml-3",
        /*$$slots*/
        ctx[4].leading
      );
      toggle_class(
        div2,
        "justify-start",
        /*$$slots*/
        ctx[4].description
      );
      toggle_class(div2, "justify-center", !/*$$slots*/
      ctx[4].description);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (title_slot) {
        title_slot.m(div2, null);
      }
      append_hydration(div2, t2);
      if (description_slot) {
        description_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_title_slot_changes$7
            ),
            get_title_slot_context$7
          );
        }
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_description_slot_changes$7
            ),
            get_description_slot_context$7
          );
        }
      }
      if (!current || dirty & /*$$slots*/
      16) {
        toggle_class(
          div2,
          "ml-3",
          /*$$slots*/
          ctx2[4].leading
        );
      }
      if (!current || dirty & /*$$slots*/
      16) {
        toggle_class(
          div2,
          "justify-start",
          /*$$slots*/
          ctx2[4].description
        );
      }
      if (!current || dirty & /*$$slots*/
      16) {
        toggle_class(div2, "justify-center", !/*$$slots*/
        ctx2[4].description);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(description_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      transition_out(description_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (title_slot)
        title_slot.d(detaching);
      if (description_slot)
        description_slot.d(detaching);
    }
  };
}
function create_fragment$2J(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[4].leading && create_if_block_1$H(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    (ctx[4].title || /*$$slots*/
    ctx[4].description) && create_if_block$$(ctx)
  );
  const extra_slot_template = (
    /*#slots*/
    ctx[8].extra
  );
  const extra_slot = create_slot(
    extra_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_extra_slot_context$6
  );
  let div1_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[5],
      ["use", "class"]
    )
  ];
  let div_data_1 = {};
  for (let i2 = 0; i2 < div1_levels.length; i2 += 1) {
    div_data_1 = assign$1(div_data_1, div1_levels[i2]);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (extra_slot)
        extra_slot.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (extra_slot)
        extra_slot.l(div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "flex relative");
      set_attributes(div1, div_data_1);
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      append_hydration(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration(div0, t0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration(div0, t1);
      if (extra_slot) {
        extra_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div1,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, div1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[4].leading
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$H(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[4].title || /*$$slots*/
        ctx2[4].description
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$$(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (extra_slot) {
        if (extra_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            extra_slot,
            extra_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              extra_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_extra_slot_changes$6
            ),
            get_extra_slot_context$6
          );
        }
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        32 && exclude(
          /*$$props*/
          ctx2[5],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(extra_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(extra_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (extra_slot)
        extra_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1_ = "rounded-md p-4";
const defaultLeadingClass = "flex-grow flex flex-col w-6 flex items-center";
function instance$2H($$self, $$props, $$invalidate) {
  let finalClass;
  let finalLeadingClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { type = "info" } = $$props;
  const currentType = writable(type);
  setContext("alert-type", currentType);
  setContext("alert-description", $$slots.description ? true : false);
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("type" in $$new_props)
      $$invalidate(6, type = $$new_props.type);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*type*/
    64) {
      currentType.set(type);
    }
    $$invalidate(2, finalClass = twMerge(defaultClass$1_, type === "info" ? "bg-info" : false, type === "warn" ? "bg-warn" : false, type === "success" ? "bg-success" : false, type === "error" ? "bg-error" : false, $$props.class));
    if ($$self.$$.dirty & /*type*/
    64) {
      $$invalidate(1, finalLeadingClass = twMerge(defaultLeadingClass, type === "info" ? "text-info-icon" : false, type === "warn" ? "text-warn-icon" : false, type === "success" ? "text-success-icon" : false, type === "error" ? "text-error-icon" : false, $$slots.description ? "justify-start h-6" : "justify-center"));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    finalLeadingClass,
    finalClass,
    forwardEvents,
    $$slots,
    $$props,
    type,
    $$scope,
    slots
  ];
}
let Alert$1 = class Alert extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2H, create_fragment$2J, safe_not_equal, { use: 0, type: 6 });
  }
};
const get_extra_slot_changes$5 = (dirty) => ({});
const get_extra_slot_context$5 = (ctx) => ({});
function create_fragment$2I(ctx) {
  let h4;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const extra_slot_template = (
    /*#slots*/
    ctx[7].extra
  );
  const extra_slot = create_slot(
    extra_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_extra_slot_context$5
  );
  let h4_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let h4_data = {};
  for (let i2 = 0; i2 < h4_levels.length; i2 += 1) {
    h4_data = assign$1(h4_data, h4_levels[i2]);
  }
  return {
    c() {
      h4 = element("h4");
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (extra_slot)
        extra_slot.c();
      this.h();
    },
    l(nodes) {
      h4 = claim_element(nodes, "H4", { class: true });
      var h4_nodes = children(h4);
      if (default_slot)
        default_slot.l(h4_nodes);
      t2 = claim_space(h4_nodes);
      if (extra_slot)
        extra_slot.l(h4_nodes);
      h4_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(h4, h4_data);
    },
    m(target, anchor) {
      insert_hydration(target, h4, anchor);
      if (default_slot) {
        default_slot.m(h4, null);
      }
      append_hydration(h4, t2);
      if (extra_slot) {
        extra_slot.m(h4, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            h4,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, h4)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (extra_slot) {
        if (extra_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            extra_slot,
            extra_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              extra_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_extra_slot_changes$5
            ),
            get_extra_slot_context$5
          );
        }
      }
      set_attributes(h4, h4_data = get_spread_update(h4_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(extra_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(extra_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h4);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (extra_slot)
        extra_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1Z = "mb-0 flex flex-row items-start justify-between w-full relative";
const infoClass$5 = "text-info-content";
const warnClass$5 = "text-warn-content";
const successClass$5 = "text-success-content";
const errorClass$b = "text-error-content";
function instance$2G($$self, $$props, $$invalidate) {
  let finalClass;
  let $type;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const type = getContext("alert-type");
  component_subscribe($$self, type, (value) => $$invalidate(5, $type = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1Z, $type === "info" ? infoClass$5 : false, $type === "warn" ? warnClass$5 : false, $type === "success" ? successClass$5 : false, $type === "error" ? errorClass$b : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, type, $$props, $type, $$scope, slots];
}
let Title$8 = class Title2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2G, create_fragment$2I, safe_not_equal, { use: 0 });
  }
};
function create_fragment$2H(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1Y = "text-sm";
const infoClass$4 = "text-info-secondary-content";
const warnClass$4 = "text-warn-secondary-content";
const successClass$4 = "text-success-secondary-content";
const errorClass$a = "text-error-secondary-content";
function instance$2F($$self, $$props, $$invalidate) {
  let finalClass;
  let $type;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const type = getContext("alert-type");
  component_subscribe($$self, type, (value) => $$invalidate(5, $type = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1Y, $type === "info" ? infoClass$4 : false, $type === "warn" ? warnClass$4 : false, $type === "success" ? successClass$4 : false, $type === "error" ? errorClass$a : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, type, $$props, $type, $$scope, slots];
}
let Description$7 = class Description extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2F, create_fragment$2H, safe_not_equal, { use: 0 });
  }
};
function create_fragment$2G(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1X = "flex-shrink-0 flex items-center justify-center";
const infoClass$3 = "text-info-icon ";
const warnClass$3 = "text-warn-icon";
const successClass$3 = "text-success-icon";
const errorClass$9 = "text-error-icon";
function instance$2E($$self, $$props, $$invalidate) {
  let finalClass;
  let $type;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const type = getContext("alert-type");
  component_subscribe($$self, type, (value) => $$invalidate(5, $type = value));
  const alertDescription = getContext("alert-description");
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1X, $type === "info" ? infoClass$3 : false, $type === "warn" ? warnClass$3 : false, $type === "success" ? successClass$3 : false, $type === "error" ? errorClass$9 : false, alertDescription ? "absolute -top-2 -right-2" : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, type, $$props, $type, $$scope, slots];
}
let Extra$2 = class Extra extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2E, create_fragment$2G, safe_not_equal, { use: 0 });
  }
};
const Alert2 = Alert$1;
Alert2.Title = Title$8;
Alert2.Description = Description$7;
Alert2.Leading = Icon$7;
Alert2.Extra = Extra$2;
const get_options_slot_changes_1$1 = (dirty) => ({});
const get_options_slot_context_1$1 = (ctx) => ({});
const get_options_slot_changes$1 = (dirty) => ({});
const get_options_slot_context$1 = (ctx) => ({});
const get_leading_slot_changes$8 = (dirty) => ({});
const get_leading_slot_context$8 = (ctx) => ({});
const get_label_slot_changes$d = (dirty) => ({});
const get_label_slot_context$d = (ctx) => ({});
function create_if_block_5$i(ctx) {
  let span;
  let current;
  const leading_slot_template = (
    /*#slots*/
    ctx[20].leading
  );
  const leading_slot = create_slot(
    leading_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_leading_slot_context$8
  );
  return {
    c() {
      span = element("span");
      if (leading_slot)
        leading_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (leading_slot)
        leading_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none");
      toggle_class(
        span,
        "text-danger",
        /*error*/
        ctx[3]
      );
      toggle_class(span, "text-secondary-content", !/*error*/
      ctx[3]);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (leading_slot) {
        leading_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (leading_slot) {
        if (leading_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            leading_slot,
            leading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              leading_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_leading_slot_changes$8
            ),
            get_leading_slot_context$8
          );
        }
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(
          span,
          "text-danger",
          /*error*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(span, "text-secondary-content", !/*error*/
        ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leading_slot, local);
      current = true;
    },
    o(local) {
      transition_out(leading_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (leading_slot)
        leading_slot.d(detaching);
    }
  };
}
function create_if_block_4$k(ctx) {
  let button;
  let span;
  let icon;
  let span_transition;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$7({ props: { data: close } });
  return {
    c() {
      button = element("button");
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        class: true
      });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "flex items-center text-content");
      attr(button, "type", "button");
      attr(button, "aria-label", "clear input");
      attr(button, "class", "absolute inset-y-0 right-8 items-center hidden group-focus-within:flex active:flex text-secondary-content");
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, span);
      mount_component(icon, span, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handleClear*/
          ctx[14]
        );
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!span_transition)
            span_transition = create_bidirectional_transition(span, scale, {}, true);
          span_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      if (local) {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, scale, {}, false);
        span_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(icon);
      if (detaching && span_transition)
        span_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block$r(ctx) {
  let span;
  let icon;
  let current;
  icon = new Icon$7({ props: { data: unfold_more_horizontal } });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none text-secondary-content");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block_3$p(ctx) {
  let span;
  let icon;
  let current;
  icon = new Icon$7({ props: { data: error } });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block_2$q(ctx) {
  let current;
  const options_slot_template = (
    /*#slots*/
    ctx[20].options
  );
  const options_slot = create_slot(
    options_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_options_slot_context_1$1
  );
  return {
    c() {
      if (options_slot)
        options_slot.c();
    },
    l(nodes) {
      if (options_slot)
        options_slot.l(nodes);
    },
    m(target, anchor) {
      if (options_slot) {
        options_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (options_slot) {
        if (options_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            options_slot,
            options_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              options_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_options_slot_changes_1$1
            ),
            get_options_slot_context_1$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(options_slot, local);
      current = true;
    },
    o(local) {
      transition_out(options_slot, local);
      current = false;
    },
    d(detaching) {
      if (options_slot)
        options_slot.d(detaching);
    }
  };
}
function create_if_block_1$G(ctx) {
  let portal;
  let current;
  portal = new Portal({
    props: {
      $$slots: { default: [create_default_slot$g] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portal.$$.fragment);
    },
    l(nodes) {
      claim_component(portal.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(portal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portal_changes = {};
      if (dirty[0] & /*$$scope, name, placeholder, disabled, value, error, $$slots*/
      268501053) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal.$set(portal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portal, detaching);
    }
  };
}
function create_default_slot_1$c(ctx) {
  let div0;
  let input_1;
  let input_1_name_value;
  let input_1_id_value;
  let t2;
  let div1;
  let current;
  let mounted;
  let dispose;
  const options_slot_template = (
    /*#slots*/
    ctx[20].options
  );
  const options_slot = create_slot(
    options_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_options_slot_context$1
  );
  return {
    c() {
      div0 = element("div");
      input_1 = element("input");
      t2 = space();
      div1 = element("div");
      if (options_slot)
        options_slot.c();
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input_1 = claim_element(div0_nodes, "INPUT", {
        name: true,
        id: true,
        placeholder: true,
        autocomplete: true,
        role: true,
        "aria-controls": true,
        class: true
      });
      div0_nodes.forEach(detach);
      t2 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (options_slot)
        options_slot.l(div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(input_1, "name", input_1_name_value = `${/*name*/
      ctx[2]}-mobile`);
      attr(input_1, "id", input_1_id_value = `${/*name*/
      ctx[2]}-mobile`);
      attr(
        input_1,
        "placeholder",
        /*placeholder*/
        ctx[4]
      );
      input_1.disabled = /*disabled*/
      ctx[5];
      attr(input_1, "autocomplete", "off");
      attr(input_1, "role", "presentation");
      attr(input_1, "aria-controls", "options");
      attr(input_1, "class", "bg-surface text-content w-full h-[2.5rem] pr-10 py-2 border rounded-md outline-none placeholder-secondary-content placeholder-opacity-80");
      toggle_class(
        input_1,
        "border-danger",
        /*error*/
        ctx[3]
      );
      toggle_class(
        input_1,
        "text-danger",
        /*error*/
        ctx[3]
      );
      toggle_class(
        input_1,
        "placeholder-red-300",
        /*error*/
        ctx[3]
      );
      toggle_class(
        input_1,
        "focus:border-danger",
        /*error*/
        ctx[3]
      );
      toggle_class(input_1, "focus:border-primary", !/*error*/
      ctx[3]);
      toggle_class(input_1, "border-border", !/*error*/
      ctx[3]);
      toggle_class(
        input_1,
        "bg-default",
        /*disabled*/
        ctx[5]
      );
      toggle_class(
        input_1,
        "pl-10",
        /*$$slots*/
        ctx[16].leading
      );
      toggle_class(input_1, "pl-3", !/*$$slots*/
      ctx[16].leading);
      attr(div0, "class", "p-3 border-b border-border shadow-md");
      attr(div1, "class", "h-[calc(100%-52px)] overflow-y-auto overflow-x-hidden");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      append_hydration(div0, input_1);
      set_input_value(
        input_1,
        /*value*/
        ctx[0]
      );
      insert_hydration(target, t2, anchor);
      insert_hydration(target, div1, anchor);
      if (options_slot) {
        options_slot.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input_1,
            "input",
            /*input_1_input_handler_1*/
            ctx[27]
          ),
          listen(
            input_1,
            "input",
            /*input_handler_1*/
            ctx[21]
          ),
          listen(
            input_1,
            "change",
            /*change_handler_1*/
            ctx[22]
          ),
          listen(
            input_1,
            "focus",
            /*handleOpen*/
            ctx[12]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & /*name*/
      4 && input_1_name_value !== (input_1_name_value = `${/*name*/
      ctx2[2]}-mobile`)) {
        attr(input_1, "name", input_1_name_value);
      }
      if (!current || dirty[0] & /*name*/
      4 && input_1_id_value !== (input_1_id_value = `${/*name*/
      ctx2[2]}-mobile`)) {
        attr(input_1, "id", input_1_id_value);
      }
      if (!current || dirty[0] & /*placeholder*/
      16) {
        attr(
          input_1,
          "placeholder",
          /*placeholder*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      32) {
        input_1.disabled = /*disabled*/
        ctx2[5];
      }
      if (dirty[0] & /*value*/
      1 && input_1.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input_1,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(
          input_1,
          "border-danger",
          /*error*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(
          input_1,
          "text-danger",
          /*error*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(
          input_1,
          "placeholder-red-300",
          /*error*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(
          input_1,
          "focus:border-danger",
          /*error*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(input_1, "focus:border-primary", !/*error*/
        ctx2[3]);
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(input_1, "border-border", !/*error*/
        ctx2[3]);
      }
      if (!current || dirty[0] & /*disabled*/
      32) {
        toggle_class(
          input_1,
          "bg-default",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*$$slots*/
      65536) {
        toggle_class(
          input_1,
          "pl-10",
          /*$$slots*/
          ctx2[16].leading
        );
      }
      if (!current || dirty[0] & /*$$slots*/
      65536) {
        toggle_class(input_1, "pl-3", !/*$$slots*/
        ctx2[16].leading);
      }
      if (options_slot) {
        if (options_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            options_slot,
            options_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              options_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_options_slot_changes$1
            ),
            get_options_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(options_slot, local);
      current = true;
    },
    o(local) {
      transition_out(options_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t2);
        detach(div1);
      }
      if (options_slot)
        options_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$g(ctx) {
  let drawer;
  let current;
  drawer = new Drawer2({
    props: {
      handleClose: (
        /*handleClose*/
        ctx[13]
      ),
      placement: "bottom",
      class: "select-mobile",
      panelClass: "!max-h-[14rem]",
      $$slots: { default: [create_default_slot_1$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(drawer.$$.fragment);
    },
    l(nodes) {
      claim_component(drawer.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(drawer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const drawer_changes = {};
      if (dirty[0] & /*$$scope, name, placeholder, disabled, value, error, $$slots*/
      268501053) {
        drawer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      drawer.$set(drawer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(drawer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(drawer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(drawer, detaching);
    }
  };
}
function create_if_block$_(ctx) {
  let p;
  let t2;
  let p_id_value;
  let p_transition;
  let current;
  return {
    c() {
      p = element("p");
      t2 = text(
        /*error*/
        ctx[3]
      );
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true, id: true });
      var p_nodes = children(p);
      t2 = claim_text(
        p_nodes,
        /*error*/
        ctx[3]
      );
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(p, "class", "mt-2 text-sm text-danger");
      attr(p, "id", p_id_value = /*name*/
      ctx[2] + "-error");
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      append_hydration(p, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & /*error*/
      8)
        set_data(
          t2,
          /*error*/
          ctx2[3]
        );
      if (!current || dirty[0] & /*name*/
      4 && p_id_value !== (p_id_value = /*name*/
      ctx2[2] + "-error")) {
        attr(p, "id", p_id_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!p_transition)
            p_transition = create_bidirectional_transition(p, slide, {}, true);
          p_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!p_transition)
          p_transition = create_bidirectional_transition(p, slide, {}, false);
        p_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (detaching && p_transition)
        p_transition.end();
    }
  };
}
function create_fragment$2F(ctx) {
  let div1;
  let t0;
  let div0;
  let button;
  let input_1;
  let t1;
  let t2;
  let t3;
  let current_block_type_index;
  let if_block2;
  let t4;
  let current_block_type_index_1;
  let if_block3;
  let t5;
  let div1_class_value;
  let clickOutside_action;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const label_slot_template = (
    /*#slots*/
    ctx[20].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[28],
    get_label_slot_context$d
  );
  let if_block0 = (
    /*$$slots*/
    ctx[16].leading && create_if_block_5$i(ctx)
  );
  let if_block1 = (
    /*value*/
    ctx[0] && /*value*/
    ctx[0].length > 0 && create_if_block_4$k(ctx)
  );
  const if_block_creators = [create_if_block_3$p, create_else_block$r];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*error*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const if_block_creators_1 = [create_if_block_1$G, create_if_block_2$q];
  const if_blocks_1 = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*mobile*/
      ctx2[6] && /*visible*/
      ctx2[7]
    )
      return 0;
    if (
      /*visible*/
      ctx2[7]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index_1 = select_block_type_1(ctx))) {
    if_block3 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  }
  let if_block4 = (
    /*error*/
    ctx[3] && create_if_block$_(ctx)
  );
  let div1_levels = [
    {
      class: div1_class_value = /*$$props*/
      ctx[15].class
    },
    exclude(
      /*$$props*/
      ctx[15],
      ["use", "class"]
    )
  ];
  let div_data_1 = {};
  for (let i2 = 0; i2 < div1_levels.length; i2 += 1) {
    div_data_1 = assign$1(div_data_1, div1_levels[i2]);
  }
  return {
    c() {
      div1 = element("div");
      if (label_slot)
        label_slot.c();
      t0 = space();
      div0 = element("div");
      button = element("button");
      input_1 = element("input");
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (label_slot)
        label_slot.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      button = claim_element(div0_nodes, "BUTTON", {
        tabindex: true,
        "aria-label": true,
        type: true,
        class: true
      });
      var button_nodes = children(button);
      input_1 = claim_element(button_nodes, "INPUT", {
        name: true,
        id: true,
        placeholder: true,
        autocomplete: true,
        role: true,
        "aria-controls": true,
        class: true
      });
      t1 = claim_space(button_nodes);
      if (if_block0)
        if_block0.l(button_nodes);
      t2 = claim_space(button_nodes);
      if (if_block1)
        if_block1.l(button_nodes);
      t3 = claim_space(button_nodes);
      if_block2.l(button_nodes);
      button_nodes.forEach(detach);
      t4 = claim_space(div0_nodes);
      if (if_block3)
        if_block3.l(div0_nodes);
      div0_nodes.forEach(detach);
      t5 = claim_space(div1_nodes);
      if (if_block4)
        if_block4.l(div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(
        input_1,
        "name",
        /*name*/
        ctx[2]
      );
      attr(
        input_1,
        "id",
        /*name*/
        ctx[2]
      );
      attr(
        input_1,
        "placeholder",
        /*placeholder*/
        ctx[4]
      );
      input_1.disabled = /*disabled*/
      ctx[5];
      attr(input_1, "autocomplete", "off");
      attr(input_1, "role", "presentation");
      attr(input_1, "aria-controls", "options");
      attr(input_1, "class", "bg-surface w-full h-[2.5rem] pr-10 py-2 border rounded-md outline-none placeholder-secondary-content placeholder-opacity-80");
      toggle_class(
        input_1,
        "border-danger",
        /*error*/
        ctx[3]
      );
      toggle_class(
        input_1,
        "text-danger",
        /*error*/
        ctx[3]
      );
      toggle_class(
        input_1,
        "placeholder-red-300",
        /*error*/
        ctx[3]
      );
      toggle_class(
        input_1,
        "focus:border-danger",
        /*error*/
        ctx[3]
      );
      toggle_class(input_1, "focus:border-primary", !/*error*/
      ctx[3]);
      toggle_class(input_1, "border-border", !/*error*/
      ctx[3]);
      toggle_class(
        input_1,
        "bg-default",
        /*disabled*/
        ctx[5]
      );
      toggle_class(
        input_1,
        "pl-10",
        /*$$slots*/
        ctx[16].leading
      );
      toggle_class(input_1, "pl-3", !/*$$slots*/
      ctx[16].leading);
      attr(button, "tabindex", "0");
      attr(button, "aria-label", "Autocomplete Toggle");
      attr(button, "type", "button");
      attr(button, "class", "group relative cursor-pointer h-[2.5rem] text-left border-none focus:outline-none sm:text-sm block w-full outline-none rounded-md bg-surface");
      toggle_class(
        button,
        "text-danger",
        /*error*/
        ctx[3]
      );
      attr(div0, "class", "mt-1 relative rounded-md h-[2.5rem]");
      toggle_class(
        div0,
        "opacity-75",
        /*disabled*/
        ctx[5]
      );
      set_attributes(div1, div_data_1);
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      if (label_slot) {
        label_slot.m(div1, null);
      }
      append_hydration(div1, t0);
      append_hydration(div1, div0);
      append_hydration(div0, button);
      append_hydration(button, input_1);
      ctx[25](input_1);
      set_input_value(
        input_1,
        /*value*/
        ctx[0]
      );
      append_hydration(button, t1);
      if (if_block0)
        if_block0.m(button, null);
      append_hydration(button, t2);
      if (if_block1)
        if_block1.m(button, null);
      append_hydration(button, t3);
      if_blocks[current_block_type_index].m(button, null);
      append_hydration(div0, t4);
      if (~current_block_type_index_1) {
        if_blocks_1[current_block_type_index_1].m(div0, null);
      }
      append_hydration(div1, t5);
      if (if_block4)
        if_block4.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input_1,
            "input",
            /*input_1_input_handler*/
            ctx[26]
          ),
          listen(
            input_1,
            "input",
            /*input_handler*/
            ctx[23]
          ),
          listen(
            input_1,
            "change",
            /*change_handler*/
            ctx[24]
          ),
          listen(
            input_1,
            "focus",
            /*handleOpen*/
            ctx[12]
          ),
          listen(button, "click", stop_propagation(prevent_default(
            /*handleOpen*/
            ctx[12]
          ))),
          action_destroyer(clickOutside_action = clickOutside.call(
            null,
            div1,
            /*mobile*/
            ctx[6] ? clickOutside_function$1 : (
              /*handleClose*/
              ctx[13]
            )
          )),
          action_destroyer(useActions_action = useActions.call(
            null,
            div1,
            /*use*/
            ctx[1]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[9].call(null, div1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty[0] & /*$$scope*/
        268435456)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[28],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[28]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[28],
              dirty,
              get_label_slot_changes$d
            ),
            get_label_slot_context$d
          );
        }
      }
      if (!current || dirty[0] & /*name*/
      4) {
        attr(
          input_1,
          "name",
          /*name*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*name*/
      4) {
        attr(
          input_1,
          "id",
          /*name*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*placeholder*/
      16) {
        attr(
          input_1,
          "placeholder",
          /*placeholder*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      32) {
        input_1.disabled = /*disabled*/
        ctx2[5];
      }
      if (dirty[0] & /*value*/
      1 && input_1.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input_1,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(
          input_1,
          "border-danger",
          /*error*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(
          input_1,
          "text-danger",
          /*error*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(
          input_1,
          "placeholder-red-300",
          /*error*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(
          input_1,
          "focus:border-danger",
          /*error*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(input_1, "focus:border-primary", !/*error*/
        ctx2[3]);
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(input_1, "border-border", !/*error*/
        ctx2[3]);
      }
      if (!current || dirty[0] & /*disabled*/
      32) {
        toggle_class(
          input_1,
          "bg-default",
          /*disabled*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*$$slots*/
      65536) {
        toggle_class(
          input_1,
          "pl-10",
          /*$$slots*/
          ctx2[16].leading
        );
      }
      if (!current || dirty[0] & /*$$slots*/
      65536) {
        toggle_class(input_1, "pl-3", !/*$$slots*/
        ctx2[16].leading);
      }
      if (
        /*$$slots*/
        ctx2[16].leading
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          65536) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5$i(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(button, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*value*/
        ctx2[0] && /*value*/
        ctx2[0].length > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*value*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4$k(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(button, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(button, null);
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(
          button,
          "text-danger",
          /*error*/
          ctx2[3]
        );
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_1(ctx2);
      if (current_block_type_index_1 === previous_block_index_1) {
        if (~current_block_type_index_1) {
          if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
        }
      } else {
        if (if_block3) {
          group_outros();
          transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
            if_blocks_1[previous_block_index_1] = null;
          });
          check_outros();
        }
        if (~current_block_type_index_1) {
          if_block3 = if_blocks_1[current_block_type_index_1];
          if (!if_block3) {
            if_block3 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
            if_block3.c();
          } else {
            if_block3.p(ctx2, dirty);
          }
          transition_in(if_block3, 1);
          if_block3.m(div0, null);
        } else {
          if_block3 = null;
        }
      }
      if (!current || dirty[0] & /*disabled*/
      32) {
        toggle_class(
          div0,
          "opacity-75",
          /*disabled*/
          ctx2[5]
        );
      }
      if (
        /*error*/
        ctx2[3]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & /*error*/
          8) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block$_(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div1, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        (!current || dirty[0] & /*$$props*/
        32768 && div1_class_value !== (div1_class_value = /*$$props*/
        ctx2[15].class)) && { class: div1_class_value },
        dirty[0] & /*$$props*/
        32768 && exclude(
          /*$$props*/
          ctx2[15],
          ["use", "class"]
        )
      ]));
      if (clickOutside_action && is_function(clickOutside_action.update) && dirty[0] & /*mobile*/
      64)
        clickOutside_action.update.call(
          null,
          /*mobile*/
          ctx2[6] ? clickOutside_function$1 : (
            /*handleClose*/
            ctx2[13]
          )
        );
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[1]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (label_slot)
        label_slot.d(detaching);
      ctx[25](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if_blocks[current_block_type_index].d();
      if (~current_block_type_index_1) {
        if_blocks_1[current_block_type_index_1].d();
      }
      if (if_block4)
        if_block4.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
const clickOutside_function$1 = () => {
  return;
};
function instance$2D($$self, $$props, $$invalidate) {
  let $isMobile;
  let $selectedOption;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { name } = $$props;
  let { error: error2 = void 0 } = $$props;
  let { placeholder = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { allowNonListValue = false } = $$props;
  let { options = [] } = $$props;
  let { disabled = false } = $$props;
  let { mobile = false } = $$props;
  let visible = false;
  let input;
  let selectedOption = writable(value);
  component_subscribe($$self, selectedOption, (value2) => $$invalidate(29, $selectedOption = value2));
  let currentError = writable(error2);
  let isMobile = writable(mobile);
  component_subscribe($$self, isMobile, (value2) => $$invalidate(19, $isMobile = value2));
  function handleOpen() {
    if (!disabled) {
      $$invalidate(7, visible = true);
    }
  }
  function handleClose() {
    checkValue();
  }
  function checkValue() {
    if (visible) {
      if (value === void 0) {
        $$invalidate(7, visible = false);
      } else if (options.includes(value)) {
        $$invalidate(7, visible = false);
      } else if (allowNonListValue) {
        $$invalidate(7, visible = false);
      } else {
        const inputMobile = document.getElementById(`${name}-mobile`);
        if (inputMobile) {
          inputMobile.value = "";
        }
        $$invalidate(8, input.value = "", input);
        $$invalidate(0, value = void 0);
        set_store_value(selectedOption, $selectedOption = void 0, $selectedOption);
        $$invalidate(7, visible = false);
      }
    }
  }
  function handleSelect(option) {
    $$invalidate(0, value = option);
    $$invalidate(8, input.value = option, input);
    set_store_value(selectedOption, $selectedOption = option, $selectedOption);
    $$invalidate(7, visible = false);
  }
  function handleClear() {
    $$invalidate(8, input.value = "", input);
    $$invalidate(0, value = void 0);
    set_store_value(selectedOption, $selectedOption = void 0, $selectedOption);
  }
  setContext("autocomplete-handleSelect", handleSelect);
  setContext("autocomplete-name", name);
  setContext("autocomplete-error", currentError);
  setContext("autocomplete-value", selectedOption);
  setContext("autocomplete-handleClose", handleClose);
  setContext("autocomplete-mobile", isMobile);
  setContext("autocomplete-actual-value", value);
  function input_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function change_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(8, input);
    });
  }
  function input_1_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input_1_input_handler_1() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(15, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("name" in $$new_props)
      $$invalidate(2, name = $$new_props.name);
    if ("error" in $$new_props)
      $$invalidate(3, error2 = $$new_props.error);
    if ("placeholder" in $$new_props)
      $$invalidate(4, placeholder = $$new_props.placeholder);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("allowNonListValue" in $$new_props)
      $$invalidate(17, allowNonListValue = $$new_props.allowNonListValue);
    if ("options" in $$new_props)
      $$invalidate(18, options = $$new_props.options);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("mobile" in $$new_props)
      $$invalidate(6, mobile = $$new_props.mobile);
    if ("$$scope" in $$new_props)
      $$invalidate(28, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*error*/
    8) {
      currentError.set(error2);
    }
    if ($$self.$$.dirty[0] & /*mobile*/
    64) {
      isMobile.set(mobile);
    }
    if ($$self.$$.dirty[0] & /*$isMobile, visible, name*/
    524420) {
      if ($isMobile && visible) {
        setTimeout(
          () => {
            const inputMobile = document.getElementById(`${name}-mobile`);
            if (inputMobile) {
              inputMobile.focus();
            }
          },
          1
        );
      }
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    use,
    name,
    error2,
    placeholder,
    disabled,
    mobile,
    visible,
    input,
    forwardEvents,
    selectedOption,
    isMobile,
    handleOpen,
    handleClose,
    handleClear,
    $$props,
    $$slots,
    allowNonListValue,
    options,
    $isMobile,
    slots,
    input_handler_1,
    change_handler_1,
    input_handler,
    change_handler,
    input_1_binding,
    input_1_input_handler,
    input_1_input_handler_1,
    $$scope
  ];
}
let Autocomplete$1 = class Autocomplete extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$2D,
      create_fragment$2F,
      safe_not_equal,
      {
        use: 1,
        name: 2,
        error: 3,
        placeholder: 4,
        value: 0,
        allowNonListValue: 17,
        options: 18,
        disabled: 5,
        mobile: 6
      },
      null,
      [-1, -1]
    );
  }
};
function create_else_block$q(ctx) {
  let ul;
  let useActions_action;
  let ul_intro;
  let ul_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let ul_levels = [
    { class: (
      /*finalClass*/
      ctx[3]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    ),
    { role: "listbox" }
  ];
  let ul_data = {};
  for (let i2 = 0; i2 < ul_levels.length; i2 += 1) {
    ul_data = assign$1(ul_data, ul_levels[i2]);
  }
  return {
    c() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      ul = claim_element(nodes, "UL", { class: true, role: true });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(ul, ul_data);
    },
    m(target, anchor) {
      insert_hydration(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[12](ul);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            ul,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[4].call(null, ul)
          ),
          action_destroyer(floatingUI.call(null, ul, { placement: "bottom-start", offset: 8 }))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        (!current || dirty & /*finalClass*/
        8) && { class: (
          /*finalClass*/
          ctx2[3]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        ),
        { role: "listbox" }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (ul_outro)
            ul_outro.end(1);
          ul_intro = create_in_transition(ul, scale, { start: 0.9, duration: 150 });
          ul_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      if (ul_intro)
        ul_intro.invalidate();
      if (local) {
        ul_outro = create_out_transition(ul, scale, { start: 0.95, duration: 150 });
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[12](null);
      if (detaching && ul_outro)
        ul_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$Z(ctx) {
  let ul;
  let t2;
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let ul_levels = [
    { class: (
      /*finalClass*/
      ctx[3]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    ),
    { role: "listbox" }
  ];
  let ul_data = {};
  for (let i2 = 0; i2 < ul_levels.length; i2 += 1) {
    ul_data = assign$1(ul_data, ul_levels[i2]);
  }
  return {
    c() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      t2 = space();
      div2 = element("div");
      this.h();
    },
    l(nodes) {
      ul = claim_element(nodes, "UL", { class: true, role: true });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      t2 = claim_space(ul_nodes);
      div2 = claim_element(ul_nodes, "DIV", { class: true });
      children(div2).forEach(detach);
      ul_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "w-full h-2");
      set_attributes(ul, ul_data);
    },
    m(target, anchor) {
      insert_hydration(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      append_hydration(ul, t2);
      append_hydration(ul, div2);
      ctx[11](ul);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            ul,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[4].call(null, ul)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        (!current || dirty & /*finalClass*/
        8) && { class: (
          /*finalClass*/
          ctx2[3]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        ),
        { role: "listbox" }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[11](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$2E(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$Z, create_else_block$q];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$mobile*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          window,
          "keydown",
          /*handleKeydown*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$2C($$self, $$props, $$invalidate) {
  let finalClass;
  let $mobile;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let list;
  let items = [];
  let focusIndex = 0;
  let arrowPressedOnce = false;
  const handleClose = getContext("autocomplete-handleClose");
  const mobile = getContext("autocomplete-mobile");
  component_subscribe($$self, mobile, (value) => $$invalidate(1, $mobile = value));
  function handleKeydown(e2) {
    if (e2.key === "ArrowUp") {
      if (!arrowPressedOnce) {
        items[focusIndex].focus();
      } else {
        focusIndex = focusIndex > 0 ? focusIndex - 1 : items.length - 1;
        if (items[focusIndex])
          items[focusIndex].focus();
      }
      arrowPressedOnce = true;
      e2.preventDefault();
      e2.stopPropagation();
    } else if (e2.key === "ArrowDown") {
      if (!arrowPressedOnce) {
        items[focusIndex].focus();
      } else {
        focusIndex = focusIndex < items.length - 1 ? focusIndex + 1 : 0;
        if (items[focusIndex])
          items[focusIndex].focus();
      }
      arrowPressedOnce = true;
      e2.preventDefault();
      e2.stopPropagation();
    } else if (e2.key === "Enter") {
      e2.preventDefault();
      e2.stopPropagation();
    } else if (e2.key === "Escape") {
      e2.preventDefault();
      e2.stopPropagation();
      handleClose();
    }
  }
  let defaultClass2 = "w-full bg-surface";
  onMount(() => {
    items = list.querySelectorAll("li");
  });
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      list = $$value;
      $$invalidate(2, list);
    });
  }
  function ul_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      list = $$value;
      $$invalidate(2, list);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$mobile, defaultClass*/
    258) {
      if ($mobile) {
        $$invalidate(8, defaultClass2 += " h-full px-3 space-y-1");
      } else {
        $$invalidate(8, defaultClass2 += " p-1 shadow-xl border border-border rounded-md origin-top-right absolute z-10 left-0 right-0 transition transform duration-150");
      }
    }
    $$invalidate(3, finalClass = twMerge(defaultClass2, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    $mobile,
    list,
    finalClass,
    forwardEvents,
    mobile,
    handleKeydown,
    $$props,
    defaultClass2,
    $$scope,
    slots,
    ul_binding,
    ul_binding_1
  ];
}
let Options$1 = class Options extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2C, create_fragment$2E, safe_not_equal, { use: 0 });
  }
};
function create_if_block$Y(ctx) {
  let span;
  let icon;
  let span_transition;
  let current;
  icon = new Icon$7({ props: { data: check } });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "text-primary absolute inset-y-0 right-0 flex items-center pr-2.5");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!span_transition)
            span_transition = create_bidirectional_transition(span, scale, {}, true);
          span_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      if (local) {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, scale, {}, false);
        span_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
      if (detaching && span_transition)
        span_transition.end();
    }
  };
}
function create_fragment$2D(ctx) {
  let li;
  let button;
  let div2;
  let span;
  let t0;
  let t1;
  let t2;
  let hoverbackground;
  let li_aria_selected_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$value*/
    ctx[3] === /*option*/
    ctx[1] && create_if_block$Y()
  );
  hoverbackground = new HoverBackground({});
  let li_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    { tabindex: "-1" },
    exclude(
      /*$$props*/
      ctx[8],
      ["use", "class"]
    ),
    { role: "option" },
    {
      "aria-selected": li_aria_selected_value = /*$value*/
      ctx[3] === /*option*/
      ctx[1]
    }
  ];
  let li_data = {};
  for (let i2 = 0; i2 < li_levels.length; i2 += 1) {
    li_data = assign$1(li_data, li_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      button = element("button");
      div2 = element("div");
      span = element("span");
      t0 = text(
        /*option*/
        ctx[1]
      );
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      create_component(hoverbackground.$$.fragment);
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", {
        class: true,
        tabindex: true,
        role: true,
        "aria-selected": true
      });
      var li_nodes = children(li);
      button = claim_element(li_nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        class: true
      });
      var button_nodes = children(button);
      div2 = claim_element(button_nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(
        span_nodes,
        /*option*/
        ctx[1]
      );
      span_nodes.forEach(detach);
      t1 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      t2 = claim_space(div_nodes);
      claim_component(hoverbackground.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      button_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "font-normal block truncate");
      toggle_class(
        span,
        "font-semibold",
        /*$value*/
        ctx[3] === /*option*/
        ctx[1]
      );
      attr(div2, "class", "relative py-1.5 pl-2.5 pr-7 w-full rounded-md overflow-hidden");
      attr(button, "type", "button");
      attr(button, "aria-label", "autocomplete option");
      attr(button, "class", "w-full text-left");
      set_attributes(li, li_data);
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, button);
      append_hydration(button, div2);
      append_hydration(div2, span);
      append_hydration(span, t0);
      append_hydration(div2, t1);
      if (if_block)
        if_block.m(div2, null);
      append_hydration(div2, t2);
      mount_component(hoverbackground, div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[9]
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            li,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[4].call(null, li)
          ),
          listen(
            li,
            "keydown",
            /*handleKeydown*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*option*/
      2)
        set_data(
          t0,
          /*option*/
          ctx2[1]
        );
      if (!current || dirty & /*$value, option*/
      10) {
        toggle_class(
          span,
          "font-semibold",
          /*$value*/
          ctx2[3] === /*option*/
          ctx2[1]
        );
      }
      if (
        /*$value*/
        ctx2[3] === /*option*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$value, option*/
          10) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$Y();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        { tabindex: "-1" },
        dirty & /*$$props*/
        256 && exclude(
          /*$$props*/
          ctx2[8],
          ["use", "class"]
        ),
        { role: "option" },
        (!current || dirty & /*$value, option*/
        10 && li_aria_selected_value !== (li_aria_selected_value = /*$value*/
        ctx2[3] === /*option*/
        ctx2[1])) && { "aria-selected": li_aria_selected_value }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(hoverbackground.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(hoverbackground.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (if_block)
        if_block.d();
      destroy_component(hoverbackground);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1W = "group text-content cursor-pointer select-none p-0.5 w-full !outline-none !border-none !ring-0";
function instance$2B($$self, $$props, $$invalidate) {
  let finalClass;
  let $value;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { option } = $$props;
  const handleSelect = getContext("autocomplete-handleSelect");
  const value = getContext("autocomplete-value");
  component_subscribe($$self, value, (value2) => $$invalidate(3, $value = value2));
  function handleKeydown(e2) {
    if (e2.key === "Enter") {
      e2.preventDefault();
      e2.stopPropagation();
      handleSelect(option);
    }
  }
  const click_handler = () => handleSelect(option);
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("option" in $$new_props)
      $$invalidate(1, option = $$new_props.option);
  };
  $$self.$$.update = () => {
    $$invalidate(2, finalClass = twMerge(defaultClass$1W, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    option,
    finalClass,
    $value,
    forwardEvents,
    handleSelect,
    value,
    handleKeydown,
    $$props,
    click_handler
  ];
}
let Option$1 = class Option extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2B, create_fragment$2D, safe_not_equal, { use: 0, option: 1 });
  }
};
function create_else_block$p(ctx) {
  let t2;
  return {
    c() {
      t2 = text("No Options Available");
    },
    l(nodes) {
      t2 = claim_text(nodes, "No Options Available");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block$X(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    l(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$2C(ctx) {
  let li;
  let span;
  let current_block_type_index;
  let if_block;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$X, create_else_block$p];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[4].default
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let li_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    ),
    { role: "option" },
    { "aria-selected": "false" }
  ];
  let li_data = {};
  for (let i2 = 0; i2 < li_levels.length; i2 += 1) {
    li_data = assign$1(li_data, li_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      span = element("span");
      if_block.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", {
        class: true,
        role: true,
        "aria-selected": true
      });
      var li_nodes = children(li);
      span = claim_element(li_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if_block.l(span_nodes);
      span_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "font-normal block truncate");
      set_attributes(li, li_data);
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, span);
      if_blocks[current_block_type_index].m(span, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            li,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, li)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(span, null);
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        ),
        { role: "option" },
        { "aria-selected": "false" }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if_blocks[current_block_type_index].d();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1V = "group text-content select-none p-0.5 w-full relative py-1.5 pl-2.5 pr-7 w-full rounded-md overflow-hidden";
function instance$2A($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1V, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$slots, $$scope, slots];
}
class EmptyOption extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2A, create_fragment$2C, safe_not_equal, { use: 0 });
  }
}
function create_fragment$2B(ctx) {
  let label;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let label_levels = [
    { for: (
      /*name*/
      ctx[3]
    ) },
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[5],
      ["use", "class"]
    )
  ];
  let label_data = {};
  for (let i2 = 0; i2 < label_levels.length; i2 += 1) {
    label_data = assign$1(label_data, label_levels[i2]);
  }
  return {
    c() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      label = claim_element(nodes, "LABEL", { for: true, class: true });
      var label_nodes = children(label);
      if (default_slot)
        default_slot.l(label_nodes);
      label_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(label, label_data);
    },
    m(target, anchor) {
      insert_hydration(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            label,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, label)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        { for: (
          /*name*/
          ctx2[3]
        ) },
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        32 && exclude(
          /*$$props*/
          ctx2[5],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1U = "block text-sm font-medium text-secondary-content";
const errorClass$8 = "text-danger";
function instance$2z($$self, $$props, $$invalidate) {
  let finalClass;
  let $error;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const name = getContext("autocomplete-name");
  const error2 = getContext("autocomplete-error");
  component_subscribe($$self, error2, (value) => $$invalidate(6, $error = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1U, $error && $error.length > 0 ? errorClass$8 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, name, error2, $$props, $error, $$scope, slots];
}
let Label$b = class Label extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2z, create_fragment$2B, safe_not_equal, { use: 0 });
  }
};
const Autocomplete2 = Autocomplete$1;
Autocomplete2.Options = Options$1;
Autocomplete2.Options.Option = Option$1;
Autocomplete2.Options.EmptyOption = EmptyOption;
Autocomplete2.Label = Label$b;
Autocomplete2.Leading = Icon$7;
const Placeholder_svelte_svelte_type_style_lang$6 = "";
const get_icon_slot_changes$i = (dirty) => ({});
const get_icon_slot_context$i = (ctx) => ({});
function create_if_block_1$F(ctx) {
  let span;
  let icon;
  let span_class_value;
  let current;
  icon = new Icon$7({
    props: { data: account, size: (
      /*iconSize*/
      ctx[2]
    ) }
  });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", span_class_value = null_to_empty(
        /*iconContainerClass*/
        ctx[3]
      ) + " svelte-13m79ia");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & /*iconSize*/
      4)
        icon_changes.size = /*iconSize*/
        ctx2[2];
      icon.$set(icon_changes);
      if (!current || dirty & /*iconContainerClass*/
      8 && span_class_value !== (span_class_value = null_to_empty(
        /*iconContainerClass*/
        ctx2[3]
      ) + " svelte-13m79ia")) {
        attr(span, "class", span_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block$W(ctx) {
  let t2;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[10].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_icon_slot_context$i
  );
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
    },
    l(nodes) {
      if (icon_slot)
        icon_slot.l(nodes);
      t2 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      insert_hydration(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_icon_slot_changes$i
            ),
            get_icon_slot_context$i
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (icon_slot)
        icon_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$2A(ctx) {
  let div2;
  let current_block_type_index;
  let if_block;
  let useActions_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$W, create_if_block_1$F];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[7].icon || /*$$slots*/
      ctx2[7].default
    )
      return 0;
    if (
      /*placeholder*/
      ctx2[5]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[6],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
      toggle_class(div2, "svelte-13m79ia", true);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[4].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div2, null);
        } else {
          if_block = null;
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        64 && exclude(
          /*$$props*/
          ctx2[6],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(div2, "svelte-13m79ia", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, fade, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, fade, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1T = "absolute text-contentt inset-0 h-full w-full flex items-center justify-center overflow-hidden bg-default";
const circleClass$c = "rounded-full";
const roundedClass$c = "rounded-md";
const defaultIconContainerClass$4 = "absolute text-contentt h-full w-full";
const xsContainerClass$4 = "bottom-[-0.25rem]";
const smContainerClass$4 = "bottom-[-0.35rem]";
const mdContainerClass$4 = "bottom-[-0.5rem]";
const lgContainerClass$4 = "text-6xl bottom-[-0.6rem]";
const xlContainerClass$4 = "bottom-[-0.75rem]";
const xsIconSize$4 = "24px";
const smIconSize$4 = "32px";
const mdIconSize$4 = "40px";
const lgIconSize$4 = "48px";
const xlIconSize$4 = "64px";
function instance$2y($$self, $$props, $$invalidate) {
  let iconContainerClass2;
  let iconSize2;
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { loading = false } = $$props;
  const shape = getContext("avatar-shape");
  const size = getContext("avatar-size");
  const placeholder = getContext("avatar-placeholder");
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("loading" in $$new_props)
      $$invalidate(8, loading = $$new_props.loading);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1T, loading ? "loading" : false, shape === "circle" ? circleClass$c : false, shape === "rounded" ? roundedClass$c : false, $$props.class));
  };
  $$invalidate(3, iconContainerClass2 = twMerge(defaultIconContainerClass$4, size === "xs" ? xsContainerClass$4 : false, size === "sm" ? smContainerClass$4 : false, size === "md" ? mdContainerClass$4 : false, size === "lg" ? lgContainerClass$4 : false, size === "xl" ? xlContainerClass$4 : false));
  $$invalidate(2, iconSize2 = twMerge(size === "xs" ? xsIconSize$4 : false, size === "sm" ? smIconSize$4 : false, size === "md" ? mdIconSize$4 : false, size === "lg" ? lgIconSize$4 : false, size === "xl" ? xlIconSize$4 : false));
  $$props = exclude_internal_props($$props);
  return [
    use,
    finalClass,
    iconSize2,
    iconContainerClass2,
    forwardEvents,
    placeholder,
    $$props,
    $$slots,
    loading,
    $$scope,
    slots
  ];
}
let Placeholder$6 = class Placeholder extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2y, create_fragment$2A, safe_not_equal, { use: 0, loading: 8 });
  }
};
const get_indicator_slot_changes$7 = (dirty) => ({});
const get_indicator_slot_context$7 = (ctx) => ({});
const get_placeholder_slot_changes$6 = (dirty) => ({});
const get_placeholder_slot_context$6 = (ctx) => ({});
function create_if_block_5$h(ctx) {
  let span1;
  let span0;
  let t2;
  let useActions_action;
  let mounted;
  let dispose;
  let span1_levels = [
    { class: (
      /*finalClass*/
      ctx[9]
    ) },
    exclude(
      /*$$props*/
      ctx[11],
      ["use", "class"]
    )
  ];
  let span_data_1 = {};
  for (let i2 = 0; i2 < span1_levels.length; i2 += 1) {
    span_data_1 = assign$1(span_data_1, span1_levels[i2]);
  }
  return {
    c() {
      span1 = element("span");
      span0 = element("span");
      t2 = text(
        /*initials*/
        ctx[4]
      );
      this.h();
    },
    l(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t2 = claim_text(
        span0_nodes,
        /*initials*/
        ctx[4]
      );
      span0_nodes.forEach(detach);
      span1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "class", "font-bold leading-none text-current");
      toggle_class(
        span0,
        "text-xs",
        /*size*/
        ctx[3] === "xs"
      );
      toggle_class(
        span0,
        "text-sm",
        /*size*/
        ctx[3] === "sm"
      );
      toggle_class(
        span0,
        "text-xl",
        /*size*/
        ctx[3] === "lg"
      );
      toggle_class(
        span0,
        "text-2xl",
        /*size*/
        ctx[3] === "xl"
      );
      set_attributes(span1, span_data_1);
    },
    m(target, anchor) {
      insert_hydration(target, span1, anchor);
      append_hydration(span1, span0);
      append_hydration(span0, t2);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span1,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[10].call(null, span1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*initials*/
      16)
        set_data(
          t2,
          /*initials*/
          ctx2[4]
        );
      if (dirty & /*size*/
      8) {
        toggle_class(
          span0,
          "text-xs",
          /*size*/
          ctx2[3] === "xs"
        );
      }
      if (dirty & /*size*/
      8) {
        toggle_class(
          span0,
          "text-sm",
          /*size*/
          ctx2[3] === "sm"
        );
      }
      if (dirty & /*size*/
      8) {
        toggle_class(
          span0,
          "text-xl",
          /*size*/
          ctx2[3] === "lg"
        );
      }
      if (dirty & /*size*/
      8) {
        toggle_class(
          span0,
          "text-2xl",
          /*size*/
          ctx2[3] === "xl"
        );
      }
      set_attributes(span1, span_data_1 = get_spread_update(span1_levels, [
        dirty & /*finalClass*/
        512 && { class: (
          /*finalClass*/
          ctx2[9]
        ) },
        dirty & /*$$props*/
        2048 && exclude(
          /*$$props*/
          ctx2[11],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$V(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$E, create_if_block_2$p, create_if_block_4$j];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*loaded*/
      ctx2[5]
    )
      return 0;
    if (
      /*failed*/
      ctx2[6]
    )
      return 1;
    if (
      /*loading*/
      ctx2[7]
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const indicator_slot_template = (
    /*#slots*/
    ctx[16].indicator
  );
  const indicator_slot = create_slot(
    indicator_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_indicator_slot_context$7
  );
  let span_levels = [
    { class: (
      /*finalContainerClass*/
      ctx[8]
    ) },
    exclude(
      /*$$props*/
      ctx[11],
      ["use", "class", "src"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (if_block)
        if_block.c();
      t2 = space();
      if (indicator_slot)
        indicator_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      t2 = claim_space(span_nodes);
      if (indicator_slot)
        indicator_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(span, null);
      }
      append_hydration(span, t2);
      if (indicator_slot) {
        indicator_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[10].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(span, t2);
        } else {
          if_block = null;
        }
      }
      if (indicator_slot) {
        if (indicator_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            indicator_slot,
            indicator_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              indicator_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_indicator_slot_changes$7
            ),
            get_indicator_slot_context$7
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalContainerClass*/
        256) && { class: (
          /*finalContainerClass*/
          ctx2[8]
        ) },
        dirty & /*$$props*/
        2048 && exclude(
          /*$$props*/
          ctx2[11],
          ["use", "class", "src"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(indicator_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(indicator_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (indicator_slot)
        indicator_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4$j(ctx) {
  let placeholder_1;
  let current;
  placeholder_1 = new Placeholder$6({ props: { loading: true } });
  return {
    c() {
      create_component(placeholder_1.$$.fragment);
    },
    l(nodes) {
      claim_component(placeholder_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(placeholder_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(placeholder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(placeholder_1, detaching);
    }
  };
}
function create_if_block_2$p(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3$o, create_else_block$o];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[12].placeholder
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_1$E(ctx) {
  let img;
  let img_style_value;
  let img_src_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", {
        class: true,
        style: true,
        src: true,
        alt: true
      });
      this.h();
    },
    h() {
      attr(
        img,
        "class",
        /*finalClass*/
        ctx[9]
      );
      attr(img, "style", img_style_value = /*$$props*/
      ctx[11].style);
      if (!src_url_equal(img.src, img_src_value = /*src*/
      ctx[1] || ""))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*alt*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*finalClass*/
      512) {
        attr(
          img,
          "class",
          /*finalClass*/
          ctx2[9]
        );
      }
      if (dirty & /*$$props*/
      2048 && img_style_value !== (img_style_value = /*$$props*/
      ctx2[11].style)) {
        attr(img, "style", img_style_value);
      }
      if (dirty & /*src*/
      2 && !src_url_equal(img.src, img_src_value = /*src*/
      ctx2[1] || "")) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*alt*/
      4) {
        attr(
          img,
          "alt",
          /*alt*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_else_block$o(ctx) {
  let placeholder_1;
  let current;
  placeholder_1 = new Placeholder$6({});
  return {
    c() {
      create_component(placeholder_1.$$.fragment);
    },
    l(nodes) {
      claim_component(placeholder_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(placeholder_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(placeholder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(placeholder_1, detaching);
    }
  };
}
function create_if_block_3$o(ctx) {
  let current;
  const placeholder_slot_template = (
    /*#slots*/
    ctx[16].placeholder
  );
  const placeholder_slot = create_slot(
    placeholder_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_placeholder_slot_context$6
  );
  return {
    c() {
      if (placeholder_slot)
        placeholder_slot.c();
    },
    l(nodes) {
      if (placeholder_slot)
        placeholder_slot.l(nodes);
    },
    m(target, anchor) {
      if (placeholder_slot) {
        placeholder_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (placeholder_slot) {
        if (placeholder_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            placeholder_slot,
            placeholder_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              placeholder_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_placeholder_slot_changes$6
            ),
            get_placeholder_slot_context$6
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(placeholder_slot, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_slot, local);
      current = false;
    },
    d(detaching) {
      if (placeholder_slot)
        placeholder_slot.d(detaching);
    }
  };
}
function create_fragment$2z(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$V, create_if_block_5$h];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*src*/
      ctx2[1]
    )
      return 0;
    if (
      /*initials*/
      ctx2[4]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
const srcClass$5 = "inline-block absolute";
const srcContainerClass$5 = "inline-block relative align-middle";
const initialClass$4 = "inline-flex items-center justify-center align-middle bg-default text-default-content";
const xsClass$7 = "h-6 w-6";
const smClass$7 = "h-8 w-8";
const mdClass$7 = "h-10 w-10";
const lgClass$7 = "h-12 w-12";
const xlClass$7 = "h-16 w-16";
const circleClass$b = "rounded-full";
const roundedClass$b = "rounded-md";
function instance$2x($$self, $$props, $$invalidate) {
  let finalClass;
  let finalContainerClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { src = void 0 } = $$props;
  let { alt = "avatar" } = $$props;
  let { shape = "circle" } = $$props;
  let { size = "md" } = $$props;
  let { initials = void 0 } = $$props;
  let { placeholder = true } = $$props;
  let loaded = false;
  let failed = false;
  let loading = true;
  setContext("avatar-shape", shape);
  setContext("avatar-size", size);
  setContext("avatar-placeholder", placeholder);
  onMount(() => {
    if (src) {
      const image = new Image();
      image.src = src;
      $$invalidate(7, loading = true);
      image.onload = () => {
        $$invalidate(7, loading = false);
        $$invalidate(5, loaded = true);
      };
      image.onerror = () => {
        $$invalidate(7, loading = false);
        $$invalidate(6, failed = true);
      };
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(11, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("src" in $$new_props)
      $$invalidate(1, src = $$new_props.src);
    if ("alt" in $$new_props)
      $$invalidate(2, alt = $$new_props.alt);
    if ("shape" in $$new_props)
      $$invalidate(13, shape = $$new_props.shape);
    if ("size" in $$new_props)
      $$invalidate(3, size = $$new_props.size);
    if ("initials" in $$new_props)
      $$invalidate(4, initials = $$new_props.initials);
    if ("placeholder" in $$new_props)
      $$invalidate(14, placeholder = $$new_props.placeholder);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(9, finalClass = twMerge(src && !initials ? srcClass$5 : false, initials && !src ? initialClass$4 : false, size === "xs" ? xsClass$7 : false, size === "sm" ? smClass$7 : false, size === "md" ? mdClass$7 : false, size === "lg" ? lgClass$7 : false, size === "xl" ? xlClass$7 : false, shape === "circle" ? circleClass$b : false, shape === "rounded" ? roundedClass$b : false, $$props.class));
    $$invalidate(8, finalContainerClass = twMerge(src && !initials ? srcContainerClass$5 : false, size === "xs" ? xsClass$7 : false, size === "sm" ? smClass$7 : false, size === "md" ? mdClass$7 : false, size === "lg" ? lgClass$7 : false, size === "xl" ? xlClass$7 : false, shape === "circle" ? circleClass$b : false, shape === "rounded" ? roundedClass$b : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    src,
    alt,
    size,
    initials,
    loaded,
    failed,
    loading,
    finalContainerClass,
    finalClass,
    forwardEvents,
    $$props,
    $$slots,
    shape,
    placeholder,
    $$scope,
    slots
  ];
}
let Avatar$7 = class Avatar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2x, create_fragment$2z, safe_not_equal, {
      use: 0,
      src: 1,
      alt: 2,
      shape: 13,
      size: 3,
      initials: 4,
      placeholder: 14
    });
  }
};
function create_fragment$2y(ctx) {
  let span;
  let useActions_action;
  let mounted;
  let dispose;
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      children(span).forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*finalClass*/
        2 && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1S = "absolute block rounded-full ring-2 ring-surface bg-primary";
const topRightClass$1 = "top-0 right-0";
const topLeftClass$1 = "top-0 left-0";
const bottomLeftClass$1 = "bottom-0 left-0";
const bottomRightClass$1 = "bottom-0 right-0";
const notCircleClass$1 = "transform";
const notCircleTopRightClass$1 = "-translate-y-1/2 translate-x-1/2";
const notCircleTopLeftClass$1 = "-translate-y-1/2 -translate-x-1/2";
const notCircleBottomRightClass$1 = "translate-y-1/2 translate-x-1/2";
const notCircleBottomLeftClass$1 = "translate-y-1/2 -translate-x-1/2";
const xsClass$6 = "h-1.5 w-1.5";
const smClass$6 = "h-2 w-2";
const mdClass$6 = "h-2.5 w-2.5";
const lgClass$6 = "h-3 w-3";
const xlClass$6 = "h-3.5 w-3.5";
function instance$2w($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { placement = "top-right" } = $$props;
  const shape = getContext("avatar-shape");
  const size = getContext("avatar-size");
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("placement" in $$new_props)
      $$invalidate(4, placement = $$new_props.placement);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(
      defaultClass$1S,
      placement === "top-right" ? topRightClass$1 : false,
      placement === "top-left" ? topLeftClass$1 : false,
      placement === "bottom-right" ? bottomRightClass$1 : false,
      placement === "bottom-left" ? bottomLeftClass$1 : false,
      shape !== "circle" ? notCircleClass$1 : false,
      shape !== "circle" && placement === "top-left" ? notCircleTopLeftClass$1 : false,
      shape !== "circle" && placement === "top-right" ? notCircleTopRightClass$1 : false,
      shape !== "circle" && placement === "bottom-left" ? notCircleBottomLeftClass$1 : false,
      shape !== "circle" && placement === "bottom-right" ? notCircleBottomRightClass$1 : false,
      size === "xs" ? xsClass$6 : false,
      size === "sm" ? smClass$6 : false,
      size === "md" ? mdClass$6 : false,
      size === "lg" ? lgClass$6 : false,
      size === "xl" ? xlClass$6 : false,
      $$props.class
    ));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, placement];
}
let Indicator$2 = class Indicator extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2w, create_fragment$2y, safe_not_equal, { use: 0, placement: 4 });
  }
};
const Avatar$6 = Avatar$7;
Avatar$6.Indicator = Indicator$2;
Avatar$6.Placeholder = Placeholder$6;
function create_fragment$2x(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const xsClass$5 = "flex overflow-hidden p-0.5 -space-x-1";
const smClass$5 = "flex overflow-hidden p-0.5 -space-x-2";
const mdClass$5 = "flex overflow-hidden p-0.5 -space-x-2";
const lgClass$5 = "flex overflow-hidden p-0.5 -space-x-3";
const xlClass$5 = "flex overflow-hidden p-0.5 -space-x-3";
function instance$2v($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { shape = "circle" } = $$props;
  let { size = "md" } = $$props;
  let { placeholder = true } = $$props;
  setContext("avatar-group-shape", shape);
  setContext("avatar-group-size", size);
  setContext("avatar-group-placeholder", placeholder);
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("shape" in $$new_props)
      $$invalidate(4, shape = $$new_props.shape);
    if ("size" in $$new_props)
      $$invalidate(5, size = $$new_props.size);
    if ("placeholder" in $$new_props)
      $$invalidate(6, placeholder = $$new_props.placeholder);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(size === "xs" ? xsClass$5 : false, size === "sm" ? smClass$5 : false, size === "md" ? mdClass$5 : false, size === "lg" ? lgClass$5 : false, size === "xl" ? xlClass$5 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    finalClass,
    forwardEvents,
    $$props,
    shape,
    size,
    placeholder,
    $$scope,
    slots
  ];
}
let AvatarGroup$1 = class AvatarGroup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2v, create_fragment$2x, safe_not_equal, {
      use: 0,
      shape: 4,
      size: 5,
      placeholder: 6
    });
  }
};
const Placeholder_svelte_svelte_type_style_lang$5 = "";
const get_icon_slot_changes$h = (dirty) => ({});
const get_icon_slot_context$h = (ctx) => ({});
function create_if_block_1$D(ctx) {
  let span;
  let icon;
  let span_class_value;
  let current;
  icon = new Icon$7({
    props: { data: account, size: (
      /*iconSize*/
      ctx[2]
    ) }
  });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", span_class_value = null_to_empty(
        /*iconContainerClass*/
        ctx[3]
      ) + " svelte-13m79ia");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & /*iconSize*/
      4)
        icon_changes.size = /*iconSize*/
        ctx2[2];
      icon.$set(icon_changes);
      if (!current || dirty & /*iconContainerClass*/
      8 && span_class_value !== (span_class_value = null_to_empty(
        /*iconContainerClass*/
        ctx2[3]
      ) + " svelte-13m79ia")) {
        attr(span, "class", span_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block$U(ctx) {
  let t2;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[10].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_icon_slot_context$h
  );
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
    },
    l(nodes) {
      if (icon_slot)
        icon_slot.l(nodes);
      t2 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      insert_hydration(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_icon_slot_changes$h
            ),
            get_icon_slot_context$h
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (icon_slot)
        icon_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$2w(ctx) {
  let div2;
  let current_block_type_index;
  let if_block;
  let useActions_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$U, create_if_block_1$D];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[7].icon || /*$$slots*/
      ctx2[7].default
    )
      return 0;
    if (
      /*placeholder*/
      ctx2[5]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[6],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
      toggle_class(div2, "svelte-13m79ia", true);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[4].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div2, null);
        } else {
          if_block = null;
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        64 && exclude(
          /*$$props*/
          ctx2[6],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(div2, "svelte-13m79ia", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, fade, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, fade, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1R = "absolute text-content inset-0 h-full w-full flex items-center justify-center overflow-hidden bg-default";
const circleClass$a = "rounded-full";
const roundedClass$a = "rounded-md";
const defaultIconContainerClass$3 = "absolute text-content h-full w-full";
const xsContainerClass$3 = "bottom-[-0.25rem]";
const smContainerClass$3 = "bottom-[-0.35rem]";
const mdContainerClass$3 = "bottom-[-0.5rem]";
const lgContainerClass$3 = "text-6xl bottom-[-0.6rem]";
const xlContainerClass$3 = "bottom-[-0.75rem]";
const xsIconSize$3 = "24px";
const smIconSize$3 = "32px";
const mdIconSize$3 = "40px";
const lgIconSize$3 = "48px";
const xlIconSize$3 = "64px";
function instance$2u($$self, $$props, $$invalidate) {
  let iconContainerClass2;
  let iconSize2;
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { loading = false } = $$props;
  const shape = getContext("avatar-group-shape");
  const size = getContext("avatar-group-size");
  const placeholder = getContext("avatar-group-placeholder");
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("loading" in $$new_props)
      $$invalidate(8, loading = $$new_props.loading);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1R, loading ? "loading" : false, shape === "circle" ? circleClass$a : false, shape === "rounded" ? roundedClass$a : false, $$props.class));
  };
  $$invalidate(3, iconContainerClass2 = twMerge(defaultIconContainerClass$3, size === "xs" ? xsContainerClass$3 : false, size === "sm" ? smContainerClass$3 : false, size === "md" ? mdContainerClass$3 : false, size === "lg" ? lgContainerClass$3 : false, size === "xl" ? xlContainerClass$3 : false));
  $$invalidate(2, iconSize2 = twMerge(size === "xs" ? xsIconSize$3 : false, size === "sm" ? smIconSize$3 : false, size === "md" ? mdIconSize$3 : false, size === "lg" ? lgIconSize$3 : false, size === "xl" ? xlIconSize$3 : false));
  $$props = exclude_internal_props($$props);
  return [
    use,
    finalClass,
    iconSize2,
    iconContainerClass2,
    forwardEvents,
    placeholder,
    $$props,
    $$slots,
    loading,
    $$scope,
    slots
  ];
}
let Placeholder$5 = class Placeholder2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2u, create_fragment$2w, safe_not_equal, { use: 0, loading: 8 });
  }
};
const get_indicator_slot_changes$6 = (dirty) => ({});
const get_indicator_slot_context$6 = (ctx) => ({});
const get_placeholder_slot_changes$5 = (dirty) => ({});
const get_placeholder_slot_context$5 = (ctx) => ({});
function create_if_block_5$g(ctx) {
  let span1;
  let span0;
  let t2;
  let useActions_action;
  let mounted;
  let dispose;
  let span1_levels = [
    { class: (
      /*finalClass*/
      ctx[8]
    ) },
    exclude(
      /*$$props*/
      ctx[11],
      ["use", "class"]
    )
  ];
  let span_data_1 = {};
  for (let i2 = 0; i2 < span1_levels.length; i2 += 1) {
    span_data_1 = assign$1(span_data_1, span1_levels[i2]);
  }
  return {
    c() {
      span1 = element("span");
      span0 = element("span");
      t2 = text(
        /*initials*/
        ctx[3]
      );
      this.h();
    },
    l(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t2 = claim_text(
        span0_nodes,
        /*initials*/
        ctx[3]
      );
      span0_nodes.forEach(detach);
      span1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "class", "font-bold leading-none text-current");
      toggle_class(
        span0,
        "text-xs",
        /*size*/
        ctx[10] === "xs"
      );
      toggle_class(
        span0,
        "text-sm",
        /*size*/
        ctx[10] === "sm"
      );
      toggle_class(
        span0,
        "text-xl",
        /*size*/
        ctx[10] === "lg"
      );
      toggle_class(
        span0,
        "text-2xl",
        /*size*/
        ctx[10] === "xl"
      );
      set_attributes(span1, span_data_1);
    },
    m(target, anchor) {
      insert_hydration(target, span1, anchor);
      append_hydration(span1, span0);
      append_hydration(span0, t2);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span1,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[9].call(null, span1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*initials*/
      8)
        set_data(
          t2,
          /*initials*/
          ctx2[3]
        );
      set_attributes(span1, span_data_1 = get_spread_update(span1_levels, [
        dirty & /*finalClass*/
        256 && { class: (
          /*finalClass*/
          ctx2[8]
        ) },
        dirty & /*$$props*/
        2048 && exclude(
          /*$$props*/
          ctx2[11],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$T(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$C, create_if_block_2$o, create_if_block_4$i];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*loaded*/
      ctx2[4]
    )
      return 0;
    if (
      /*failed*/
      ctx2[5]
    )
      return 1;
    if (
      /*loading*/
      ctx2[6]
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const indicator_slot_template = (
    /*#slots*/
    ctx[14].indicator
  );
  const indicator_slot = create_slot(
    indicator_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_indicator_slot_context$6
  );
  let span_levels = [
    { class: (
      /*finalContainerClass*/
      ctx[7]
    ) },
    exclude(
      /*$$props*/
      ctx[11],
      ["use", "class", "src"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (if_block)
        if_block.c();
      t2 = space();
      if (indicator_slot)
        indicator_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      t2 = claim_space(span_nodes);
      if (indicator_slot)
        indicator_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(span, null);
      }
      append_hydration(span, t2);
      if (indicator_slot) {
        indicator_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[9].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(span, t2);
        } else {
          if_block = null;
        }
      }
      if (indicator_slot) {
        if (indicator_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            indicator_slot,
            indicator_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              indicator_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_indicator_slot_changes$6
            ),
            get_indicator_slot_context$6
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalContainerClass*/
        128) && { class: (
          /*finalContainerClass*/
          ctx2[7]
        ) },
        dirty & /*$$props*/
        2048 && exclude(
          /*$$props*/
          ctx2[11],
          ["use", "class", "src"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(indicator_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(indicator_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (indicator_slot)
        indicator_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4$i(ctx) {
  let placeholder;
  let current;
  placeholder = new Placeholder$5({ props: { loading: true } });
  return {
    c() {
      create_component(placeholder.$$.fragment);
    },
    l(nodes) {
      claim_component(placeholder.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(placeholder, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(placeholder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(placeholder, detaching);
    }
  };
}
function create_if_block_2$o(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3$n, create_else_block$n];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[12].placeholder
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_1$C(ctx) {
  let img;
  let img_style_value;
  let img_src_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", {
        class: true,
        style: true,
        src: true,
        alt: true
      });
      this.h();
    },
    h() {
      attr(
        img,
        "class",
        /*finalClass*/
        ctx[8]
      );
      attr(img, "style", img_style_value = /*$$props*/
      ctx[11].style);
      if (!src_url_equal(img.src, img_src_value = /*src*/
      ctx[1] || ""))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*alt*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*finalClass*/
      256) {
        attr(
          img,
          "class",
          /*finalClass*/
          ctx2[8]
        );
      }
      if (dirty & /*$$props*/
      2048 && img_style_value !== (img_style_value = /*$$props*/
      ctx2[11].style)) {
        attr(img, "style", img_style_value);
      }
      if (dirty & /*src*/
      2 && !src_url_equal(img.src, img_src_value = /*src*/
      ctx2[1] || "")) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*alt*/
      4) {
        attr(
          img,
          "alt",
          /*alt*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_else_block$n(ctx) {
  let placeholder;
  let current;
  placeholder = new Placeholder$5({});
  return {
    c() {
      create_component(placeholder.$$.fragment);
    },
    l(nodes) {
      claim_component(placeholder.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(placeholder, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(placeholder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(placeholder, detaching);
    }
  };
}
function create_if_block_3$n(ctx) {
  let current;
  const placeholder_slot_template = (
    /*#slots*/
    ctx[14].placeholder
  );
  const placeholder_slot = create_slot(
    placeholder_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_placeholder_slot_context$5
  );
  return {
    c() {
      if (placeholder_slot)
        placeholder_slot.c();
    },
    l(nodes) {
      if (placeholder_slot)
        placeholder_slot.l(nodes);
    },
    m(target, anchor) {
      if (placeholder_slot) {
        placeholder_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (placeholder_slot) {
        if (placeholder_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            placeholder_slot,
            placeholder_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              placeholder_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_placeholder_slot_changes$5
            ),
            get_placeholder_slot_context$5
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(placeholder_slot, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_slot, local);
      current = false;
    },
    d(detaching) {
      if (placeholder_slot)
        placeholder_slot.d(detaching);
    }
  };
}
function create_fragment$2v(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$T, create_if_block_5$g];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*src*/
      ctx2[1]
    )
      return 0;
    if (
      /*initials*/
      ctx2[3]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
const srcClass$4 = "inline-block absolute ring-2 ring-surface";
const srcContainerClass$4 = "inline-block relative align-middle";
const initialClass$3 = "inline-flex items-center justify-center align-middle bg-default text-content ring-2 ring-surface";
const xsClass$4 = "h-6 w-6";
const smClass$4 = "h-8 w-8";
const mdClass$4 = "h-10 w-10";
const lgClass$4 = "h-12 w-12";
const xlClass$4 = "h-16 w-16";
const circleClass$9 = "rounded-full";
const roundedClass$9 = "rounded-md";
function instance$2t($$self, $$props, $$invalidate) {
  let finalClass;
  let finalContainerClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { src = void 0 } = $$props;
  let { alt = "avatar" } = $$props;
  let { initials = void 0 } = $$props;
  let loaded = false;
  let failed = false;
  let loading = true;
  const shape = getContext("avatar-group-shape");
  const size = getContext("avatar-group-size");
  onMount(() => {
    if (src) {
      const image = new Image();
      image.src = src;
      $$invalidate(6, loading = true);
      image.onload = () => {
        $$invalidate(6, loading = false);
        $$invalidate(4, loaded = true);
      };
      image.onerror = () => {
        $$invalidate(6, loading = false);
        $$invalidate(5, failed = true);
      };
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(11, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("src" in $$new_props)
      $$invalidate(1, src = $$new_props.src);
    if ("alt" in $$new_props)
      $$invalidate(2, alt = $$new_props.alt);
    if ("initials" in $$new_props)
      $$invalidate(3, initials = $$new_props.initials);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(8, finalClass = twMerge(src && !initials ? srcClass$4 : false, initials && !src ? initialClass$3 : false, size === "xs" ? xsClass$4 : false, size === "sm" ? smClass$4 : false, size === "md" ? mdClass$4 : false, size === "lg" ? lgClass$4 : false, size === "xl" ? xlClass$4 : false, shape === "circle" ? circleClass$9 : false, shape === "rounded" ? roundedClass$9 : false, $$props.class));
    $$invalidate(7, finalContainerClass = twMerge(src && !initials ? srcContainerClass$4 : false, size === "xs" ? xsClass$4 : false, size === "sm" ? smClass$4 : false, size === "md" ? mdClass$4 : false, size === "lg" ? lgClass$4 : false, size === "xl" ? xlClass$4 : false, shape === "circle" ? circleClass$9 : false, shape === "rounded" ? roundedClass$9 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    src,
    alt,
    initials,
    loaded,
    failed,
    loading,
    finalContainerClass,
    finalClass,
    forwardEvents,
    size,
    $$props,
    $$slots,
    $$scope,
    slots
  ];
}
let Avatar$5 = class Avatar2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2t, create_fragment$2v, safe_not_equal, { use: 0, src: 1, alt: 2, initials: 3 });
  }
};
function create_fragment$2u(ctx) {
  let span;
  let useActions_action;
  let mounted;
  let dispose;
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      children(span).forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*finalClass*/
        2 && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1Q = "absolute block rounded-full ring-2 ring-surface bg-primary";
const topRightClass = "top-0 right-0";
const topLeftClass = "top-0 left-0";
const bottomLeftClass = "bottom-0 left-0";
const bottomRightClass = "bottom-0 right-0";
const notCircleClass = "transform";
const notCircleTopRightClass = "-translate-y-1/2 translate-x-1/2";
const notCircleTopLeftClass = "-translate-y-1/2 -translate-x-1/2";
const notCircleBottomRightClass = "translate-y-1/2 translate-x-1/2";
const notCircleBottomLeftClass = "translate-y-1/2 -translate-x-1/2";
const xsClass$3 = "h-1.5 w-1.5";
const smClass$3 = "h-2 w-2";
const mdClass$3 = "h-2.5 w-2.5";
const lgClass$3 = "h-3 w-3";
const xlClass$3 = "h-3.5 w-3.5";
function instance$2s($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { placement = "top-right" } = $$props;
  const shape = getContext("avatar-group-shape");
  const size = getContext("avatar-group-size");
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("placement" in $$new_props)
      $$invalidate(4, placement = $$new_props.placement);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(
      defaultClass$1Q,
      placement === "top-right" ? topRightClass : false,
      placement === "top-left" ? topLeftClass : false,
      placement === "bottom-right" ? bottomRightClass : false,
      placement === "bottom-left" ? bottomLeftClass : false,
      shape !== "circle" ? notCircleClass : false,
      shape !== "circle" && placement === "top-left" ? notCircleTopLeftClass : false,
      shape !== "circle" && placement === "top-right" ? notCircleTopRightClass : false,
      shape !== "circle" && placement === "bottom-left" ? notCircleBottomLeftClass : false,
      shape !== "circle" && placement === "bottom-right" ? notCircleBottomRightClass : false,
      size === "xs" ? xsClass$3 : false,
      size === "sm" ? smClass$3 : false,
      size === "md" ? mdClass$3 : false,
      size === "lg" ? lgClass$3 : false,
      size === "xl" ? xlClass$3 : false,
      $$props.class
    ));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, placement];
}
let Indicator$1 = class Indicator2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2s, create_fragment$2u, safe_not_equal, { use: 0, placement: 4 });
  }
};
const AvatarGroup2 = AvatarGroup$1;
AvatarGroup2.Avatar = Avatar$5;
AvatarGroup2.Avatar.Indicator = Indicator$1;
AvatarGroup2.Avatar.Placeholder = Placeholder$5;
const get_close_slot_changes$1 = (dirty) => ({});
const get_close_slot_context$1 = (ctx) => ({});
const get_indicator_slot_changes$5 = (dirty) => ({});
const get_indicator_slot_context$5 = (ctx) => ({});
function create_fragment$2t(ctx) {
  let span;
  let t0;
  let t1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const indicator_slot_template = (
    /*#slots*/
    ctx[9].indicator
  );
  const indicator_slot = create_slot(
    indicator_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_indicator_slot_context$5
  );
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  const close_slot_template = (
    /*#slots*/
    ctx[9].close
  );
  const close_slot = create_slot(
    close_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    get_close_slot_context$1
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (indicator_slot)
        indicator_slot.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (close_slot)
        close_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (indicator_slot)
        indicator_slot.l(span_nodes);
      t0 = claim_space(span_nodes);
      if (default_slot)
        default_slot.l(span_nodes);
      t1 = claim_space(span_nodes);
      if (close_slot)
        close_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
      toggle_class(
        span,
        "pr-0.5",
        /*$$slots*/
        ctx[4].close
      );
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (indicator_slot) {
        indicator_slot.m(span, null);
      }
      append_hydration(span, t0);
      if (default_slot) {
        default_slot.m(span, null);
      }
      append_hydration(span, t1);
      if (close_slot) {
        close_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (indicator_slot) {
        if (indicator_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            indicator_slot,
            indicator_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              indicator_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_indicator_slot_changes$5
            ),
            get_indicator_slot_context$5
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (close_slot) {
        if (close_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            close_slot,
            close_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              close_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              get_close_slot_changes$1
            ),
            get_close_slot_context$1
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(
        span,
        "pr-0.5",
        /*$$slots*/
        ctx2[4].close
      );
    },
    i(local) {
      if (current)
        return;
      transition_in(indicator_slot, local);
      transition_in(default_slot, local);
      transition_in(close_slot, local);
      current = true;
    },
    o(local) {
      transition_out(indicator_slot, local);
      transition_out(default_slot, local);
      transition_out(close_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (indicator_slot)
        indicator_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (close_slot)
        close_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1P = "inline-flex items-center py-0.5 font-medium text-default-content bg-default";
const infoClass$2 = "bg-info text-info-content";
const successClass$2 = "bg-success text-success-content";
const warnClass$2 = "bg-warn text-warn-content";
const errorClass$7 = "bg-error text-error-content";
const defaultSize = "px-2 text-xs";
const largeSize = "px-3 text-sm";
const defaultShape = "rounded-full";
const roundedShape = "rounded";
function instance$2r($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { type = void 0 } = $$props;
  let { size = "default" } = $$props;
  let { shape = "default" } = $$props;
  setContext("badge-type", type);
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("type" in $$new_props)
      $$invalidate(5, type = $$new_props.type);
    if ("size" in $$new_props)
      $$invalidate(6, size = $$new_props.size);
    if ("shape" in $$new_props)
      $$invalidate(7, shape = $$new_props.shape);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1P, type === "info" ? infoClass$2 : false, type === "success" ? successClass$2 : false, type === "warn" ? warnClass$2 : false, type === "error" ? errorClass$7 : false, size === "default" ? defaultSize : false, size === "large" ? largeSize : false, shape === "default" ? defaultShape : false, shape === "rounded" ? roundedShape : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    finalClass,
    forwardEvents,
    $$props,
    $$slots,
    type,
    size,
    shape,
    $$scope,
    slots
  ];
}
let Badge$1 = class Badge extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2r, create_fragment$2t, safe_not_equal, { use: 0, type: 5, size: 6, shape: 7 });
  }
};
function create_fragment$2s(ctx) {
  let svg;
  let circle;
  let useActions_action;
  let mounted;
  let dispose;
  let svg_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    ),
    { fill: "currentColor" },
    { viewBox: "0 0 8 8" }
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", { class: true, fill: true, viewBox: true });
      var svg_nodes = children(svg);
      circle = claim_svg_element(svg_nodes, "circle", { cx: true, cy: true, r: true });
      children(circle).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(circle, "cx", "4");
      attr(circle, "cy", "4");
      attr(circle, "r", "3");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, circle);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svg,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, svg)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & /*finalClass*/
        2 && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        ),
        { fill: "currentColor" },
        { viewBox: "0 0 8 8" }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1O = "-ml-0.5 mr-1.5 h-2 w-2";
const infoClass$1 = "text-info-content";
const successClass$1 = "text-success-content";
const warnClass$1 = "text-warn-content";
const errorClass$6 = "text-error-content";
function instance$2q($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const type = getContext("badge-type");
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1O, type === "info" ? infoClass$1 : false, type === "success" ? successClass$1 : false, type === "warn" ? warnClass$1 : false, type === "error" ? errorClass$6 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props];
}
class Indicator3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2q, create_fragment$2s, safe_not_equal, { use: 0 });
  }
}
function create_fragment$2r(ctx) {
  let button;
  let span;
  let textContent = "Remove option";
  let t1;
  let svg;
  let path;
  let useActions_action;
  let mounted;
  let dispose;
  let button_levels = [
    { "aria-label": "close" },
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let button_data = {};
  for (let i2 = 0; i2 < button_levels.length; i2 += 1) {
    button_data = assign$1(button_data, button_levels[i2]);
  }
  return {
    c() {
      button = element("button");
      span = element("span");
      span.textContent = textContent;
      t1 = space();
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { "aria-label": true, class: true });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-1tw6350")
        span.textContent = textContent;
      t1 = claim_space(button_nodes);
      svg = claim_svg_element(button_nodes, "svg", {
        class: true,
        stroke: true,
        fill: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        "stroke-linecap": true,
        "stroke-width": true,
        d: true
      });
      children(path).forEach(detach);
      svg_nodes.forEach(detach);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "sr-only");
      attr(path, "stroke-linecap", "round");
      attr(path, "stroke-width", "1.5");
      attr(path, "d", "M1 1l6 6m0-6L1 7");
      attr(svg, "class", "h-2 w-2");
      attr(svg, "stroke", "currentColor");
      attr(svg, "fill", "none");
      attr(svg, "viewBox", "0 0 8 8");
      set_attributes(button, button_data);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, span);
      append_hydration(button, t1);
      append_hydration(button, svg);
      append_hydration(svg, path);
      if (button.autofocus)
        button.focus();
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            button,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, button)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { "aria-label": "close" },
        dirty & /*finalClass*/
        2 && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1N = "ml-1.5 flex-shrink-0 h-4 w-4 rounded-full inline-flex items-center justify-center focus:outline-none hover:bg-default text-default-content hover:bg-background hover:bg-opacity-50 hover:text-content";
const infoClass = " text-info-content";
const successClass = " text-success-content";
const warnClass = " text-warn-content";
const errorClass$5 = "text-error-content";
function instance$2p($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const type = getContext("badge-type");
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1N, type === "info" ? infoClass : false, type === "success" ? successClass : false, type === "warn" ? warnClass : false, type === "error" ? errorClass$5 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props];
}
let Close$1 = class Close extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2p, create_fragment$2r, safe_not_equal, { use: 0 });
  }
};
const Badge2 = Badge$1;
Badge2.Indicator = Indicator3;
Badge2.Close = Close$1;
const Breadcrumbs_svelte_svelte_type_style_lang = "";
function create_fragment$2q(ctx) {
  let nav;
  let ol;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let ol_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let ol_data = {};
  for (let i2 = 0; i2 < ol_levels.length; i2 += 1) {
    ol_data = assign$1(ol_data, ol_levels[i2]);
  }
  return {
    c() {
      nav = element("nav");
      ol = element("ol");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      nav = claim_element(nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      ol = claim_element(nav_nodes, "OL", { class: true });
      var ol_nodes = children(ol);
      if (default_slot)
        default_slot.l(ol_nodes);
      ol_nodes.forEach(detach);
      nav_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(ol, ol_data);
      attr(nav, "class", "flex");
    },
    m(target, anchor) {
      insert_hydration(target, nav, anchor);
      append_hydration(nav, ol);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            ol,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, ol)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ol, ol_data = get_spread_update(ol_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(nav);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1M = "breadcrumbs flex items-center space-x-4";
const solidClass$1 = "border border-border bg-surface rounded-md px-6";
function instance$2o($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { type = "ghost" } = $$props;
  setContext("breadcrumbs-type", type);
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("type" in $$new_props)
      $$invalidate(4, type = $$new_props.type);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1M, type === "solid" ? solidClass$1 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, type, $$scope, slots];
}
let Breadcrumbs$1 = class Breadcrumbs extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2o, create_fragment$2q, safe_not_equal, { use: 0, type: 4 });
  }
};
function create_if_block_1$B(ctx) {
  let svg;
  let path;
  let useActions_action;
  let mounted;
  let dispose;
  let svg_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    ),
    { viewBox: "0 0 24 44" },
    { preserveAspectRatio: "none" },
    { fill: "currentColor" },
    { xmlns: "http://www.w3.org/2000/svg" }
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        class: true,
        viewBox: true,
        preserveAspectRatio: true,
        fill: true,
        xmlns: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path, "d", "M.293 0l22 22-22 22h1.414l22-22-22-22H.293z");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, path);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svg,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, svg)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & /*finalClass*/
        2 && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        ),
        { viewBox: "0 0 24 44" },
        { preserveAspectRatio: "none" },
        { fill: "currentColor" },
        { xmlns: "http://www.w3.org/2000/svg" }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$S(ctx) {
  let svg;
  let path;
  let useActions_action;
  let mounted;
  let dispose;
  let svg_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    ),
    { xmlns: "http://www.w3.org/2000/svg" },
    { viewBox: "0 0 20 20" },
    { fill: "currentColor" }
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        class: true,
        xmlns: true,
        viewBox: true,
        fill: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", {
        "fill-rule": true,
        d: true,
        "clip-rule": true
      });
      children(path).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path, "fill-rule", "evenodd");
      attr(path, "d", "M7.21 14.77a.75.75 0 01.02-1.06L11.168 10 7.23 6.29a.75.75 0 111.04-1.08l4.5 4.25a.75.75 0 010 1.08l-4.5 4.25a.75.75 0 01-1.06-.02z");
      attr(path, "clip-rule", "evenodd");
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, path);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svg,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, svg)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & /*finalClass*/
        2 && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        ),
        { xmlns: "http://www.w3.org/2000/svg" },
        { viewBox: "0 0 20 20" },
        { fill: "currentColor" }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$2p(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*type*/
      ctx2[3] === "ghost"
    )
      return create_if_block$S;
    if (
      /*type*/
      ctx2[3] === "solid"
    )
      return create_if_block_1$B;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (if_block)
        if_block.p(ctx2, dirty);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) {
        if_block.d(detaching);
      }
    }
  };
}
const ghostClass = "divider flex-shrink-0 h-5 w-5 fill-border";
const solidClass = "divider flex-shrink-0 w-6 h-full fill-border";
function instance$2n($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const type = getContext("breadcrumbs-type");
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(type === "ghost" ? ghostClass : false, type === "solid" ? solidClass : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, type, $$props];
}
let Divider$1 = class Divider extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2n, create_fragment$2p, safe_not_equal, { use: 0 });
  }
};
const get_label_slot_changes$c = (dirty) => ({});
const get_label_slot_context$c = (ctx) => ({});
const get_icon_slot_changes$g = (dirty) => ({});
const get_icon_slot_context$g = (ctx) => ({});
const get_divider_slot_changes$1 = (dirty) => ({});
const get_divider_slot_context$1 = (ctx) => ({});
function create_else_block$m(ctx) {
  let divider;
  let current;
  divider = new Divider$1({});
  return {
    c() {
      create_component(divider.$$.fragment);
    },
    l(nodes) {
      claim_component(divider.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(divider, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(divider.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(divider.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(divider, detaching);
    }
  };
}
function create_if_block$R(ctx) {
  let current;
  const divider_slot_template = (
    /*#slots*/
    ctx[7].divider
  );
  const divider_slot = create_slot(
    divider_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_divider_slot_context$1
  );
  return {
    c() {
      if (divider_slot)
        divider_slot.c();
    },
    l(nodes) {
      if (divider_slot)
        divider_slot.l(nodes);
    },
    m(target, anchor) {
      if (divider_slot) {
        divider_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (divider_slot) {
        if (divider_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            divider_slot,
            divider_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              divider_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_divider_slot_changes$1
            ),
            get_divider_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(divider_slot, local);
      current = true;
    },
    o(local) {
      transition_out(divider_slot, local);
      current = false;
    },
    d(detaching) {
      if (divider_slot)
        divider_slot.d(detaching);
    }
  };
}
function create_fragment$2o(ctx) {
  let li;
  let div2;
  let current_block_type_index;
  let if_block;
  let t0;
  let a3;
  let t1;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$R, create_else_block$m];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[5].divider
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const icon_slot_template = (
    /*#slots*/
    ctx[7].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_icon_slot_context$g
  );
  const label_slot_template = (
    /*#slots*/
    ctx[7].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_label_slot_context$c
  );
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      div2 = element("div");
      if_block.c();
      t0 = space();
      a3 = element("a");
      if (icon_slot)
        icon_slot.c();
      t1 = space();
      if (label_slot)
        label_slot.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      div2 = claim_element(li_nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if_block.l(div_nodes);
      t0 = claim_space(div_nodes);
      a3 = claim_element(div_nodes, "A", { href: true, class: true });
      var a_nodes = children(a3);
      if (icon_slot)
        icon_slot.l(a_nodes);
      t1 = claim_space(a_nodes);
      if (label_slot)
        label_slot.l(a_nodes);
      t2 = claim_space(a_nodes);
      if (default_slot)
        default_slot.l(a_nodes);
      a_nodes.forEach(detach);
      div_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(
        a3,
        "href",
        /*href*/
        ctx[1]
      );
      attr(a3, "class", "flex items-center");
      set_attributes(div2, div_data);
      attr(li, "class", "crumb");
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, div2);
      if_blocks[current_block_type_index].m(div2, null);
      append_hydration(div2, t0);
      append_hydration(div2, a3);
      if (icon_slot) {
        icon_slot.m(a3, null);
      }
      append_hydration(a3, t1);
      if (label_slot) {
        label_slot.m(a3, null);
      }
      append_hydration(a3, t2);
      if (default_slot) {
        default_slot.m(a3, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div2, t0);
      }
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_icon_slot_changes$g
            ),
            get_icon_slot_context$g
          );
        }
      }
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_label_slot_changes$c
            ),
            get_label_slot_context$c
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*href*/
      2) {
        attr(
          a3,
          "href",
          /*href*/
          ctx2[1]
        );
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(icon_slot, local);
      transition_in(label_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(icon_slot, local);
      transition_out(label_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if_blocks[current_block_type_index].d();
      if (icon_slot)
        icon_slot.d(detaching);
      if (label_slot)
        label_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1L = "flex items-center text-secondary-content hover:text-primary";
function instance$2m($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { href } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("href" in $$new_props)
      $$invalidate(1, href = $$new_props.href);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(2, finalClass = twMerge(defaultClass$1L, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, href, finalClass, forwardEvents, $$props, $$slots, $$scope, slots];
}
class Crumb extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2m, create_fragment$2o, safe_not_equal, { use: 0, href: 1 });
  }
}
function create_fragment$2n(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1K = "ml-4 text-sm font-medium";
function instance$2l($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1K, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Label$a = class Label2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2l, create_fragment$2n, safe_not_equal, { use: 0 });
  }
};
const Breadcrumbs2 = Breadcrumbs$1;
Breadcrumbs2.Crumb = Crumb;
Breadcrumbs2.Crumb.Icon = Icon$7;
Breadcrumbs2.Crumb.Label = Label$a;
Breadcrumbs2.Crumb.Divider = Divider$1;
function create_fragment$2m(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1J = "relative z-0 inline-flex shadow-md rounded-md border border-border divide-x divide-border";
function instance$2k($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { block = false } = $$props;
  setContext("button-group-block", block);
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("block" in $$new_props)
      $$invalidate(4, block = $$new_props.block);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1J, block ? "w-full" : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, block, $$scope, slots];
}
let ButtonGroup$1 = class ButtonGroup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2k, create_fragment$2m, safe_not_equal, { use: 0, block: 4 });
  }
};
const Loader_svelte_svelte_type_style_lang$1 = "";
function create_fragment$2l(ctx) {
  let svg;
  let circle0;
  let circle1;
  let useActions_action;
  let mounted;
  let dispose;
  let svg_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    ),
    { viewBox: "25 25 50 50" },
    { "stroke-width": "5" }
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        class: true,
        viewBox: true,
        "stroke-width": true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { class: true, cx: true, cy: true, r: true });
      children(circle0).forEach(detach);
      circle1 = claim_svg_element(svg_nodes, "circle", { class: true, cx: true, cy: true, r: true });
      children(circle1).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(circle0, "class", "background-circle svelte-gzqvii");
      attr(circle0, "cx", "50");
      attr(circle0, "cy", "50");
      attr(circle0, "r", "20");
      attr(circle1, "class", "animated svelte-gzqvii");
      attr(circle1, "cx", "50");
      attr(circle1, "cy", "50");
      attr(circle1, "r", "20");
      set_svg_attributes(svg, svg_data);
      toggle_class(svg, "svelte-gzqvii", true);
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, circle0);
      append_hydration(svg, circle1);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svg,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, svg)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & /*finalClass*/
        2 && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        ),
        { viewBox: "25 25 50 50" },
        { "stroke-width": "5" }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(svg, "svelte-gzqvii", true);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1I = "button-loader";
function instance$2j($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1I, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props];
}
let Loader$1 = class Loader extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2j, create_fragment$2l, safe_not_equal, { use: 0 });
  }
};
const get_trailing_slot_changes_1$2 = (dirty) => ({});
const get_trailing_slot_context_1$2 = (ctx) => ({ size: iconSize });
const get_icon_slot_changes_2 = (dirty) => ({});
const get_icon_slot_context_2 = (ctx) => ({ slot: "on", size: iconSize });
const get_leading_slot_changes_2 = (dirty) => ({});
const get_leading_slot_context_2 = (ctx) => ({ size: iconSize });
const get_trailing_slot_changes$3 = (dirty) => ({});
const get_trailing_slot_context$3 = (ctx) => ({ size: iconSize });
const get_icon_slot_changes_1 = (dirty) => ({});
const get_icon_slot_context_1 = (ctx) => ({ slot: "on", size: iconSize });
const get_leading_slot_changes_1$1 = (dirty) => ({});
const get_leading_slot_context_1$1 = (ctx) => ({ slot: "on", size: iconSize });
const get_icon_slot_changes$f = (dirty) => ({});
const get_icon_slot_context$f = (ctx) => ({ slot: "on" });
const get_leading_slot_changes$7 = (dirty) => ({});
const get_leading_slot_context$7 = (ctx) => ({ slot: "on", size: iconSize });
function create_else_block$l(ctx) {
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx[11].leading && create_if_block_9$5(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    ctx[11].icon && create_if_block_8$6(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  let if_block2 = (
    /*$$slots*/
    ctx[11].trailing && create_if_block_7$7(ctx)
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    l(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t1 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      t2 = claim_space(nodes);
      if (if_block2)
        if_block2.l(nodes);
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration(target, t1, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration(target, t2, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert_hydration(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[11].leading
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          2048) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_9$5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[11].icon
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_8$6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*$$slots*/
        ctx2[11].trailing
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          2048) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_7$7(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(if_block2_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
    }
  };
}
function create_if_block_1$A(ctx) {
  let current_block_type_index;
  let if_block0;
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_3$m, create_if_block_4$h, create_if_block_5$f, create_if_block_6$7];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[11].leading && /*$$slots*/
      ctx2[11].icon
    )
      return 0;
    if (
      /*$$slots*/
      ctx2[11].leading
    )
      return 1;
    if (
      /*$$slots*/
      ctx2[11].icon
    )
      return 2;
    if (
      /*loading*/
      ctx2[2]
    )
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[12].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  let if_block1 = (
    /*$$slots*/
    ctx[11].trailing && create_if_block_2$n(ctx)
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, t0, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        } else {
          if_block0 = null;
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*$$slots*/
        ctx2[11].trailing
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$n(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block1_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function create_if_block_9$5(ctx) {
  let div2;
  let current;
  const leading_slot_template = (
    /*#slots*/
    ctx[12].leading
  );
  const leading_slot = create_slot(
    leading_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_leading_slot_context_2
  );
  return {
    c() {
      div2 = element("div");
      if (leading_slot)
        leading_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div2);
      if (leading_slot)
        leading_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "flex justify-center items-center relative mr-1");
      set_style(div2, "width", iconSize);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (leading_slot) {
        leading_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (leading_slot) {
        if (leading_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            leading_slot,
            leading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              leading_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_leading_slot_changes_2
            ),
            get_leading_slot_context_2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leading_slot, local);
      current = true;
    },
    o(local) {
      transition_out(leading_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (leading_slot)
        leading_slot.d(detaching);
    }
  };
}
function create_if_block_8$6(ctx) {
  let div2;
  let swap2;
  let current;
  swap2 = new Swap({
    props: {
      loading: (
        /*loading*/
        ctx[2]
      ),
      style: "width: " + iconSize + ";",
      $$slots: {
        off: [create_off_slot_4],
        on: [create_on_slot_4]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      create_component(swap2.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div2);
      claim_component(swap2.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "flex justify-center items-center relative");
      set_style(div2, "width", iconSize);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(swap2, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const swap_changes = {};
      if (dirty & /*loading*/
      4)
        swap_changes.loading = /*loading*/
        ctx2[2];
      if (dirty & /*$$scope*/
      8192) {
        swap_changes.$$scope = { dirty, ctx: ctx2 };
      }
      swap2.$set(swap_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(swap2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(swap2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(swap2);
    }
  };
}
function create_on_slot_4(ctx) {
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[12].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_icon_slot_context_2
  );
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
    },
    l(nodes) {
      if (icon_slot)
        icon_slot.l(nodes);
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_icon_slot_changes_2
            ),
            get_icon_slot_context_2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_off_slot_4(ctx) {
  let buttonloader;
  let current;
  buttonloader = new Loader$1({ props: { slot: "off" } });
  return {
    c() {
      create_component(buttonloader.$$.fragment);
    },
    l(nodes) {
      claim_component(buttonloader.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(buttonloader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(buttonloader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonloader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttonloader, detaching);
    }
  };
}
function create_if_block_7$7(ctx) {
  let div2;
  let current;
  const trailing_slot_template = (
    /*#slots*/
    ctx[12].trailing
  );
  const trailing_slot = create_slot(
    trailing_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_trailing_slot_context_1$2
  );
  return {
    c() {
      div2 = element("div");
      if (trailing_slot)
        trailing_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div2);
      if (trailing_slot)
        trailing_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "flex justify-center items-center relative ml-1");
      set_style(div2, "width", iconSize);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (trailing_slot) {
        trailing_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (trailing_slot) {
        if (trailing_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            trailing_slot,
            trailing_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              trailing_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_trailing_slot_changes_1$2
            ),
            get_trailing_slot_context_1$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(trailing_slot, local);
      current = true;
    },
    o(local) {
      transition_out(trailing_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (trailing_slot)
        trailing_slot.d(detaching);
    }
  };
}
function create_if_block_6$7(ctx) {
  let div2;
  let buttonloader;
  let div_transition;
  let current;
  buttonloader = new Loader$1({});
  return {
    c() {
      div2 = element("div");
      create_component(buttonloader.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      claim_component(buttonloader.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "flex justify-center items-center relative mr-1");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(buttonloader, div2, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(buttonloader.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, scale, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(buttonloader.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, scale, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(buttonloader);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_if_block_5$f(ctx) {
  let div2;
  let swap2;
  let current;
  swap2 = new Swap({
    props: {
      loading: (
        /*loading*/
        ctx[2]
      ),
      style: "width: " + iconSize + ";",
      $$slots: {
        off: [create_off_slot_3],
        on: [create_on_slot_3]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      create_component(swap2.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div2);
      claim_component(swap2.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "flex justify-center items-center relative");
      set_style(div2, "width", iconSize);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(swap2, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const swap_changes = {};
      if (dirty & /*loading*/
      4)
        swap_changes.loading = /*loading*/
        ctx2[2];
      if (dirty & /*$$scope*/
      8192) {
        swap_changes.$$scope = { dirty, ctx: ctx2 };
      }
      swap2.$set(swap_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(swap2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(swap2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(swap2);
    }
  };
}
function create_if_block_4$h(ctx) {
  let div2;
  let swap2;
  let current;
  swap2 = new Swap({
    props: {
      loading: (
        /*loading*/
        ctx[2]
      ),
      style: "width: " + iconSize + ";",
      $$slots: {
        off: [create_off_slot_2],
        on: [create_on_slot_2]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div2 = element("div");
      create_component(swap2.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div2);
      claim_component(swap2.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "flex justify-center items-center relative mr-1");
      set_style(div2, "width", iconSize);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(swap2, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const swap_changes = {};
      if (dirty & /*loading*/
      4)
        swap_changes.loading = /*loading*/
        ctx2[2];
      if (dirty & /*$$scope*/
      8192) {
        swap_changes.$$scope = { dirty, ctx: ctx2 };
      }
      swap2.$set(swap_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(swap2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(swap2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(swap2);
    }
  };
}
function create_if_block_3$m(ctx) {
  let div0;
  let swap0;
  let t2;
  let div1;
  let swap1;
  let current;
  swap0 = new Swap({
    props: {
      loading: (
        /*loading*/
        ctx[2]
      ),
      style: "width: " + iconSize + ";",
      $$slots: {
        off: [create_off_slot_1],
        on: [create_on_slot_1]
      },
      $$scope: { ctx }
    }
  });
  swap1 = new Swap({
    props: {
      loading: (
        /*loading*/
        ctx[2]
      ),
      $$slots: {
        off: [create_off_slot],
        on: [create_on_slot]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div0 = element("div");
      create_component(swap0.$$.fragment);
      t2 = space();
      div1 = element("div");
      create_component(swap1.$$.fragment);
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true, style: true });
      var div0_nodes = children(div0);
      claim_component(swap0.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t2 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(swap1.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "flex justify-center items-center relative mr-1");
      set_style(div0, "width", iconSize);
      attr(div1, "class", "flex justify-center items-center relative");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      mount_component(swap0, div0, null);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, div1, anchor);
      mount_component(swap1, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const swap0_changes = {};
      if (dirty & /*loading*/
      4)
        swap0_changes.loading = /*loading*/
        ctx2[2];
      if (dirty & /*$$scope*/
      8192) {
        swap0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      swap0.$set(swap0_changes);
      const swap1_changes = {};
      if (dirty & /*loading*/
      4)
        swap1_changes.loading = /*loading*/
        ctx2[2];
      if (dirty & /*$$scope*/
      8192) {
        swap1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      swap1.$set(swap1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(swap0.$$.fragment, local);
      transition_in(swap1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(swap0.$$.fragment, local);
      transition_out(swap1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t2);
        detach(div1);
      }
      destroy_component(swap0);
      destroy_component(swap1);
    }
  };
}
function create_on_slot_3(ctx) {
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[12].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_icon_slot_context_1
  );
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
    },
    l(nodes) {
      if (icon_slot)
        icon_slot.l(nodes);
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_icon_slot_changes_1
            ),
            get_icon_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_off_slot_3(ctx) {
  let buttonloader;
  let current;
  buttonloader = new Loader$1({ props: { slot: "off" } });
  return {
    c() {
      create_component(buttonloader.$$.fragment);
    },
    l(nodes) {
      claim_component(buttonloader.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(buttonloader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(buttonloader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonloader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttonloader, detaching);
    }
  };
}
function create_on_slot_2(ctx) {
  let current;
  const leading_slot_template = (
    /*#slots*/
    ctx[12].leading
  );
  const leading_slot = create_slot(
    leading_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_leading_slot_context_1$1
  );
  return {
    c() {
      if (leading_slot)
        leading_slot.c();
    },
    l(nodes) {
      if (leading_slot)
        leading_slot.l(nodes);
    },
    m(target, anchor) {
      if (leading_slot) {
        leading_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (leading_slot) {
        if (leading_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            leading_slot,
            leading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              leading_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_leading_slot_changes_1$1
            ),
            get_leading_slot_context_1$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leading_slot, local);
      current = true;
    },
    o(local) {
      transition_out(leading_slot, local);
      current = false;
    },
    d(detaching) {
      if (leading_slot)
        leading_slot.d(detaching);
    }
  };
}
function create_off_slot_2(ctx) {
  let buttonloader;
  let current;
  buttonloader = new Loader$1({ props: { slot: "off" } });
  return {
    c() {
      create_component(buttonloader.$$.fragment);
    },
    l(nodes) {
      claim_component(buttonloader.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(buttonloader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(buttonloader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonloader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttonloader, detaching);
    }
  };
}
function create_on_slot_1(ctx) {
  let current;
  const leading_slot_template = (
    /*#slots*/
    ctx[12].leading
  );
  const leading_slot = create_slot(
    leading_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_leading_slot_context$7
  );
  return {
    c() {
      if (leading_slot)
        leading_slot.c();
    },
    l(nodes) {
      if (leading_slot)
        leading_slot.l(nodes);
    },
    m(target, anchor) {
      if (leading_slot) {
        leading_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (leading_slot) {
        if (leading_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            leading_slot,
            leading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              leading_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_leading_slot_changes$7
            ),
            get_leading_slot_context$7
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leading_slot, local);
      current = true;
    },
    o(local) {
      transition_out(leading_slot, local);
      current = false;
    },
    d(detaching) {
      if (leading_slot)
        leading_slot.d(detaching);
    }
  };
}
function create_off_slot_1(ctx) {
  let buttonloader;
  let current;
  buttonloader = new Loader$1({ props: { slot: "off" } });
  return {
    c() {
      create_component(buttonloader.$$.fragment);
    },
    l(nodes) {
      claim_component(buttonloader.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(buttonloader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(buttonloader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonloader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttonloader, detaching);
    }
  };
}
function create_on_slot(ctx) {
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[12].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_icon_slot_context$f
  );
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
    },
    l(nodes) {
      if (icon_slot)
        icon_slot.l(nodes);
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_icon_slot_changes$f
            ),
            get_icon_slot_context$f
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_off_slot(ctx) {
  let buttonloader;
  let current;
  buttonloader = new Loader$1({ props: { slot: "off" } });
  return {
    c() {
      create_component(buttonloader.$$.fragment);
    },
    l(nodes) {
      claim_component(buttonloader.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(buttonloader, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(buttonloader.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(buttonloader.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(buttonloader, detaching);
    }
  };
}
function create_if_block_2$n(ctx) {
  let div2;
  let current;
  const trailing_slot_template = (
    /*#slots*/
    ctx[12].trailing
  );
  const trailing_slot = create_slot(
    trailing_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_trailing_slot_context$3
  );
  return {
    c() {
      div2 = element("div");
      if (trailing_slot)
        trailing_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div2);
      if (trailing_slot)
        trailing_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "flex justify-center items-center relative ml-1");
      set_style(div2, "width", iconSize);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (trailing_slot) {
        trailing_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (trailing_slot) {
        if (trailing_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            trailing_slot,
            trailing_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              trailing_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_trailing_slot_changes$3
            ),
            get_trailing_slot_context$3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(trailing_slot, local);
      current = true;
    },
    o(local) {
      transition_out(trailing_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (trailing_slot)
        trailing_slot.d(detaching);
    }
  };
}
function create_if_block$Q(ctx) {
  let hoverbackground;
  let current;
  hoverbackground = new HoverBackground({
    props: {
      class: "group-active:h-full group-active:w-full group-focus:h-full group-focus:w-full"
    }
  });
  return {
    c() {
      create_component(hoverbackground.$$.fragment);
    },
    l(nodes) {
      claim_component(hoverbackground.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(hoverbackground, target, anchor);
      current = true;
    },
    i(local) {
      if (current)
        return;
      transition_in(hoverbackground.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hoverbackground.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(hoverbackground, detaching);
    }
  };
}
function create_fragment$2k(ctx) {
  let button;
  let current_block_type_index;
  let if_block0;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$A, create_else_block$l];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*defaultLoading*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = !/*disabled*/
  ctx[4] && create_if_block$Q();
  let button_levels = [
    { "aria-label": (
      /*ariaLabel*/
      ctx[5]
    ) },
    { type: (
      /*htmlType*/
      ctx[6]
    ) },
    { class: (
      /*finalClass*/
      ctx[7]
    ) },
    { disabled: (
      /*disabled*/
      ctx[4]
    ) },
    exclude(
      /*$$props*/
      ctx[10],
      ["use", "class"]
    )
  ];
  let button_data = {};
  for (let i2 = 0; i2 < button_levels.length; i2 += 1) {
    button_data = assign$1(button_data, button_levels[i2]);
  }
  return {
    c() {
      button = element("button");
      if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", {
        "aria-label": true,
        type: true,
        class: true
      });
      var button_nodes = children(button);
      if_block0.l(button_nodes);
      t2 = claim_space(button_nodes);
      if (if_block1)
        if_block1.l(button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(button, button_data);
      toggle_class(
        button,
        "bg-primary",
        /*active*/
        ctx[1]
      );
      toggle_class(
        button,
        "text-primary-content",
        /*active*/
        ctx[1]
      );
      toggle_class(
        button,
        "focus:bg-primary",
        /*active*/
        ctx[1]
      );
      toggle_class(
        button,
        "focus:text-primary-content",
        /*active*/
        ctx[1]
      );
      toggle_class(button, "bg-surface", !/*active*/
      ctx[1]);
      toggle_class(
        button,
        "disabled",
        /*disabled*/
        ctx[4]
      );
      toggle_class(
        button,
        "w-full",
        /*block*/
        ctx[9]
      );
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      if_blocks[current_block_type_index].m(button, null);
      append_hydration(button, t2);
      if (if_block1)
        if_block1.m(button, null);
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            button,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[8].call(null, button)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(button, t2);
      }
      if (!/*disabled*/
      ctx2[4]) {
        if (if_block1) {
          if (dirty & /*disabled*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$Q();
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(button, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        (!current || dirty & /*ariaLabel*/
        32) && { "aria-label": (
          /*ariaLabel*/
          ctx2[5]
        ) },
        (!current || dirty & /*htmlType*/
        64) && { type: (
          /*htmlType*/
          ctx2[6]
        ) },
        (!current || dirty & /*finalClass*/
        128) && { class: (
          /*finalClass*/
          ctx2[7]
        ) },
        (!current || dirty & /*disabled*/
        16) && { disabled: (
          /*disabled*/
          ctx2[4]
        ) },
        dirty & /*$$props*/
        1024 && exclude(
          /*$$props*/
          ctx2[10],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(
        button,
        "bg-primary",
        /*active*/
        ctx2[1]
      );
      toggle_class(
        button,
        "text-primary-content",
        /*active*/
        ctx2[1]
      );
      toggle_class(
        button,
        "focus:bg-primary",
        /*active*/
        ctx2[1]
      );
      toggle_class(
        button,
        "focus:text-primary-content",
        /*active*/
        ctx2[1]
      );
      toggle_class(button, "bg-surface", !/*active*/
      ctx2[1]);
      toggle_class(
        button,
        "disabled",
        /*disabled*/
        ctx2[4]
      );
      toggle_class(
        button,
        "w-full",
        /*block*/
        ctx2[9]
      );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if_blocks[current_block_type_index].d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
const iconSize = "20px";
const defaultClass$1H = "btn-group group overflow-hidden relative inline-flex items-center justify-center px-4 py-2 text-sm font-medium text-content focus:z-10 outline-none focus:outline-none first-of-type:rounded-l-md last-of-type:rounded-r-md";
const disabledClass$1 = "opacity-70 bg-default hover:bg-default";
function instance$2i($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { active = false } = $$props;
  let { loading = false } = $$props;
  let { defaultLoading = true } = $$props;
  let { disabled = false } = $$props;
  let { ariaLabel = void 0 } = $$props;
  let { htmlType = "button" } = $$props;
  const block = getContext("button-group-block");
  setContext("button-group-button-icon-size", iconSize);
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("active" in $$new_props)
      $$invalidate(1, active = $$new_props.active);
    if ("loading" in $$new_props)
      $$invalidate(2, loading = $$new_props.loading);
    if ("defaultLoading" in $$new_props)
      $$invalidate(3, defaultLoading = $$new_props.defaultLoading);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("ariaLabel" in $$new_props)
      $$invalidate(5, ariaLabel = $$new_props.ariaLabel);
    if ("htmlType" in $$new_props)
      $$invalidate(6, htmlType = $$new_props.htmlType);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(7, finalClass = twMerge(defaultClass$1H, disabled ? disabledClass$1 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    active,
    loading,
    defaultLoading,
    disabled,
    ariaLabel,
    htmlType,
    finalClass,
    forwardEvents,
    block,
    $$props,
    $$slots,
    slots,
    $$scope
  ];
}
class Button extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2i, create_fragment$2k, safe_not_equal, {
      use: 0,
      active: 1,
      loading: 2,
      defaultLoading: 3,
      disabled: 4,
      ariaLabel: 5,
      htmlType: 6
    });
  }
}
function create_fragment$2j(ctx) {
  let svg;
  let useActions_action;
  let mounted;
  let dispose;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: (
      /*width*/
      ctx[2]
    ) },
    { height: (
      /*height*/
      ctx[3]
    ) },
    { viewBox: (
      /*viewBox*/
      ctx[1]
    ) },
    { stroke: (
      /*stroke*/
      ctx[5]
    ) },
    { fill: (
      /*fill*/
      ctx[6]
    ) },
    { color: (
      /*color*/
      ctx[4]
    ) },
    exclude(
      /*$$props*/
      ctx[9],
      [
        "use",
        "data",
        "fill",
        "viewBox",
        "width",
        "height",
        "stroke",
        "size",
        "color"
      ]
    )
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        stroke: true,
        fill: true,
        color: true
      });
      var svg_nodes = children(svg);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      svg.innerHTML = /*elements*/
      ctx[7];
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svg,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[8].call(null, svg)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*elements*/
      128)
        svg.innerHTML = /*elements*/
        ctx2[7];
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty & /*width*/
        4 && { width: (
          /*width*/
          ctx2[2]
        ) },
        dirty & /*height*/
        8 && { height: (
          /*height*/
          ctx2[3]
        ) },
        dirty & /*viewBox*/
        2 && { viewBox: (
          /*viewBox*/
          ctx2[1]
        ) },
        dirty & /*stroke*/
        32 && { stroke: (
          /*stroke*/
          ctx2[5]
        ) },
        dirty & /*fill*/
        64 && { fill: (
          /*fill*/
          ctx2[6]
        ) },
        dirty & /*color*/
        16 && { color: (
          /*color*/
          ctx2[4]
        ) },
        dirty & /*$$props*/
        512 && exclude(
          /*$$props*/
          ctx2[9],
          [
            "use",
            "data",
            "fill",
            "viewBox",
            "width",
            "height",
            "stroke",
            "size",
            "color"
          ]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function extractViewBox$8(svg) {
  const regex = /viewBox="([\d\- ]+)"/;
  const res = regex.exec(svg);
  if (!res)
    return "0 0 24 24";
  return res[1];
}
function instance$2h($$self, $$props, $$invalidate) {
  let elements2;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const iconSize2 = getContext("button-group-button-icon-size");
  let { data = "" } = $$props;
  let { viewBox = extractViewBox$8(data) } = $$props;
  let { size = iconSize2 } = $$props;
  let { width: width2 = size } = $$props;
  let { height = size } = $$props;
  let { color: color2 = "currentColor" } = $$props;
  let { stroke = void 0 } = $$props;
  let { fill: fill2 = color2 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("data" in $$new_props)
      $$invalidate(10, data = $$new_props.data);
    if ("viewBox" in $$new_props)
      $$invalidate(1, viewBox = $$new_props.viewBox);
    if ("size" in $$new_props)
      $$invalidate(11, size = $$new_props.size);
    if ("width" in $$new_props)
      $$invalidate(2, width2 = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(3, height = $$new_props.height);
    if ("color" in $$new_props)
      $$invalidate(4, color2 = $$new_props.color);
    if ("stroke" in $$new_props)
      $$invalidate(5, stroke = $$new_props.stroke);
    if ("fill" in $$new_props)
      $$invalidate(6, fill2 = $$new_props.fill);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data*/
    1024) {
      $$invalidate(7, elements2 = data.replace(/<svg ([^>]*)>/, "").replace("</svg>", ""));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    viewBox,
    width2,
    height,
    color2,
    stroke,
    fill2,
    elements2,
    forwardEvents,
    $$props,
    data,
    size
  ];
}
let Icon$6 = class Icon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2h, create_fragment$2j, safe_not_equal, {
      use: 0,
      data: 10,
      viewBox: 1,
      size: 11,
      width: 2,
      height: 3,
      color: 4,
      stroke: 5,
      fill: 6
    });
  }
};
const ButtonGroup2 = ButtonGroup$1;
ButtonGroup2.Button = Button;
ButtonGroup2.Button.Loader = Loader$1;
ButtonGroup2.Button.Icon = Icon$6;
ButtonGroup2.Button.Leading = Icon$6;
ButtonGroup2.Button.Trailing = Icon$6;
const Carousel_svelte_svelte_type_style_lang = "";
const get_label_slot_changes$b = (dirty) => ({});
const get_label_slot_context$b = (ctx) => ({});
function create_fragment$2i(ctx) {
  let div2;
  let t2;
  let fieldset;
  let fieldset_style_value;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[4].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    get_label_slot_context$b
  );
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div2 = element("div");
      if (label_slot)
        label_slot.c();
      t2 = space();
      fieldset = element("fieldset");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div_nodes = children(div2);
      if (label_slot)
        label_slot.l(div_nodes);
      t2 = claim_space(div_nodes);
      fieldset = claim_element(div_nodes, "FIELDSET", { class: true, style: true });
      var fieldset_nodes = children(fieldset);
      if (default_slot)
        default_slot.l(fieldset_nodes);
      fieldset_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(
        fieldset,
        "class",
        /*finalClass*/
        ctx[0]
      );
      attr(fieldset, "style", fieldset_style_value = /*$$props*/
      ctx[1].style);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (label_slot) {
        label_slot.m(div2, null);
      }
      append_hydration(div2, t2);
      append_hydration(div2, fieldset);
      if (default_slot) {
        default_slot.m(fieldset, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              get_label_slot_changes$b
            ),
            get_label_slot_context$b
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*finalClass*/
      1) {
        attr(
          fieldset,
          "class",
          /*finalClass*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$$props*/
      2 && fieldset_style_value !== (fieldset_style_value = /*$$props*/
      ctx2[1].style)) {
        attr(fieldset, "style", fieldset_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (label_slot)
        label_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
const defaultClass$1G = "space-y-5 mt-2";
function instance$2g($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { inline = false } = $$props;
  setContext("checkbox-inline", inline);
  $$self.$$set = ($$new_props) => {
    $$invalidate(1, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("inline" in $$new_props)
      $$invalidate(2, inline = $$new_props.inline);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(0, finalClass = twMerge(defaultClass$1G, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [finalClass, $$props, inline, $$scope, slots];
}
let CheckboxGroup$1 = class CheckboxGroup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2g, create_fragment$2i, safe_not_equal, { inline: 2 });
  }
};
function create_fragment$2h(ctx) {
  let legend;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let legend_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let legend_data = {};
  for (let i2 = 0; i2 < legend_levels.length; i2 += 1) {
    legend_data = assign$1(legend_data, legend_levels[i2]);
  }
  return {
    c() {
      legend = element("legend");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      legend = claim_element(nodes, "LEGEND", { class: true });
      var legend_nodes = children(legend);
      if (default_slot)
        default_slot.l(legend_nodes);
      legend_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(legend, legend_data);
    },
    m(target, anchor) {
      insert_hydration(target, legend, anchor);
      if (default_slot) {
        default_slot.m(legend, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            legend,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, legend)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(legend, legend_data = get_spread_update(legend_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(legend);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1F = "text-secondary-content font-medium text-sm";
function instance$2f($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1F, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let GroupLabel$1 = class GroupLabel extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2f, create_fragment$2h, safe_not_equal, { use: 0 });
  }
};
const Checkbox_svelte_svelte_type_style_lang = "";
const get_description_slot_changes$6 = (dirty) => ({});
const get_description_slot_context$6 = (ctx) => ({});
const get_label_slot_changes$a = (dirty) => ({});
const get_label_slot_context$a = (ctx) => ({});
function create_if_block$P(ctx) {
  let p;
  let t2;
  let p_id_value;
  let p_transition;
  let current;
  return {
    c() {
      p = element("p");
      t2 = text(
        /*error*/
        ctx[5]
      );
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true, id: true });
      var p_nodes = children(p);
      t2 = claim_text(
        p_nodes,
        /*error*/
        ctx[5]
      );
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(p, "class", "!mt-2 text-sm text-danger");
      attr(p, "id", p_id_value = /*name*/
      ctx[1] + "-error");
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      append_hydration(p, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*error*/
      32)
        set_data(
          t2,
          /*error*/
          ctx2[5]
        );
      if (!current || dirty & /*name*/
      2 && p_id_value !== (p_id_value = /*name*/
      ctx2[1] + "-error")) {
        attr(p, "id", p_id_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!p_transition)
            p_transition = create_bidirectional_transition(p, slide, {}, true);
          p_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!p_transition)
          p_transition = create_bidirectional_transition(p, slide, {}, false);
        p_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (detaching && p_transition)
        p_transition.end();
    }
  };
}
function create_fragment$2g(ctx) {
  let button;
  let div0;
  let input;
  let input_class_value;
  let input_style_value;
  let t0;
  let div1;
  let t1;
  let t2;
  let t3;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  const label_slot_template = (
    /*#slots*/
    ctx[10].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_label_slot_context$a
  );
  const description_slot_template = (
    /*#slots*/
    ctx[10].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_description_slot_context$6
  );
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let if_block = (
    /*error*/
    ctx[5] && create_if_block$P(ctx)
  );
  return {
    c() {
      button = element("button");
      div0 = element("div");
      input = element("input");
      t0 = space();
      div1 = element("div");
      if (label_slot)
        label_slot.c();
      t1 = space();
      if (description_slot)
        description_slot.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
      t3 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { tabindex: true, type: true, class: true });
      var button_nodes = children(button);
      div0 = claim_element(button_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input = claim_element(div0_nodes, "INPUT", {
        id: true,
        name: true,
        type: true,
        class: true,
        style: true
      });
      div0_nodes.forEach(detach);
      t0 = claim_space(button_nodes);
      div1 = claim_element(button_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (label_slot)
        label_slot.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      if (description_slot)
        description_slot.l(div1_nodes);
      t2 = claim_space(div1_nodes);
      if (default_slot)
        default_slot.l(div1_nodes);
      div1_nodes.forEach(detach);
      button_nodes.forEach(detach);
      t3 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h() {
      attr(
        input,
        "id",
        /*name*/
        ctx[1]
      );
      attr(
        input,
        "name",
        /*name*/
        ctx[1]
      );
      input.indeterminate = /*indeterminate*/
      ctx[3];
      input.disabled = /*disabled*/
      ctx[4];
      attr(input, "type", "checkbox");
      input.__value = /*value*/
      ctx[2];
      set_input_value(input, input.__value);
      attr(input, "class", input_class_value = null_to_empty(
        /*finalClass*/
        ctx[6]
      ) + " svelte-9vmu2r");
      attr(input, "style", input_style_value = /*$$props*/
      ctx[8].style);
      attr(div0, "class", "flex items-center h-5");
      attr(div1, "class", "ml-3 text-sm");
      attr(button, "tabindex", "-1");
      attr(button, "type", "button");
      attr(button, "class", "relative flex items-start");
      toggle_class(
        button,
        "pointer-events-none",
        /*disabled*/
        ctx[4]
      );
      toggle_class(
        button,
        "opacity-75",
        /*disabled*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, div0);
      append_hydration(div0, input);
      input.checked = /*checked*/
      ctx[0];
      append_hydration(button, t0);
      append_hydration(button, div1);
      if (label_slot) {
        label_slot.m(div1, null);
      }
      append_hydration(div1, t1);
      if (description_slot) {
        description_slot.m(div1, null);
      }
      append_hydration(div1, t2);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      insert_hydration(target, t3, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[11]
          ),
          listen(
            button,
            "keydown",
            /*handleKeydown*/
            ctx[7]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*name*/
      2) {
        attr(
          input,
          "id",
          /*name*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*name*/
      2) {
        attr(
          input,
          "name",
          /*name*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*indeterminate*/
      8) {
        input.indeterminate = /*indeterminate*/
        ctx2[3];
      }
      if (!current || dirty & /*disabled*/
      16) {
        input.disabled = /*disabled*/
        ctx2[4];
      }
      if (!current || dirty & /*value*/
      4) {
        input.__value = /*value*/
        ctx2[2];
        set_input_value(input, input.__value);
      }
      if (!current || dirty & /*finalClass*/
      64 && input_class_value !== (input_class_value = null_to_empty(
        /*finalClass*/
        ctx2[6]
      ) + " svelte-9vmu2r")) {
        attr(input, "class", input_class_value);
      }
      if (!current || dirty & /*$$props*/
      256 && input_style_value !== (input_style_value = /*$$props*/
      ctx2[8].style)) {
        attr(input, "style", input_style_value);
      }
      if (dirty & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx2[0];
      }
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_label_slot_changes$a
            ),
            get_label_slot_context$a
          );
        }
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_description_slot_changes$6
            ),
            get_description_slot_context$6
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*disabled*/
      16) {
        toggle_class(
          button,
          "pointer-events-none",
          /*disabled*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*disabled*/
      16) {
        toggle_class(
          button,
          "opacity-75",
          /*disabled*/
          ctx2[4]
        );
      }
      if (
        /*error*/
        ctx2[5]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*error*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$P(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(description_slot, local);
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      transition_out(description_slot, local);
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
        detach(t3);
        detach(if_block_anchor);
      }
      if (label_slot)
        label_slot.d(detaching);
      if (description_slot)
        description_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1E = "checkbox checked:bg-primary indeterminate:bg-primary hover:border-primary bg-surface h-6 w-6 text-primary border-border disabled:hover:border-border rounded-md cursor-pointer disabled:checked:bg-default";
function instance$2e($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name } = $$props;
  let { value } = $$props;
  let { indeterminate = false } = $$props;
  let { disabled = false } = $$props;
  let { checked = false } = $$props;
  let { error: error2 = void 0 } = $$props;
  function handleKeydown(e2) {
    if (e2.key === "Spacebar") {
      e2.preventDefault();
      e2.stopPropagation();
      $$invalidate(0, checked = !checked);
    }
  }
  setContext("checkbox-name", name);
  function input_change_handler() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("value" in $$new_props)
      $$invalidate(2, value = $$new_props.value);
    if ("indeterminate" in $$new_props)
      $$invalidate(3, indeterminate = $$new_props.indeterminate);
    if ("disabled" in $$new_props)
      $$invalidate(4, disabled = $$new_props.disabled);
    if ("checked" in $$new_props)
      $$invalidate(0, checked = $$new_props.checked);
    if ("error" in $$new_props)
      $$invalidate(5, error2 = $$new_props.error);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(6, finalClass = twMerge(defaultClass$1E, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    checked,
    name,
    value,
    indeterminate,
    disabled,
    error2,
    finalClass,
    handleKeydown,
    $$props,
    $$scope,
    slots,
    input_change_handler
  ];
}
class Checkbox extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2e, create_fragment$2g, safe_not_equal, {
      name: 1,
      value: 2,
      indeterminate: 3,
      disabled: 4,
      checked: 0,
      error: 5
    });
  }
}
function create_fragment$2f(ctx) {
  let label;
  let label_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      label = claim_element(nodes, "LABEL", { for: true, class: true, style: true });
      var label_nodes = children(label);
      if (default_slot)
        default_slot.l(label_nodes);
      label_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(
        label,
        "for",
        /*name*/
        ctx[1]
      );
      attr(
        label,
        "class",
        /*finalClass*/
        ctx[0]
      );
      attr(label, "style", label_style_value = /*$$props*/
      ctx[2].style);
    },
    m(target, anchor) {
      insert_hydration(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*finalClass*/
      1) {
        attr(
          label,
          "class",
          /*finalClass*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$$props*/
      4 && label_style_value !== (label_style_value = /*$$props*/
      ctx2[2].style)) {
        attr(label, "style", label_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
const defaultClass$1D = "font-medium text-content cursor-pointer";
function instance$2d($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const name = getContext("checkbox-name");
  $$self.$$set = ($$new_props) => {
    $$invalidate(2, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(0, finalClass = twMerge(defaultClass$1D, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [finalClass, name, $$props, $$scope, slots];
}
let Label$9 = class Label3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2d, create_fragment$2f, safe_not_equal, {});
  }
};
function create_else_block$k(ctx) {
  let p;
  let p_id_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let p_levels = [
    {
      id: p_id_value = /*name*/
      ctx[4] + "-description"
    },
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[5],
      ["use", "class"]
    )
  ];
  let p_data = {};
  for (let i2 = 0; i2 < p_levels.length; i2 += 1) {
    p_data = assign$1(p_data, p_levels[i2]);
  }
  return {
    c() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { id: true, class: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(p, p_data);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            p,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, p)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        { id: p_id_value },
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        32 && exclude(
          /*$$props*/
          ctx2[5],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$O(ctx) {
  let span;
  let t2;
  let span_id_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let span_levels = [
    {
      id: span_id_value = /*name*/
      ctx[4] + "-description"
    },
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[5],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      t2 = text("| ");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { id: true, class: true });
      var span_nodes = children(span);
      t2 = claim_text(span_nodes, "| ");
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, t2);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        { id: span_id_value },
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        32 && exclude(
          /*$$props*/
          ctx2[5],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$2e(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$O, create_else_block$k];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*inline*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
const defaultClass$1C = "text-secondary-content";
function instance$2c($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const inline = getContext("checkbox-inline");
  const name = getContext("checkbox-name");
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1C, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, inline, name, $$props, $$scope, slots];
}
let Description$6 = class Description2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2c, create_fragment$2e, safe_not_equal, { use: 0 });
  }
};
const CheckboxGroup2 = CheckboxGroup$1;
CheckboxGroup2.Label = GroupLabel$1;
CheckboxGroup2.Checkbox = Checkbox;
CheckboxGroup2.Checkbox.Label = Label$9;
CheckboxGroup2.Checkbox.Description = Description$6;
const get_close_slot_changes = (dirty) => ({});
const get_close_slot_context = (ctx) => ({});
const get_label_slot_changes$9 = (dirty) => ({});
const get_label_slot_context$9 = (ctx) => ({});
const get_avatar_slot_changes$4 = (dirty) => ({});
const get_avatar_slot_context$4 = (ctx) => ({});
function create_fragment$2d(ctx) {
  let span;
  let t0;
  let t1;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const avatar_slot_template = (
    /*#slots*/
    ctx[7].avatar
  );
  const avatar_slot = create_slot(
    avatar_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_avatar_slot_context$4
  );
  const label_slot_template = (
    /*#slots*/
    ctx[7].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_label_slot_context$9
  );
  const close_slot_template = (
    /*#slots*/
    ctx[7].close
  );
  const close_slot = create_slot(
    close_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_close_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (avatar_slot)
        avatar_slot.c();
      t0 = space();
      if (label_slot)
        label_slot.c();
      t1 = space();
      if (close_slot)
        close_slot.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (avatar_slot)
        avatar_slot.l(span_nodes);
      t0 = claim_space(span_nodes);
      if (label_slot)
        label_slot.l(span_nodes);
      t1 = claim_space(span_nodes);
      if (close_slot)
        close_slot.l(span_nodes);
      t2 = claim_space(span_nodes);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (avatar_slot) {
        avatar_slot.m(span, null);
      }
      append_hydration(span, t0);
      if (label_slot) {
        label_slot.m(span, null);
      }
      append_hydration(span, t1);
      if (close_slot) {
        close_slot.m(span, null);
      }
      append_hydration(span, t2);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (avatar_slot) {
        if (avatar_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            avatar_slot,
            avatar_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              avatar_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_avatar_slot_changes$4
            ),
            get_avatar_slot_context$4
          );
        }
      }
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_label_slot_changes$9
            ),
            get_label_slot_context$9
          );
        }
      }
      if (close_slot) {
        if (close_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            close_slot,
            close_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              close_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_close_slot_changes
            ),
            get_close_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(avatar_slot, local);
      transition_in(label_slot, local);
      transition_in(close_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(avatar_slot, local);
      transition_out(label_slot, local);
      transition_out(close_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (avatar_slot)
        avatar_slot.d(detaching);
      if (label_slot)
        label_slot.d(detaching);
      if (close_slot)
        close_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1B = "inline-flex items-center pr-3 text-sm font-medium border border-border rounded-full";
const defaultTypeClass = " bg-default text-default-content";
const infoTypeClass = " bg-info text-info-content";
const successTypeClass = " bg-success text-success-content";
const warnTypeClass = " bg-warn text-warn-content";
const errorTypeClass = " bg-error text-error-content";
const closeSlotClass = "pr-1.5";
function instance$2b($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { type = "default" } = $$props;
  let { size = "md" } = $$props;
  setContext("chip-size", size);
  setContext("chip-type", type);
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("type" in $$new_props)
      $$invalidate(4, type = $$new_props.type);
    if ("size" in $$new_props)
      $$invalidate(5, size = $$new_props.size);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1B, type === "default" ? defaultTypeClass : false, type === "info" ? infoTypeClass : false, type === "success" ? successTypeClass : false, type === "warn" ? warnTypeClass : false, type === "error" ? errorTypeClass : false, $$slots.close ? closeSlotClass : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, type, size, $$scope, slots];
}
let Chip$1 = class Chip extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2b, create_fragment$2d, safe_not_equal, { use: 0, type: 4, size: 5 });
  }
};
const Placeholder_svelte_svelte_type_style_lang$4 = "";
const get_icon_slot_changes$e = (dirty) => ({});
const get_icon_slot_context$e = (ctx) => ({});
function create_if_block_1$z(ctx) {
  let span;
  let icon;
  let span_class_value;
  let current;
  icon = new Icon$7({
    props: { data: account, size: (
      /*iconSize*/
      ctx[2]
    ) }
  });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", span_class_value = null_to_empty(
        /*iconContainerClass*/
        ctx[3]
      ) + " svelte-13m79ia");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & /*iconSize*/
      4)
        icon_changes.size = /*iconSize*/
        ctx2[2];
      icon.$set(icon_changes);
      if (!current || dirty & /*iconContainerClass*/
      8 && span_class_value !== (span_class_value = null_to_empty(
        /*iconContainerClass*/
        ctx2[3]
      ) + " svelte-13m79ia")) {
        attr(span, "class", span_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block$N(ctx) {
  let t2;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[10].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_icon_slot_context$e
  );
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
    },
    l(nodes) {
      if (icon_slot)
        icon_slot.l(nodes);
      t2 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      insert_hydration(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_icon_slot_changes$e
            ),
            get_icon_slot_context$e
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (icon_slot)
        icon_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$2c(ctx) {
  let div2;
  let current_block_type_index;
  let if_block;
  let useActions_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$N, create_if_block_1$z];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[7].icon || /*$$slots*/
      ctx2[7].default
    )
      return 0;
    if (
      /*placeholder*/
      ctx2[5]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[6],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
      toggle_class(div2, "svelte-13m79ia", true);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[4].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div2, null);
        } else {
          if_block = null;
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        64 && exclude(
          /*$$props*/
          ctx2[6],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(div2, "svelte-13m79ia", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, fade, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, fade, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1A = "absolute text-default-content flex items-center justify-center overflow-hidden bg-default inset-[0.2rem] bg-background";
const circleClass$8 = "rounded-full";
const roundedClass$8 = "rounded-md";
const defaultIconContainerClass$2 = "absolute text-default-content h-full w-full";
const xsContainerClass$2 = "bottom-[-0.1rem] left-[-0.2rem]";
const smContainerClass$2 = "bottom-[-0.2rem] left-[-0.2rem]";
const mdContainerClass$2 = "bottom-[-0.3rem] left-[-0.2rem]";
const lgContainerClass$2 = "bottom-[-0.5rem] left-[-0.2rem]";
const xlContainerClass$2 = "bottom-[-0.5rem] left-[-0.2rem]";
const xsIconSize$2 = "24px";
const smIconSize$2 = "32px";
const mdIconSize$2 = "40px";
const lgIconSize$2 = "48px";
const xlIconSize$2 = "64px";
function instance$2a($$self, $$props, $$invalidate) {
  let iconContainerClass2;
  let iconSize2;
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { loading = false } = $$props;
  const shape = getContext("chip-avatar-shape");
  const size = getContext("chip-avatar-size");
  const placeholder = getContext("chip-avatar-placeholder");
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("loading" in $$new_props)
      $$invalidate(8, loading = $$new_props.loading);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1A, loading ? "loading" : false, shape === "circle" ? circleClass$8 : false, shape === "rounded" ? roundedClass$8 : false, $$props.class));
  };
  $$invalidate(3, iconContainerClass2 = twMerge(defaultIconContainerClass$2, size === "xs" ? xsContainerClass$2 : false, size === "sm" ? smContainerClass$2 : false, size === "md" ? mdContainerClass$2 : false, size === "lg" ? lgContainerClass$2 : false, size === "xl" ? xlContainerClass$2 : false));
  $$invalidate(2, iconSize2 = twMerge(size === "xs" ? xsIconSize$2 : false, size === "sm" ? smIconSize$2 : false, size === "md" ? mdIconSize$2 : false, size === "lg" ? lgIconSize$2 : false, size === "xl" ? xlIconSize$2 : false));
  $$props = exclude_internal_props($$props);
  return [
    use,
    finalClass,
    iconSize2,
    iconContainerClass2,
    forwardEvents,
    placeholder,
    $$props,
    $$slots,
    loading,
    $$scope,
    slots
  ];
}
let Placeholder$4 = class Placeholder3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$2a, create_fragment$2c, safe_not_equal, { use: 0, loading: 8 });
  }
};
const get_indicator_slot_changes$4 = (dirty) => ({});
const get_indicator_slot_context$4 = (ctx) => ({});
const get_placeholder_slot_changes$4 = (dirty) => ({});
const get_placeholder_slot_context$4 = (ctx) => ({});
function create_if_block_5$e(ctx) {
  let span1;
  let span0;
  let t2;
  let useActions_action;
  let mounted;
  let dispose;
  let span1_levels = [
    { class: (
      /*finalClass*/
      ctx[8]
    ) },
    exclude(
      /*$$props*/
      ctx[11],
      ["use", "class"]
    )
  ];
  let span_data_1 = {};
  for (let i2 = 0; i2 < span1_levels.length; i2 += 1) {
    span_data_1 = assign$1(span_data_1, span1_levels[i2]);
  }
  return {
    c() {
      span1 = element("span");
      span0 = element("span");
      t2 = text(
        /*initials*/
        ctx[3]
      );
      this.h();
    },
    l(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t2 = claim_text(
        span0_nodes,
        /*initials*/
        ctx[3]
      );
      span0_nodes.forEach(detach);
      span1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "class", "font-bold leading-none text-current");
      toggle_class(
        span0,
        "text-xs",
        /*size*/
        ctx[10] === "xs"
      );
      toggle_class(
        span0,
        "text-sm",
        /*size*/
        ctx[10] === "sm"
      );
      toggle_class(
        span0,
        "text-xl",
        /*size*/
        ctx[10] === "lg"
      );
      toggle_class(
        span0,
        "text-2xl",
        /*size*/
        ctx[10] === "xl"
      );
      set_attributes(span1, span_data_1);
    },
    m(target, anchor) {
      insert_hydration(target, span1, anchor);
      append_hydration(span1, span0);
      append_hydration(span0, t2);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span1,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[9].call(null, span1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*initials*/
      8)
        set_data(
          t2,
          /*initials*/
          ctx2[3]
        );
      set_attributes(span1, span_data_1 = get_spread_update(span1_levels, [
        dirty & /*finalClass*/
        256 && { class: (
          /*finalClass*/
          ctx2[8]
        ) },
        dirty & /*$$props*/
        2048 && exclude(
          /*$$props*/
          ctx2[11],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$M(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$y, create_if_block_2$m, create_if_block_4$g];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*loaded*/
      ctx2[4]
    )
      return 0;
    if (
      /*failed*/
      ctx2[5]
    )
      return 1;
    if (
      /*loading*/
      ctx2[6]
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const indicator_slot_template = (
    /*#slots*/
    ctx[16].indicator
  );
  const indicator_slot = create_slot(
    indicator_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_indicator_slot_context$4
  );
  let span_levels = [
    { class: (
      /*finalContainerClass*/
      ctx[7]
    ) },
    exclude(
      /*$$props*/
      ctx[11],
      ["use", "class", "src"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (if_block)
        if_block.c();
      t2 = space();
      if (indicator_slot)
        indicator_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      t2 = claim_space(span_nodes);
      if (indicator_slot)
        indicator_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(span, null);
      }
      append_hydration(span, t2);
      if (indicator_slot) {
        indicator_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[9].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(span, t2);
        } else {
          if_block = null;
        }
      }
      if (indicator_slot) {
        if (indicator_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            indicator_slot,
            indicator_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              indicator_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_indicator_slot_changes$4
            ),
            get_indicator_slot_context$4
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalContainerClass*/
        128) && { class: (
          /*finalContainerClass*/
          ctx2[7]
        ) },
        dirty & /*$$props*/
        2048 && exclude(
          /*$$props*/
          ctx2[11],
          ["use", "class", "src"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(indicator_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(indicator_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (indicator_slot)
        indicator_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4$g(ctx) {
  let placeholder_1;
  let current;
  placeholder_1 = new Placeholder$4({ props: { loading: true } });
  return {
    c() {
      create_component(placeholder_1.$$.fragment);
    },
    l(nodes) {
      claim_component(placeholder_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(placeholder_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(placeholder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(placeholder_1, detaching);
    }
  };
}
function create_if_block_2$m(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3$l, create_else_block$j];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[12].placeholder
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_1$y(ctx) {
  let img;
  let img_style_value;
  let img_src_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", {
        class: true,
        style: true,
        src: true,
        alt: true
      });
      this.h();
    },
    h() {
      attr(
        img,
        "class",
        /*finalClass*/
        ctx[8]
      );
      attr(img, "style", img_style_value = /*$$props*/
      ctx[11].style);
      if (!src_url_equal(img.src, img_src_value = /*src*/
      ctx[1] || ""))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*alt*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*finalClass*/
      256) {
        attr(
          img,
          "class",
          /*finalClass*/
          ctx2[8]
        );
      }
      if (dirty & /*$$props*/
      2048 && img_style_value !== (img_style_value = /*$$props*/
      ctx2[11].style)) {
        attr(img, "style", img_style_value);
      }
      if (dirty & /*src*/
      2 && !src_url_equal(img.src, img_src_value = /*src*/
      ctx2[1] || "")) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*alt*/
      4) {
        attr(
          img,
          "alt",
          /*alt*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_else_block$j(ctx) {
  let placeholder_1;
  let current;
  placeholder_1 = new Placeholder$4({});
  return {
    c() {
      create_component(placeholder_1.$$.fragment);
    },
    l(nodes) {
      claim_component(placeholder_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(placeholder_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(placeholder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(placeholder_1, detaching);
    }
  };
}
function create_if_block_3$l(ctx) {
  let current;
  const placeholder_slot_template = (
    /*#slots*/
    ctx[16].placeholder
  );
  const placeholder_slot = create_slot(
    placeholder_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_placeholder_slot_context$4
  );
  return {
    c() {
      if (placeholder_slot)
        placeholder_slot.c();
    },
    l(nodes) {
      if (placeholder_slot)
        placeholder_slot.l(nodes);
    },
    m(target, anchor) {
      if (placeholder_slot) {
        placeholder_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (placeholder_slot) {
        if (placeholder_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            placeholder_slot,
            placeholder_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              placeholder_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_placeholder_slot_changes$4
            ),
            get_placeholder_slot_context$4
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(placeholder_slot, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_slot, local);
      current = false;
    },
    d(detaching) {
      if (placeholder_slot)
        placeholder_slot.d(detaching);
    }
  };
}
function create_fragment$2b(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$M, create_if_block_5$e];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*src*/
      ctx2[1]
    )
      return 0;
    if (
      /*initials*/
      ctx2[3]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
const srcClass$3 = "inline-block absolute";
const srcContainerClass$3 = "inline-block relative align-middle flex items-center justify-center";
const initialClass$2 = "inline-flex items-center justify-center align-middle bg-default text-default-content flex items-center justify-center";
const xsClass$2 = "h-6 w-6 p-0.5";
const smClass$2 = "h-8 w-8 p-0.5";
const mdClass$2 = "h-10 w-10 p-0.5";
const lgClass$2 = "h-12 w-12 p-1";
const xlClass$2 = "h-16 w-16 p-1";
const circleClass$7 = "rounded-full";
const roundedClass$7 = "rounded-md";
function instance$29($$self, $$props, $$invalidate) {
  let finalClass;
  let finalContainerClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { src } = $$props;
  let { alt = "user-avatar" } = $$props;
  let { shape = "circle" } = $$props;
  let { initials = void 0 } = $$props;
  let { placeholder = true } = $$props;
  let loaded = false;
  let failed = false;
  let loading = true;
  const size = getContext("chip-size");
  setContext("chip-avatar-src", src);
  setContext("chip-avatar-alt", alt);
  setContext("chip-avatar-shape", shape);
  setContext("chip-avatar-size", size);
  setContext("chip-avatar-placeholder", placeholder);
  onMount(() => {
    if (src) {
      const image = new Image();
      image.src = src;
      $$invalidate(6, loading = true);
      image.onload = () => {
        $$invalidate(6, loading = false);
        $$invalidate(4, loaded = true);
      };
      image.onerror = () => {
        $$invalidate(6, loading = false);
        $$invalidate(5, failed = true);
      };
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(11, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("src" in $$new_props)
      $$invalidate(1, src = $$new_props.src);
    if ("alt" in $$new_props)
      $$invalidate(2, alt = $$new_props.alt);
    if ("shape" in $$new_props)
      $$invalidate(13, shape = $$new_props.shape);
    if ("initials" in $$new_props)
      $$invalidate(3, initials = $$new_props.initials);
    if ("placeholder" in $$new_props)
      $$invalidate(14, placeholder = $$new_props.placeholder);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(8, finalClass = twMerge(src && !initials ? srcClass$3 : false, initials && !src ? initialClass$2 : false, size === "xs" ? xsClass$2 : false, size === "sm" ? smClass$2 : false, size === "md" ? mdClass$2 : false, size === "lg" ? lgClass$2 : false, size === "xl" ? xlClass$2 : false, shape === "circle" ? circleClass$7 : false, shape === "rounded" ? roundedClass$7 : false, $$props.class));
    $$invalidate(7, finalContainerClass = twMerge(src && !initials ? srcContainerClass$3 : false, size === "xs" ? xsClass$2 : false, size === "sm" ? smClass$2 : false, size === "md" ? mdClass$2 : false, size === "lg" ? lgClass$2 : false, size === "xl" ? xlClass$2 : false, shape === "circle" ? circleClass$7 : false, shape === "rounded" ? roundedClass$7 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    src,
    alt,
    initials,
    loaded,
    failed,
    loading,
    finalContainerClass,
    finalClass,
    forwardEvents,
    size,
    $$props,
    $$slots,
    shape,
    placeholder,
    $$scope,
    slots
  ];
}
let Avatar$4 = class Avatar3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$29, create_fragment$2b, safe_not_equal, {
      use: 0,
      src: 1,
      alt: 2,
      shape: 13,
      initials: 3,
      placeholder: 14
    });
  }
};
function create_fragment$2a(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1z = "pl-2";
function instance$28($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1z, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Label$8 = class Label4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$28, create_fragment$2a, safe_not_equal, { use: 0 });
  }
};
function create_fragment$29(ctx) {
  let button;
  let span;
  let textContent = "Remove option";
  let t1;
  let icon;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$7({ props: { data: close } });
  let button_levels = [
    { "aria-label": "close" },
    { type: "button" },
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let button_data = {};
  for (let i2 = 0; i2 < button_levels.length; i2 += 1) {
    button_data = assign$1(button_data, button_levels[i2]);
  }
  return {
    c() {
      button = element("button");
      span = element("span");
      span.textContent = textContent;
      t1 = space();
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", {
        "aria-label": true,
        type: true,
        class: true
      });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-1tw6350")
        span.textContent = textContent;
      t1 = claim_space(button_nodes);
      claim_component(icon.$$.fragment, button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "sr-only");
      set_attributes(button, button_data);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, span);
      append_hydration(button, t1);
      mount_component(icon, button, null);
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            button,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, button)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { "aria-label": "close" },
        { type: "button" },
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(icon);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1y = "flex-shrink-0 ml-2 h-8 w-8 rounded-full inline-flex items-center justify-center outline-none focus:outline-none hover:bg-default text-default-content hover:bg-background hover:bg-opacity-50 hover:text-content";
const defaultType$1 = "text-default-content";
const infoType = "text-info-content";
const successType = "text-success-content";
const warnType = "text-warn-content";
const errorType = "text-error-content";
function instance$27($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const type = getContext("chip-type");
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1y, type === "default" ? defaultType$1 : false, type === "info" ? infoType : false, type === "success" ? successType : false, type === "warn" ? warnType : false, type === "error" ? errorType : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props];
}
class Close2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$27, create_fragment$29, safe_not_equal, { use: 0 });
  }
}
const Chip2 = Chip$1;
Chip2.Avatar = Avatar$4;
Chip2.Label = Label$8;
Chip2.Close = Close2;
const Currency_svelte_svelte_type_style_lang = "";
const get_trailing_slot_changes$2 = (dirty) => ({});
const get_trailing_slot_context$2 = (ctx) => ({});
const get_leading_slot_changes$6 = (dirty) => ({});
const get_leading_slot_context$6 = (ctx) => ({});
const get_label_slot_changes$8 = (dirty) => ({});
const get_label_slot_context$8 = (ctx) => ({});
function create_if_block_4$f(ctx) {
  let span;
  let current;
  const leading_slot_template = (
    /*#slots*/
    ctx[15].leading
  );
  const leading_slot = create_slot(
    leading_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_leading_slot_context$6
  );
  return {
    c() {
      span = element("span");
      if (leading_slot)
        leading_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (leading_slot)
        leading_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (leading_slot) {
        leading_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (leading_slot) {
        if (leading_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            leading_slot,
            leading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              leading_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_leading_slot_changes$6
            ),
            get_leading_slot_context$6
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leading_slot, local);
      current = true;
    },
    o(local) {
      transition_out(leading_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (leading_slot)
        leading_slot.d(detaching);
    }
  };
}
function create_if_block_3$k(ctx) {
  let button;
  let span;
  let icon;
  let span_transition;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$7({ props: { data: close } });
  return {
    c() {
      button = element("button");
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { "aria-label": true, class: true });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "items-center flex");
      attr(button, "aria-label", "clear");
      attr(button, "class", "absolute inset-y-0 group-focus-within:flex active:flex items-center");
      toggle_class(
        button,
        "right-10",
        /*$$slots*/
        ctx[13].trailing || /*error*/
        ctx[2]
      );
      toggle_class(button, "right-3", !/*$$slots*/
      ctx[13].trailing && !/*error*/
      ctx[2]);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, span);
      mount_component(icon, span, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handleClear*/
          ctx[11]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*$$slots, error*/
      8196) {
        toggle_class(
          button,
          "right-10",
          /*$$slots*/
          ctx2[13].trailing || /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$$slots, error*/
      8196) {
        toggle_class(button, "right-3", !/*$$slots*/
        ctx2[13].trailing && !/*error*/
        ctx2[2]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!span_transition)
            span_transition = create_bidirectional_transition(span, scale, {}, true);
          span_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      if (local) {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, scale, {}, false);
        span_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(icon);
      if (detaching && span_transition)
        span_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$l(ctx) {
  let span;
  let icon;
  let current;
  icon = new Icon$7({ props: { data: error } });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block_1$x(ctx) {
  let span;
  let current;
  const trailing_slot_template = (
    /*#slots*/
    ctx[15].trailing
  );
  const trailing_slot = create_slot(
    trailing_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_trailing_slot_context$2
  );
  return {
    c() {
      span = element("span");
      if (trailing_slot)
        trailing_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (trailing_slot)
        trailing_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (trailing_slot) {
        trailing_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (trailing_slot) {
        if (trailing_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            trailing_slot,
            trailing_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              trailing_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_trailing_slot_changes$2
            ),
            get_trailing_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(trailing_slot, local);
      current = true;
    },
    o(local) {
      transition_out(trailing_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (trailing_slot)
        trailing_slot.d(detaching);
    }
  };
}
function create_if_block$L(ctx) {
  let p;
  let t2;
  let p_id_value;
  let p_transition;
  let current;
  return {
    c() {
      p = element("p");
      t2 = text(
        /*error*/
        ctx[2]
      );
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true, id: true });
      var p_nodes = children(p);
      t2 = claim_text(
        p_nodes,
        /*error*/
        ctx[2]
      );
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(p, "class", "mt-2 text-sm text-danger");
      attr(p, "id", p_id_value = /*name*/
      ctx[1] + "-error");
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      append_hydration(p, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*error*/
      4)
        set_data(
          t2,
          /*error*/
          ctx2[2]
        );
      if (!current || dirty & /*name*/
      2 && p_id_value !== (p_id_value = /*name*/
      ctx2[1] + "-error")) {
        attr(p, "id", p_id_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!p_transition)
            p_transition = create_bidirectional_transition(p, slide, {}, true);
          p_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!p_transition)
          p_transition = create_bidirectional_transition(p, slide, {}, false);
        p_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (detaching && p_transition)
        p_transition.end();
    }
  };
}
function create_fragment$28(ctx) {
  let div1;
  let t0;
  let div0;
  let input_1;
  let t1;
  let t2;
  let t3;
  let current_block_type_index;
  let if_block2;
  let t4;
  let div1_class_value;
  let div1_style_value;
  let current;
  let mounted;
  let dispose;
  const label_slot_template = (
    /*#slots*/
    ctx[15].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_label_slot_context$8
  );
  let if_block0 = (
    /*$$slots*/
    ctx[13].leading && create_if_block_4$f(ctx)
  );
  let if_block1 = (
    /*allowClear*/
    ctx[8] && /*value*/
    ctx[0] && create_if_block_3$k(ctx)
  );
  const if_block_creators = [create_if_block_1$x, create_if_block_2$l];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[13].trailing && !/*error*/
      ctx2[2]
    )
      return 0;
    if (
      /*error*/
      ctx2[2]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block3 = (
    /*error*/
    ctx[2] && create_if_block$L(ctx)
  );
  return {
    c() {
      div1 = element("div");
      if (label_slot)
        label_slot.c();
      t0 = space();
      div0 = element("div");
      input_1 = element("input");
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      if (label_slot)
        label_slot.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input_1 = claim_element(div0_nodes, "INPUT", {
        type: true,
        inputmode: true,
        pattern: true,
        autocapitalize: true,
        autocomplete: true,
        name: true,
        id: true,
        class: true,
        placeholder: true,
        step: true
      });
      t1 = claim_space(div0_nodes);
      if (if_block0)
        if_block0.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      t3 = claim_space(div0_nodes);
      if (if_block2)
        if_block2.l(div0_nodes);
      div0_nodes.forEach(detach);
      t4 = claim_space(div1_nodes);
      if (if_block3)
        if_block3.l(div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(input_1, "type", "number");
      attr(input_1, "inputmode", "numeric");
      attr(input_1, "pattern", "\\d*");
      attr(
        input_1,
        "autocapitalize",
        /*autocapitalize*/
        ctx[5]
      );
      attr(
        input_1,
        "autocomplete",
        /*autocomplete*/
        ctx[4]
      );
      attr(
        input_1,
        "name",
        /*name*/
        ctx[1]
      );
      input_1.readOnly = /*readonly*/
      ctx[7];
      input_1.disabled = /*disabled*/
      ctx[6];
      attr(
        input_1,
        "id",
        /*name*/
        ctx[1]
      );
      attr(input_1, "class", "block w-full px-3 h-[2.5rem] border outline-none focus:outline-none sm:text-sm rounded-md bg-surface placeholder-secondary-content placeholder-opacity-80 svelte-6isbck");
      attr(
        input_1,
        "placeholder",
        /*placeholder*/
        ctx[3]
      );
      attr(input_1, "step", "0.01");
      toggle_class(
        input_1,
        "border-danger",
        /*error*/
        ctx[2]
      );
      toggle_class(
        input_1,
        "text-danger",
        /*error*/
        ctx[2]
      );
      toggle_class(
        input_1,
        "placeholder-danger",
        /*error*/
        ctx[2]
      );
      toggle_class(
        input_1,
        "focus:border-red-500",
        /*error*/
        ctx[2]
      );
      toggle_class(input_1, "focus:border-primary", !/*error*/
      ctx[2]);
      toggle_class(input_1, "border-border", !/*error*/
      ctx[2]);
      toggle_class(
        input_1,
        "pl-10",
        /*$$slots*/
        ctx[13].leading
      );
      toggle_class(
        input_1,
        "pr-10",
        /*$$slots*/
        ctx[13].trailing || /*error*/
        ctx[2] || /*allowClear*/
        ctx[8]
      );
      toggle_class(
        input_1,
        "bg-default",
        /*disabled*/
        ctx[6]
      );
      attr(div0, "class", "mt-1 relative rounded-md h-[2.5rem]");
      toggle_class(
        div0,
        "text-danger",
        /*error*/
        ctx[2]
      );
      toggle_class(
        div0,
        "opacity-75",
        /*disabled*/
        ctx[6]
      );
      attr(div1, "class", div1_class_value = /*$$props*/
      ctx[12].class);
      attr(div1, "style", div1_style_value = /*$$props*/
      ctx[12].style);
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      if (label_slot) {
        label_slot.m(div1, null);
      }
      append_hydration(div1, t0);
      append_hydration(div1, div0);
      append_hydration(div0, input_1);
      ctx[16](input_1);
      set_input_value(
        input_1,
        /*value*/
        ctx[0]
      );
      append_hydration(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration(div0, t2);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration(div0, t3);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div0, null);
      }
      append_hydration(div1, t4);
      if (if_block3)
        if_block3.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input_1,
            "input",
            /*input_1_input_handler*/
            ctx[17]
          ),
          listen(
            input_1,
            "input",
            /*setTwoNumberDecimal*/
            ctx[10]
          ),
          listen(input_1, "keypress", onlyNumeric$1)
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_label_slot_changes$8
            ),
            get_label_slot_context$8
          );
        }
      }
      if (!current || dirty & /*autocapitalize*/
      32) {
        attr(
          input_1,
          "autocapitalize",
          /*autocapitalize*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*autocomplete*/
      16) {
        attr(
          input_1,
          "autocomplete",
          /*autocomplete*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*name*/
      2) {
        attr(
          input_1,
          "name",
          /*name*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*readonly*/
      128) {
        input_1.readOnly = /*readonly*/
        ctx2[7];
      }
      if (!current || dirty & /*disabled*/
      64) {
        input_1.disabled = /*disabled*/
        ctx2[6];
      }
      if (!current || dirty & /*name*/
      2) {
        attr(
          input_1,
          "id",
          /*name*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*placeholder*/
      8) {
        attr(
          input_1,
          "placeholder",
          /*placeholder*/
          ctx2[3]
        );
      }
      if (dirty & /*value*/
      1 && to_number(input_1.value) !== /*value*/
      ctx2[0]) {
        set_input_value(
          input_1,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          input_1,
          "border-danger",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          input_1,
          "text-danger",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          input_1,
          "placeholder-danger",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          input_1,
          "focus:border-red-500",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(input_1, "focus:border-primary", !/*error*/
        ctx2[2]);
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(input_1, "border-border", !/*error*/
        ctx2[2]);
      }
      if (!current || dirty & /*$$slots*/
      8192) {
        toggle_class(
          input_1,
          "pl-10",
          /*$$slots*/
          ctx2[13].leading
        );
      }
      if (!current || dirty & /*$$slots, error, allowClear*/
      8452) {
        toggle_class(
          input_1,
          "pr-10",
          /*$$slots*/
          ctx2[13].trailing || /*error*/
          ctx2[2] || /*allowClear*/
          ctx2[8]
        );
      }
      if (!current || dirty & /*disabled*/
      64) {
        toggle_class(
          input_1,
          "bg-default",
          /*disabled*/
          ctx2[6]
        );
      }
      if (
        /*$$slots*/
        ctx2[13].leading
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          8192) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$f(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*allowClear*/
        ctx2[8] && /*value*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*allowClear, value*/
          257) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3$k(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block2) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block2 = if_blocks[current_block_type_index];
          if (!if_block2) {
            if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block2.c();
          } else {
            if_block2.p(ctx2, dirty);
          }
          transition_in(if_block2, 1);
          if_block2.m(div0, null);
        } else {
          if_block2 = null;
        }
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          div0,
          "text-danger",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*disabled*/
      64) {
        toggle_class(
          div0,
          "opacity-75",
          /*disabled*/
          ctx2[6]
        );
      }
      if (
        /*error*/
        ctx2[2]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*error*/
          4) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$L(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div1, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*$$props*/
      4096 && div1_class_value !== (div1_class_value = /*$$props*/
      ctx2[12].class)) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*$$props*/
      4096 && div1_style_value !== (div1_style_value = /*$$props*/
      ctx2[12].style)) {
        attr(div1, "style", div1_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (label_slot)
        label_slot.d(detaching);
      ctx[16](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block3)
        if_block3.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function onlyNumeric$1(e2) {
  if (!e2.key.match(/^[0-9]+$/))
    e2.preventDefault();
}
function instance$26($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { name } = $$props;
  let { error: error2 = void 0 } = $$props;
  let { placeholder = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { autocomplete = void 0 } = $$props;
  let { autocapitalize = "off" } = $$props;
  let { disabled = false } = $$props;
  let { readonly = false } = $$props;
  let { allowClear = false } = $$props;
  let input;
  let currentError = writable(error2);
  function setTwoNumberDecimal(e2) {
    const el = e2.target;
    if (el.value) {
      let temporaryStringValue = el.value.replace(".", "");
      temporaryStringValue = temporaryStringValue.replace(/\D/g, "");
      if (temporaryStringValue && temporaryStringValue.length > 0) {
        const temporaryValue = +temporaryStringValue;
        const temporaryShiftedValue = temporaryValue / 100;
        $$invalidate(0, value = parseFloat(temporaryShiftedValue.toString()).toFixed(2));
      }
    }
  }
  function handleClear() {
    input.focus();
    $$invalidate(9, input.value = "", input);
    $$invalidate(0, value = void 0);
  }
  setContext("currency-name", name);
  setContext("currency-error", currentError);
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(9, input);
    });
  }
  function input_1_input_handler() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(12, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("error" in $$new_props)
      $$invalidate(2, error2 = $$new_props.error);
    if ("placeholder" in $$new_props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("autocomplete" in $$new_props)
      $$invalidate(4, autocomplete = $$new_props.autocomplete);
    if ("autocapitalize" in $$new_props)
      $$invalidate(5, autocapitalize = $$new_props.autocapitalize);
    if ("disabled" in $$new_props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("readonly" in $$new_props)
      $$invalidate(7, readonly = $$new_props.readonly);
    if ("allowClear" in $$new_props)
      $$invalidate(8, allowClear = $$new_props.allowClear);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*error*/
    4) {
      currentError.set(error2);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    name,
    error2,
    placeholder,
    autocomplete,
    autocapitalize,
    disabled,
    readonly,
    allowClear,
    input,
    setTwoNumberDecimal,
    handleClear,
    $$props,
    $$slots,
    $$scope,
    slots,
    input_1_binding,
    input_1_input_handler
  ];
}
let Currency$1 = class Currency extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$26, create_fragment$28, safe_not_equal, {
      name: 1,
      error: 2,
      placeholder: 3,
      value: 0,
      autocomplete: 4,
      autocapitalize: 5,
      disabled: 6,
      readonly: 7,
      allowClear: 8
    });
  }
};
function create_fragment$27(ctx) {
  let label;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let label_levels = [
    { for: (
      /*name*/
      ctx[3]
    ) },
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[5],
      ["use", "class"]
    )
  ];
  let label_data = {};
  for (let i2 = 0; i2 < label_levels.length; i2 += 1) {
    label_data = assign$1(label_data, label_levels[i2]);
  }
  return {
    c() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      label = claim_element(nodes, "LABEL", { for: true, class: true });
      var label_nodes = children(label);
      if (default_slot)
        default_slot.l(label_nodes);
      label_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(label, label_data);
    },
    m(target, anchor) {
      insert_hydration(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            label,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, label)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        { for: (
          /*name*/
          ctx2[3]
        ) },
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        32 && exclude(
          /*$$props*/
          ctx2[5],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1x = "block text-sm font-medium text-secondary-content";
const errorClass$4 = "text-danger";
function instance$25($$self, $$props, $$invalidate) {
  let finalClass;
  let $error;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const name = getContext("currency-name");
  const error2 = getContext("currency-error");
  component_subscribe($$self, error2, (value) => $$invalidate(6, $error = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1x, $error && $error.length > 0 ? errorClass$4 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, name, error2, $$props, $error, $$scope, slots];
}
let Label$7 = class Label5 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$25, create_fragment$27, safe_not_equal, { use: 0 });
  }
};
const Currency2 = Currency$1;
Currency2.Label = Label$7;
Currency2.Leading = Icon$7;
Currency2.Trailing = Icon$7;
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e2 = 6e4, n = 36e5, r = "millisecond", i2 = "second", s3 = "minute", u2 = "hour", a3 = "day", o = "week", c2 = "month", f = "quarter", h4 = "year", d3 = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y3 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M3 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e3 = ["th", "st", "nd", "rd"], n2 = t3 % 100;
      return "[" + t3 + (e3[(n2 - 20) % 10] || e3[n2] || e3[0]) + "]";
    } }, m3 = function(t3, e3, n2) {
      var r2 = String(t3);
      return !r2 || r2.length >= e3 ? t3 : "" + Array(e3 + 1 - r2.length).join(n2) + t3;
    }, v = { s: m3, z: function(t3) {
      var e3 = -t3.utcOffset(), n2 = Math.abs(e3), r2 = Math.floor(n2 / 60), i3 = n2 % 60;
      return (e3 <= 0 ? "+" : "-") + m3(r2, 2, "0") + ":" + m3(i3, 2, "0");
    }, m: function t3(e3, n2) {
      if (e3.date() < n2.date())
        return -t3(n2, e3);
      var r2 = 12 * (n2.year() - e3.year()) + (n2.month() - e3.month()), i3 = e3.clone().add(r2, c2), s4 = n2 - i3 < 0, u3 = e3.clone().add(r2 + (s4 ? -1 : 1), c2);
      return +(-(r2 + (n2 - i3) / (s4 ? i3 - u3 : u3 - i3)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: c2, y: h4, w: o, d: a3, D: d3, h: u2, m: s3, s: i2, ms: r, Q: f }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g = "en", D2 = {};
    D2[g] = M3;
    var p = function(t3) {
      return t3 instanceof b2;
    }, S3 = function t3(e3, n2, r2) {
      var i3;
      if (!e3)
        return g;
      if ("string" == typeof e3) {
        var s4 = e3.toLowerCase();
        D2[s4] && (i3 = s4), n2 && (D2[s4] = n2, i3 = s4);
        var u3 = e3.split("-");
        if (!i3 && u3.length > 1)
          return t3(u3[0]);
      } else {
        var a4 = e3.name;
        D2[a4] = e3, i3 = a4;
      }
      return !r2 && i3 && (g = i3), i3 || !r2 && g;
    }, w2 = function(t3, e3) {
      if (p(t3))
        return t3.clone();
      var n2 = "object" == typeof e3 ? e3 : {};
      return n2.date = t3, n2.args = arguments, new b2(n2);
    }, O2 = v;
    O2.l = S3, O2.i = p, O2.w = function(t3, e3) {
      return w2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var b2 = function() {
      function M4(t3) {
        this.$L = S3(t3.locale, null, true), this.parse(t3);
      }
      var m4 = M4.prototype;
      return m4.parse = function(t3) {
        this.$d = function(t4) {
          var e3 = t4.date, n2 = t4.utc;
          if (null === e3)
            return /* @__PURE__ */ new Date(NaN);
          if (O2.u(e3))
            return /* @__PURE__ */ new Date();
          if (e3 instanceof Date)
            return new Date(e3);
          if ("string" == typeof e3 && !/Z$/i.test(e3)) {
            var r2 = e3.match($);
            if (r2) {
              var i3 = r2[2] - 1 || 0, s4 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i3, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s4)) : new Date(r2[1], i3, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s4);
            }
          }
          return new Date(e3);
        }(t3), this.$x = t3.x || {}, this.init();
      }, m4.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m4.$utils = function() {
        return O2;
      }, m4.isValid = function() {
        return !(this.$d.toString() === l);
      }, m4.isSame = function(t3, e3) {
        var n2 = w2(t3);
        return this.startOf(e3) <= n2 && n2 <= this.endOf(e3);
      }, m4.isAfter = function(t3, e3) {
        return w2(t3) < this.startOf(e3);
      }, m4.isBefore = function(t3, e3) {
        return this.endOf(e3) < w2(t3);
      }, m4.$g = function(t3, e3, n2) {
        return O2.u(t3) ? this[e3] : this.set(n2, t3);
      }, m4.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m4.valueOf = function() {
        return this.$d.getTime();
      }, m4.startOf = function(t3, e3) {
        var n2 = this, r2 = !!O2.u(e3) || e3, f2 = O2.p(t3), l2 = function(t4, e4) {
          var i3 = O2.w(n2.$u ? Date.UTC(n2.$y, e4, t4) : new Date(n2.$y, e4, t4), n2);
          return r2 ? i3 : i3.endOf(a3);
        }, $2 = function(t4, e4) {
          return O2.w(n2.toDate()[t4].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n2);
        }, y4 = this.$W, M5 = this.$M, m5 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (f2) {
          case h4:
            return r2 ? l2(1, 0) : l2(31, 11);
          case c2:
            return r2 ? l2(1, M5) : l2(0, M5 + 1);
          case o:
            var g2 = this.$locale().weekStart || 0, D3 = (y4 < g2 ? y4 + 7 : y4) - g2;
            return l2(r2 ? m5 - D3 : m5 + (6 - D3), M5);
          case a3:
          case d3:
            return $2(v2 + "Hours", 0);
          case u2:
            return $2(v2 + "Minutes", 1);
          case s3:
            return $2(v2 + "Seconds", 2);
          case i2:
            return $2(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m4.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m4.$set = function(t3, e3) {
        var n2, o2 = O2.p(t3), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a3] = f2 + "Date", n2[d3] = f2 + "Date", n2[c2] = f2 + "Month", n2[h4] = f2 + "FullYear", n2[u2] = f2 + "Hours", n2[s3] = f2 + "Minutes", n2[i2] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a3 ? this.$D + (e3 - this.$W) : e3;
        if (o2 === c2 || o2 === h4) {
          var y4 = this.clone().set(d3, 1);
          y4.$d[l2]($2), y4.init(), this.$d = y4.set(d3, Math.min(this.$D, y4.daysInMonth())).$d;
        } else
          l2 && this.$d[l2]($2);
        return this.init(), this;
      }, m4.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m4.get = function(t3) {
        return this[O2.p(t3)]();
      }, m4.add = function(r2, f2) {
        var d4, l2 = this;
        r2 = Number(r2);
        var $2 = O2.p(f2), y4 = function(t3) {
          var e3 = w2(l2);
          return O2.w(e3.date(e3.date() + Math.round(t3 * r2)), l2);
        };
        if ($2 === c2)
          return this.set(c2, this.$M + r2);
        if ($2 === h4)
          return this.set(h4, this.$y + r2);
        if ($2 === a3)
          return y4(1);
        if ($2 === o)
          return y4(7);
        var M5 = (d4 = {}, d4[s3] = e2, d4[u2] = n, d4[i2] = t2, d4)[$2] || 1, m5 = this.$d.getTime() + r2 * M5;
        return O2.w(m5, this);
      }, m4.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m4.format = function(t3) {
        var e3 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || l;
        var r2 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O2.z(this), s4 = this.$H, u3 = this.$m, a4 = this.$M, o2 = n2.weekdays, c3 = n2.months, f2 = n2.meridiem, h5 = function(t4, n3, i4, s5) {
          return t4 && (t4[n3] || t4(e3, r2)) || i4[n3].slice(0, s5);
        }, d4 = function(t4) {
          return O2.s(s4 % 12 || 12, t4, "0");
        }, $2 = f2 || function(t4, e4, n3) {
          var r3 = t4 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        };
        return r2.replace(y3, function(t4, r3) {
          return r3 || function(t5) {
            switch (t5) {
              case "YY":
                return String(e3.$y).slice(-2);
              case "YYYY":
                return O2.s(e3.$y, 4, "0");
              case "M":
                return a4 + 1;
              case "MM":
                return O2.s(a4 + 1, 2, "0");
              case "MMM":
                return h5(n2.monthsShort, a4, c3, 3);
              case "MMMM":
                return h5(c3, a4);
              case "D":
                return e3.$D;
              case "DD":
                return O2.s(e3.$D, 2, "0");
              case "d":
                return String(e3.$W);
              case "dd":
                return h5(n2.weekdaysMin, e3.$W, o2, 2);
              case "ddd":
                return h5(n2.weekdaysShort, e3.$W, o2, 3);
              case "dddd":
                return o2[e3.$W];
              case "H":
                return String(s4);
              case "HH":
                return O2.s(s4, 2, "0");
              case "h":
                return d4(1);
              case "hh":
                return d4(2);
              case "a":
                return $2(s4, u3, true);
              case "A":
                return $2(s4, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return O2.s(u3, 2, "0");
              case "s":
                return String(e3.$s);
              case "ss":
                return O2.s(e3.$s, 2, "0");
              case "SSS":
                return O2.s(e3.$ms, 3, "0");
              case "Z":
                return i3;
            }
            return null;
          }(t4) || i3.replace(":", "");
        });
      }, m4.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m4.diff = function(r2, d4, l2) {
        var $2, y4 = this, M5 = O2.p(d4), m5 = w2(r2), v2 = (m5.utcOffset() - this.utcOffset()) * e2, g2 = this - m5, D3 = function() {
          return O2.m(y4, m5);
        };
        switch (M5) {
          case h4:
            $2 = D3() / 12;
            break;
          case c2:
            $2 = D3();
            break;
          case f:
            $2 = D3() / 3;
            break;
          case o:
            $2 = (g2 - v2) / 6048e5;
            break;
          case a3:
            $2 = (g2 - v2) / 864e5;
            break;
          case u2:
            $2 = g2 / n;
            break;
          case s3:
            $2 = g2 / e2;
            break;
          case i2:
            $2 = g2 / t2;
            break;
          default:
            $2 = g2;
        }
        return l2 ? $2 : O2.a($2);
      }, m4.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m4.$locale = function() {
        return D2[this.$L];
      }, m4.locale = function(t3, e3) {
        if (!t3)
          return this.$L;
        var n2 = this.clone(), r2 = S3(t3, e3, true);
        return r2 && (n2.$L = r2), n2;
      }, m4.clone = function() {
        return O2.w(this.$d, this);
      }, m4.toDate = function() {
        return new Date(this.valueOf());
      }, m4.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m4.toISOString = function() {
        return this.$d.toISOString();
      }, m4.toString = function() {
        return this.$d.toUTCString();
      }, M4;
    }(), _ = b2.prototype;
    return w2.prototype = _, [["$ms", r], ["$s", i2], ["$m", s3], ["$H", u2], ["$W", a3], ["$M", c2], ["$y", h4], ["$D", d3]].forEach(function(t3) {
      _[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), w2.extend = function(t3, e3) {
      return t3.$i || (t3(e3, b2, w2), t3.$i = true), w2;
    }, w2.locale = S3, w2.isDayjs = p, w2.unix = function(t3) {
      return w2(1e3 * t3);
    }, w2.en = D2[g], w2.Ls = D2, w2.p = {}, w2;
  });
})(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
function getMonthDays(date) {
  const monthLength = date.daysInMonth();
  const days = [];
  for (let i2 = 0; i2 < monthLength; i2++) {
    days.push(date.add(i2, "days"));
  }
  return days;
}
function getCalendarDays(value, weekStartsOn) {
  const firstWeekday = dayjs(value).startOf("month");
  let days = [];
  const daysBefore = firstWeekday.subtract(weekStartsOn, "days").add(7, "days").day() % 7;
  if (daysBefore > 0) {
    days = getMonthDays(value.subtract(1, "month").startOf("month")).slice(-daysBefore);
  }
  days = days.concat(getMonthDays(value.startOf("month")));
  const daysAfter = 35 - days.length;
  days = days.concat(getMonthDays(value.add(1, "month").startOf("month")).slice(0, daysAfter));
  return days;
}
function getLocaleDefaults() {
  return {
    weekdays: [
      dayjs().day(0).format("dd"),
      dayjs().day(1).format("dd"),
      dayjs().day(2).format("dd"),
      dayjs().day(3).format("dd"),
      dayjs().day(4).format("dd"),
      dayjs().day(5).format("dd"),
      dayjs().day(6).format("dd")
    ],
    months: [
      dayjs().month(0).format("MMMM"),
      dayjs().month(1).format("MMMM"),
      dayjs().month(2).format("MMMM"),
      dayjs().month(3).format("MMMM"),
      dayjs().month(4).format("MMMM"),
      dayjs().month(5).format("MMMM"),
      dayjs().month(6).format("MMMM"),
      dayjs().month(7).format("MMMM"),
      dayjs().month(8).format("MMMM"),
      dayjs().month(9).format("MMMM"),
      dayjs().month(10).format("MMMM"),
      dayjs().month(11).format("MMMM")
    ],
    weekStartsOn: 0
  };
}
function getInnerLocale(locale2 = {}) {
  const innerLocale = getLocaleDefaults();
  if (typeof locale2.weekStartsOn === "number") {
    innerLocale.weekStartsOn = locale2.weekStartsOn;
  }
  if (locale2.months)
    innerLocale.months = locale2.months;
  if (locale2.weekdays)
    innerLocale.weekdays = locale2.weekdays;
  return innerLocale;
}
function get_each_context_3$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[47] = list[i2];
  return child_ctx;
}
function get_each_context_5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[50] = list[i2];
  return child_ctx;
}
function get_each_context_4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[50] = list[i2];
  return child_ctx;
}
function get_each_context$c(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[47] = list[i2];
  return child_ctx;
}
function get_each_context_2$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[50] = list[i2];
  return child_ctx;
}
function get_each_context_1$5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[50] = list[i2];
  return child_ctx;
}
function create_else_block_1$5(ctx) {
  let show_if_1;
  let current_block_type_index;
  let if_block0;
  let t0;
  let div2;
  let t1;
  let show_if = (
    /*format*/
    ctx[4].includes("h")
  );
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_4$e, create_else_block_2$2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (dirty[0] & /*format*/
    16)
      show_if_1 = null;
    if (show_if_1 == null)
      show_if_1 = !!/*format*/
      ctx2[4].includes("H");
    if (show_if_1)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1]);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let each_value_3 = ensure_array_like(
    /*minutesArray*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    each_blocks[i2] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block1 = show_if && create_if_block_3$j(ctx);
  return {
    c() {
      if_block0.c();
      t0 = space();
      div2 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      this.h();
    },
    l(nodes) {
      if_block0.l(nodes);
      t0 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(div_nodes);
      }
      div_nodes.forEach(detach);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
      this.h();
    },
    h() {
      attr(div2, "class", "overflow-auto w-full h-full snap-y snap-mandatory snap-always p-1 space-y-1");
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, div2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div2, null);
        }
      }
      ctx[40](div2);
      insert_hydration(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(t0.parentNode, t0);
      }
      if (dirty[0] & /*minutesArray, minuteSelected, handleSelectMinute*/
      262178) {
        each_value_3 = ensure_array_like(
          /*minutesArray*/
          ctx2[5]
        );
        let i2;
        for (i2 = 0; i2 < each_value_3.length; i2 += 1) {
          const child_ctx = get_each_context_3$1(ctx2, each_value_3, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_3$1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div2, null);
          }
        }
        group_outros();
        for (i2 = each_value_3.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (dirty[0] & /*format*/
      16)
        show_if = /*format*/
        ctx2[4].includes("h");
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*format*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3$j(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div2);
        detach(t1);
        detach(if_block1_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
      destroy_each(each_blocks, detaching);
      ctx[40](null);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function create_if_block$K(ctx) {
  let show_if_1;
  let current_block_type_index;
  let if_block0;
  let t0;
  let dropdown;
  let updating_visible;
  let t1;
  let show_if = (
    /*format*/
    ctx[4].includes("h")
  );
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_2$k, create_else_block$i];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty[0] & /*format*/
    16)
      show_if_1 = null;
    if (show_if_1 == null)
      show_if_1 = !!/*format*/
      ctx2[4].includes("H");
    if (show_if_1)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  function dropdown_visible_binding_2(value) {
    ctx[31](value);
  }
  let dropdown_props = {
    class: "w-full",
    $$slots: {
      items: [create_items_slot_1],
      trigger: [create_trigger_slot_1]
    },
    $$scope: { ctx }
  };
  if (
    /*minutesVisible*/
    ctx[10] !== void 0
  ) {
    dropdown_props.visible = /*minutesVisible*/
    ctx[10];
  }
  dropdown = new Dropdown({ props: dropdown_props });
  binding_callbacks.push(() => bind(dropdown, "visible", dropdown_visible_binding_2));
  let if_block1 = show_if && create_if_block_1$w(ctx);
  return {
    c() {
      if_block0.c();
      t0 = space();
      create_component(dropdown.$$.fragment);
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l(nodes) {
      if_block0.l(nodes);
      t0 = claim_space(nodes);
      claim_component(dropdown.$$.fragment, nodes);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, t0, anchor);
      mount_component(dropdown, target, anchor);
      insert_hydration(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block0 = if_blocks[current_block_type_index];
        if (!if_block0) {
          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block0.c();
        } else {
          if_block0.p(ctx2, dirty);
        }
        transition_in(if_block0, 1);
        if_block0.m(t0.parentNode, t0);
      }
      const dropdown_changes = {};
      if (dirty[0] & /*minutesArray, minuteSelected*/
      34 | dirty[1] & /*$$scope*/
      1073741824) {
        dropdown_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_visible && dirty[0] & /*minutesVisible*/
      1024) {
        updating_visible = true;
        dropdown_changes.visible = /*minutesVisible*/
        ctx2[10];
        add_flush_callback(() => updating_visible = false);
      }
      dropdown.$set(dropdown_changes);
      if (dirty[0] & /*format*/
      16)
        show_if = /*format*/
        ctx2[4].includes("h");
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*format*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$w(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(dropdown.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(dropdown.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(if_block1_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
      destroy_component(dropdown, detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function create_else_block_2$2(ctx) {
  let div2;
  let current;
  let each_value_5 = ensure_array_like(
    /*hoursArray*/
    ctx[12]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_5.length; i2 += 1) {
    each_blocks[i2] = create_each_block_5(get_each_context_5(ctx, each_value_5, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div2 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(div_nodes);
      }
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "overflow-auto w-full h-full snap-y snap-mandatory snap-always p-1 space-y-1");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div2, null);
        }
      }
      ctx[38](div2);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*hoursArray, hourSelected, handleSelectHour*/
      135169) {
        each_value_5 = ensure_array_like(
          /*hoursArray*/
          ctx2[12]
        );
        let i2;
        for (i2 = 0; i2 < each_value_5.length; i2 += 1) {
          const child_ctx = get_each_context_5(ctx2, each_value_5, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div2, null);
          }
        }
        group_outros();
        for (i2 = each_value_5.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_5.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
      ctx[38](null);
    }
  };
}
function create_if_block_4$e(ctx) {
  let div2;
  let current;
  let each_value_4 = ensure_array_like(
    /*hoursArray24*/
    ctx[13]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
    each_blocks[i2] = create_each_block_4(get_each_context_4(ctx, each_value_4, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div2 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(div_nodes);
      }
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "overflow-auto w-full h-full snap-y snap-mandatory snap-always p-1 space-y-1");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div2, null);
        }
      }
      ctx[36](div2);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*hoursArray24, hourSelected, handleSelectHour*/
      139265) {
        each_value_4 = ensure_array_like(
          /*hoursArray24*/
          ctx2[13]
        );
        let i2;
        for (i2 = 0; i2 < each_value_4.length; i2 += 1) {
          const child_ctx = get_each_context_4(ctx2, each_value_4, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_4(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div2, null);
          }
        }
        group_outros();
        for (i2 = each_value_4.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
      ctx[36](null);
    }
  };
}
function create_default_slot_17(ctx) {
  let t_value = (
    /*hour*/
    ctx[50] + 1 + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    l(nodes) {
      t2 = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_each_block_5(ctx) {
  let button;
  let current;
  function click_handler_6() {
    return (
      /*click_handler_6*/
      ctx[37](
        /*hour*/
        ctx[50]
      )
    );
  }
  button = new Button$1({
    props: {
      id: `hour-${/*hour*/
      ctx[50] + 1}`,
      class: "w-full flex justify-center items-center snap-center",
      type: `${/*hour*/
      ctx[50] + 1}` === /*hourSelected*/
      ctx[0] ? "primary" : void 0,
      $$slots: { default: [create_default_slot_17] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler_6);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty[0] & /*hourSelected*/
      1)
        button_changes.type = `${/*hour*/
        ctx[50] + 1}` === /*hourSelected*/
        ctx[0] ? "primary" : void 0;
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_16(ctx) {
  let t_value = (
    /*hour*/
    ctx[50] + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    l(nodes) {
      t2 = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_each_block_4(ctx) {
  let button;
  let current;
  function click_handler_5() {
    return (
      /*click_handler_5*/
      ctx[35](
        /*hour*/
        ctx[50]
      )
    );
  }
  button = new Button$1({
    props: {
      id: `hour-${/*hour*/
      ctx[50]}`,
      class: "w-full flex justify-center items-center snap-center",
      type: `${/*hour*/
      ctx[50]}` === /*hourSelected*/
      ctx[0] ? "primary" : void 0,
      $$slots: { default: [create_default_slot_16] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler_5);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty[0] & /*hourSelected*/
      1)
        button_changes.type = `${/*hour*/
        ctx[50]}` === /*hourSelected*/
        ctx[0] ? "primary" : void 0;
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_15(ctx) {
  let t0_value = (
    /*minute*/
    (ctx[47] < 10 ? `0${/*minute*/
    ctx[47]}` : (
      /*minute*/
      ctx[47]
    )) + ""
  );
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
    },
    l(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*minutesArray*/
      32 && t0_value !== (t0_value = /*minute*/
      (ctx2[47] < 10 ? `0${/*minute*/
      ctx2[47]}` : (
        /*minute*/
        ctx2[47]
      )) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_each_block_3$1(ctx) {
  let button;
  let current;
  function click_handler_7() {
    return (
      /*click_handler_7*/
      ctx[39](
        /*minute*/
        ctx[47]
      )
    );
  }
  button = new Button$1({
    props: {
      id: `minute-${/*minute*/
      ctx[47] < 10 ? `0${/*minute*/
      ctx[47]}` : (
        /*minute*/
        ctx[47]
      )}`,
      class: "w-full flex justify-center items-center snap-center",
      type: `${/*minute*/
      ctx[47] < 10 ? `0${/*minute*/
      ctx[47]}` : (
        /*minute*/
        ctx[47]
      )}` === /*minuteSelected*/
      ctx[1] ? "primary" : void 0,
      $$slots: { default: [create_default_slot_15] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler_7);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty[0] & /*minutesArray*/
      32)
        button_changes.id = `minute-${/*minute*/
        ctx[47] < 10 ? `0${/*minute*/
        ctx[47]}` : (
          /*minute*/
          ctx[47]
        )}`;
      if (dirty[0] & /*minutesArray, minuteSelected*/
      34)
        button_changes.type = `${/*minute*/
        ctx[47] < 10 ? `0${/*minute*/
        ctx[47]}` : (
          /*minute*/
          ctx[47]
        )}` === /*minuteSelected*/
        ctx[1] ? "primary" : void 0;
      if (dirty[0] & /*minutesArray*/
      32 | dirty[1] & /*$$scope*/
      1073741824) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_if_block_3$j(ctx) {
  let div2;
  let button0;
  let t2;
  let button1;
  let current;
  button0 = new Button$1({
    props: {
      id: "meridian-AM",
      class: "w-full flex justify-center items-center snap-center",
      type: "AM" === /*meridianSelected*/
      ctx[2] ? "primary" : void 0,
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*click_handler_8*/
    ctx[41]
  );
  button1 = new Button$1({
    props: {
      id: "meridian-PM",
      class: "w-full flex justify-center items-center snap-center",
      type: "PM" === /*meridianSelected*/
      ctx[2] ? "primary" : void 0,
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*click_handler_9*/
    ctx[42]
  );
  return {
    c() {
      div2 = element("div");
      create_component(button0.$$.fragment);
      t2 = space();
      create_component(button1.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      claim_component(button0.$$.fragment, div_nodes);
      t2 = claim_space(div_nodes);
      claim_component(button1.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "overflow-auto w-full h-full snap-y snap-mandatory snap-always p-1 space-y-1");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(button0, div2, null);
      append_hydration(div2, t2);
      mount_component(button1, div2, null);
      ctx[43](div2);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty[0] & /*meridianSelected*/
      4)
        button0_changes.type = "AM" === /*meridianSelected*/
        ctx2[2] ? "primary" : void 0;
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty[0] & /*meridianSelected*/
      4)
        button1_changes.type = "PM" === /*meridianSelected*/
        ctx2[2] ? "primary" : void 0;
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(button0);
      destroy_component(button1);
      ctx[43](null);
    }
  };
}
function create_default_slot_14(ctx) {
  let t2;
  return {
    c() {
      t2 = text("AM");
    },
    l(nodes) {
      t2 = claim_text(nodes, "AM");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_13(ctx) {
  let t2;
  return {
    c() {
      t2 = text("PM");
    },
    l(nodes) {
      t2 = claim_text(nodes, "PM");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_else_block$i(ctx) {
  let dropdown;
  let updating_visible;
  let current;
  function dropdown_visible_binding_1(value) {
    ctx[29](value);
  }
  let dropdown_props = {
    class: "w-full",
    $$slots: {
      items: [create_items_slot_3],
      trigger: [create_trigger_slot_3]
    },
    $$scope: { ctx }
  };
  if (
    /*hoursVisible*/
    ctx[9] !== void 0
  ) {
    dropdown_props.visible = /*hoursVisible*/
    ctx[9];
  }
  dropdown = new Dropdown({ props: dropdown_props });
  binding_callbacks.push(() => bind(dropdown, "visible", dropdown_visible_binding_1));
  return {
    c() {
      create_component(dropdown.$$.fragment);
    },
    l(nodes) {
      claim_component(dropdown.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(dropdown, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dropdown_changes = {};
      if (dirty[0] & /*hourSelected*/
      1 | dirty[1] & /*$$scope*/
      1073741824) {
        dropdown_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_visible && dirty[0] & /*hoursVisible*/
      512) {
        updating_visible = true;
        dropdown_changes.visible = /*hoursVisible*/
        ctx2[9];
        add_flush_callback(() => updating_visible = false);
      }
      dropdown.$set(dropdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dropdown, detaching);
    }
  };
}
function create_if_block_2$k(ctx) {
  let dropdown;
  let updating_visible;
  let current;
  function dropdown_visible_binding(value) {
    ctx[27](value);
  }
  let dropdown_props = {
    class: "w-full",
    $$slots: {
      items: [create_items_slot_2],
      trigger: [create_trigger_slot_2]
    },
    $$scope: { ctx }
  };
  if (
    /*hoursVisible*/
    ctx[9] !== void 0
  ) {
    dropdown_props.visible = /*hoursVisible*/
    ctx[9];
  }
  dropdown = new Dropdown({ props: dropdown_props });
  binding_callbacks.push(() => bind(dropdown, "visible", dropdown_visible_binding));
  return {
    c() {
      create_component(dropdown.$$.fragment);
    },
    l(nodes) {
      claim_component(dropdown.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(dropdown, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dropdown_changes = {};
      if (dirty[0] & /*hourSelected*/
      1 | dirty[1] & /*$$scope*/
      1073741824) {
        dropdown_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_visible && dirty[0] & /*hoursVisible*/
      512) {
        updating_visible = true;
        dropdown_changes.visible = /*hoursVisible*/
        ctx2[9];
        add_flush_callback(() => updating_visible = false);
      }
      dropdown.$set(dropdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dropdown, detaching);
    }
  };
}
function create_default_slot_12(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*hourSelected*/
        ctx[0]
      );
    },
    l(nodes) {
      t2 = claim_text(
        nodes,
        /*hourSelected*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*hourSelected*/
      1)
        set_data(
          t2,
          /*hourSelected*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_trigger_slot_3(ctx) {
  let button;
  let current;
  button = new Button$1({
    props: {
      slot: "trigger",
      class: "w-full bg-transparent border-primary border active:bg-transparent focus:bg-transparent",
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*toggleHoursVisibility*/
    ctx[14]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty[0] & /*hourSelected*/
      1 | dirty[1] & /*$$scope*/
      1073741824) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_11(ctx) {
  let t_value = (
    /*hour*/
    ctx[50] + 1 + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    l(nodes) {
      t2 = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_each_block_2$2(ctx) {
  let button;
  let current;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[28](
        /*hour*/
        ctx[50]
      )
    );
  }
  button = new Button$1({
    props: {
      id: `hour-${/*hour*/
      ctx[50] + 1}`,
      class: "w-full flex justify-center items-center snap-center",
      type: `${/*hour*/
      ctx[50] + 1}` === /*hourSelected*/
      ctx[0] ? "primary" : void 0,
      $$slots: { default: [create_default_slot_11] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler_1);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty[0] & /*hourSelected*/
      1)
        button_changes.type = `${/*hour*/
        ctx[50] + 1}` === /*hourSelected*/
        ctx[0] ? "primary" : void 0;
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_10(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ensure_array_like(
    /*hoursArray*/
    ctx[12]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*hoursArray, hourSelected, handleSelectHour*/
      135169) {
        each_value_2 = ensure_array_like(
          /*hoursArray*/
          ctx2[12]
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$2(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2$2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_items_slot_3(ctx) {
  let dropdown_items;
  let current;
  dropdown_items = new Dropdown.Items({
    props: {
      slot: "items",
      id: "hourDropdownScroll",
      class: "max-w-full w-full max-h-[160px] overflow-auto",
      offset: 14,
      $$slots: { default: [create_default_slot_10] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(dropdown_items.$$.fragment);
    },
    l(nodes) {
      claim_component(dropdown_items.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(dropdown_items, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dropdown_items_changes = {};
      if (dirty[0] & /*hourSelected*/
      1 | dirty[1] & /*$$scope*/
      1073741824) {
        dropdown_items_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropdown_items.$set(dropdown_items_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dropdown_items.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropdown_items.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dropdown_items, detaching);
    }
  };
}
function create_default_slot_9(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*hourSelected*/
        ctx[0]
      );
    },
    l(nodes) {
      t2 = claim_text(
        nodes,
        /*hourSelected*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*hourSelected*/
      1)
        set_data(
          t2,
          /*hourSelected*/
          ctx2[0]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_trigger_slot_2(ctx) {
  let button;
  let current;
  button = new Button$1({
    props: {
      slot: "trigger",
      type: "primary",
      class: "w-full",
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*toggleHoursVisibility*/
    ctx[14]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty[0] & /*hourSelected*/
      1 | dirty[1] & /*$$scope*/
      1073741824) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_8(ctx) {
  let t_value = (
    /*hour*/
    ctx[50] + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    l(nodes) {
      t2 = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_each_block_1$5(ctx) {
  let button;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[26](
        /*hour*/
        ctx[50]
      )
    );
  }
  button = new Button$1({
    props: {
      id: `hour-${/*hour*/
      ctx[50]}`,
      class: "w-full flex justify-center items-center snap-center",
      type: `${/*hour*/
      ctx[50]}` === /*hourSelected*/
      ctx[0] ? "primary" : void 0,
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty[0] & /*hourSelected*/
      1)
        button_changes.type = `${/*hour*/
        ctx[50]}` === /*hourSelected*/
        ctx[0] ? "primary" : void 0;
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_7$2(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*hoursArray24*/
    ctx[13]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*hoursArray24, hourSelected, handleSelectHour*/
      139265) {
        each_value_1 = ensure_array_like(
          /*hoursArray24*/
          ctx2[13]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$5(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_items_slot_2(ctx) {
  let dropdown_items;
  let current;
  dropdown_items = new Dropdown.Items({
    props: {
      slot: "items",
      id: "hourDropdownScroll",
      class: "max-w-full w-full max-h-[160px] overflow-auto",
      offset: 14,
      $$slots: { default: [create_default_slot_7$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(dropdown_items.$$.fragment);
    },
    l(nodes) {
      claim_component(dropdown_items.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(dropdown_items, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dropdown_items_changes = {};
      if (dirty[0] & /*hourSelected*/
      1 | dirty[1] & /*$$scope*/
      1073741824) {
        dropdown_items_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropdown_items.$set(dropdown_items_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dropdown_items.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropdown_items.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dropdown_items, detaching);
    }
  };
}
function create_default_slot_6$2(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*minuteSelected*/
        ctx[1]
      );
    },
    l(nodes) {
      t2 = claim_text(
        nodes,
        /*minuteSelected*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*minuteSelected*/
      2)
        set_data(
          t2,
          /*minuteSelected*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_trigger_slot_1(ctx) {
  let button;
  let current;
  button = new Button$1({
    props: {
      slot: "trigger",
      class: "w-full bg-transparent border-primary border active:bg-transparent focus:bg-transparent",
      $$slots: { default: [create_default_slot_6$2] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*toggleMinutesVisibility*/
    ctx[15]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty[0] & /*minuteSelected*/
      2 | dirty[1] & /*$$scope*/
      1073741824) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_5$3(ctx) {
  let t0_value = (
    /*minute*/
    (ctx[47] < 10 ? `0${/*minute*/
    ctx[47]}` : (
      /*minute*/
      ctx[47]
    )) + ""
  );
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
    },
    l(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*minutesArray*/
      32 && t0_value !== (t0_value = /*minute*/
      (ctx2[47] < 10 ? `0${/*minute*/
      ctx2[47]}` : (
        /*minute*/
        ctx2[47]
      )) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_each_block$c(ctx) {
  let button;
  let current;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[30](
        /*minute*/
        ctx[47]
      )
    );
  }
  button = new Button$1({
    props: {
      id: `minute-${/*minute*/
      ctx[47] < 10 ? `0${/*minute*/
      ctx[47]}` : (
        /*minute*/
        ctx[47]
      )}`,
      class: "w-full flex justify-center items-center snap-center",
      type: `${/*minute*/
      ctx[47] < 10 ? `0${/*minute*/
      ctx[47]}` : (
        /*minute*/
        ctx[47]
      )}` === /*minuteSelected*/
      ctx[1] ? "primary" : void 0,
      $$slots: { default: [create_default_slot_5$3] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler_2);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty[0] & /*minutesArray*/
      32)
        button_changes.id = `minute-${/*minute*/
        ctx[47] < 10 ? `0${/*minute*/
        ctx[47]}` : (
          /*minute*/
          ctx[47]
        )}`;
      if (dirty[0] & /*minutesArray, minuteSelected*/
      34)
        button_changes.type = `${/*minute*/
        ctx[47] < 10 ? `0${/*minute*/
        ctx[47]}` : (
          /*minute*/
          ctx[47]
        )}` === /*minuteSelected*/
        ctx[1] ? "primary" : void 0;
      if (dirty[0] & /*minutesArray*/
      32 | dirty[1] & /*$$scope*/
      1073741824) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_4$5(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*minutesArray*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$c(get_each_context$c(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*minutesArray, minuteSelected, handleSelectMinute*/
      262178) {
        each_value = ensure_array_like(
          /*minutesArray*/
          ctx2[5]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$c(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$c(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_items_slot_1(ctx) {
  let dropdown_items;
  let current;
  dropdown_items = new Dropdown.Items({
    props: {
      slot: "items",
      id: "minuteDropdownScroll",
      class: "max-w-full w-full max-h-[160px] overflow-auto",
      offset: 14,
      $$slots: { default: [create_default_slot_4$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(dropdown_items.$$.fragment);
    },
    l(nodes) {
      claim_component(dropdown_items.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(dropdown_items, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dropdown_items_changes = {};
      if (dirty[0] & /*minutesArray, minuteSelected*/
      34 | dirty[1] & /*$$scope*/
      1073741824) {
        dropdown_items_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropdown_items.$set(dropdown_items_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dropdown_items.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropdown_items.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dropdown_items, detaching);
    }
  };
}
function create_if_block_1$w(ctx) {
  let dropdown;
  let updating_visible;
  let current;
  function dropdown_visible_binding_3(value) {
    ctx[34](value);
  }
  let dropdown_props = {
    class: "w-full",
    $$slots: {
      items: [create_items_slot$2],
      trigger: [create_trigger_slot$2]
    },
    $$scope: { ctx }
  };
  if (
    /*meridianVisible*/
    ctx[11] !== void 0
  ) {
    dropdown_props.visible = /*meridianVisible*/
    ctx[11];
  }
  dropdown = new Dropdown({ props: dropdown_props });
  binding_callbacks.push(() => bind(dropdown, "visible", dropdown_visible_binding_3));
  return {
    c() {
      create_component(dropdown.$$.fragment);
    },
    l(nodes) {
      claim_component(dropdown.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(dropdown, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dropdown_changes = {};
      if (dirty[0] & /*meridianSelected*/
      4 | dirty[1] & /*$$scope*/
      1073741824) {
        dropdown_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_visible && dirty[0] & /*meridianVisible*/
      2048) {
        updating_visible = true;
        dropdown_changes.visible = /*meridianVisible*/
        ctx2[11];
        add_flush_callback(() => updating_visible = false);
      }
      dropdown.$set(dropdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dropdown, detaching);
    }
  };
}
function create_default_slot_3$7(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*meridianSelected*/
        ctx[2]
      );
    },
    l(nodes) {
      t2 = claim_text(
        nodes,
        /*meridianSelected*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*meridianSelected*/
      4)
        set_data(
          t2,
          /*meridianSelected*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_trigger_slot$2(ctx) {
  let button;
  let current;
  button = new Button$1({
    props: {
      slot: "trigger",
      class: "w-full bg-transparent border-primary border active:bg-transparent focus:bg-transparent",
      $$slots: { default: [create_default_slot_3$7] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*toggleMeridianVisibility*/
    ctx[16]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty[0] & /*meridianSelected*/
      4 | dirty[1] & /*$$scope*/
      1073741824) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_2$9(ctx) {
  let t2;
  return {
    c() {
      t2 = text("AM");
    },
    l(nodes) {
      t2 = claim_text(nodes, "AM");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$b(ctx) {
  let t2;
  return {
    c() {
      t2 = text("PM");
    },
    l(nodes) {
      t2 = claim_text(nodes, "PM");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$f(ctx) {
  let button0;
  let t2;
  let button1;
  let current;
  button0 = new Button$1({
    props: {
      id: "meridian-AM",
      class: "w-full flex justify-center items-center snap-center",
      type: "AM" === /*meridianSelected*/
      ctx[2] ? "primary" : void 0,
      $$slots: { default: [create_default_slot_2$9] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*click_handler_3*/
    ctx[32]
  );
  button1 = new Button$1({
    props: {
      id: "meridian-PM",
      class: "w-full flex justify-center items-center snap-center",
      type: "PM" === /*meridianSelected*/
      ctx[2] ? "primary" : void 0,
      $$slots: { default: [create_default_slot_1$b] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*click_handler_4*/
    ctx[33]
  );
  return {
    c() {
      create_component(button0.$$.fragment);
      t2 = space();
      create_component(button1.$$.fragment);
    },
    l(nodes) {
      claim_component(button0.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(button1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button0, target, anchor);
      insert_hydration(target, t2, anchor);
      mount_component(button1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty[0] & /*meridianSelected*/
      4)
        button0_changes.type = "AM" === /*meridianSelected*/
        ctx2[2] ? "primary" : void 0;
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty[0] & /*meridianSelected*/
      4)
        button1_changes.type = "PM" === /*meridianSelected*/
        ctx2[2] ? "primary" : void 0;
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(button0, detaching);
      destroy_component(button1, detaching);
    }
  };
}
function create_items_slot$2(ctx) {
  let dropdown_items;
  let current;
  dropdown_items = new Dropdown.Items({
    props: {
      slot: "items",
      id: "meridianDropdownScroll",
      class: "max-w-full w-full max-h-[160px] overflow-auto",
      offset: 14,
      $$slots: { default: [create_default_slot$f] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(dropdown_items.$$.fragment);
    },
    l(nodes) {
      claim_component(dropdown_items.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(dropdown_items, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dropdown_items_changes = {};
      if (dirty[0] & /*meridianSelected*/
      4 | dirty[1] & /*$$scope*/
      1073741824) {
        dropdown_items_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropdown_items.$set(dropdown_items_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dropdown_items.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropdown_items.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dropdown_items, detaching);
    }
  };
}
function create_fragment$26(ctx) {
  let div2;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block$K, create_else_block_1$5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*mobile*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div2 = element("div");
      if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "flex flex-row justify-evenly divide-x divide-border");
      toggle_class(div2, "divide-x", !/*mobile*/
      ctx[3]);
      toggle_class(div2, "divide-border", !/*mobile*/
      ctx[3]);
      toggle_class(div2, "items-stretch", !/*mobile*/
      ctx[3]);
      toggle_class(div2, "w-[168px]", !/*mobile*/
      ctx[3]);
      toggle_class(
        div2,
        "items-center",
        /*mobile*/
        ctx[3]
      );
      toggle_class(
        div2,
        "w-full",
        /*mobile*/
        ctx[3]
      );
      toggle_class(
        div2,
        "h-14",
        /*mobile*/
        ctx[3]
      );
      toggle_class(
        div2,
        "px-3",
        /*mobile*/
        ctx[3]
      );
      toggle_class(
        div2,
        "gap-3",
        /*mobile*/
        ctx[3]
      );
      toggle_class(div2, "gap-2", !/*mobile*/
      ctx[3]);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if_blocks[current_block_type_index].m(div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div2, null);
      }
      if (!current || dirty[0] & /*mobile*/
      8) {
        toggle_class(div2, "divide-x", !/*mobile*/
        ctx2[3]);
      }
      if (!current || dirty[0] & /*mobile*/
      8) {
        toggle_class(div2, "divide-border", !/*mobile*/
        ctx2[3]);
      }
      if (!current || dirty[0] & /*mobile*/
      8) {
        toggle_class(div2, "items-stretch", !/*mobile*/
        ctx2[3]);
      }
      if (!current || dirty[0] & /*mobile*/
      8) {
        toggle_class(div2, "w-[168px]", !/*mobile*/
        ctx2[3]);
      }
      if (!current || dirty[0] & /*mobile*/
      8) {
        toggle_class(
          div2,
          "items-center",
          /*mobile*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*mobile*/
      8) {
        toggle_class(
          div2,
          "w-full",
          /*mobile*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*mobile*/
      8) {
        toggle_class(
          div2,
          "h-14",
          /*mobile*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*mobile*/
      8) {
        toggle_class(
          div2,
          "px-3",
          /*mobile*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*mobile*/
      8) {
        toggle_class(
          div2,
          "gap-3",
          /*mobile*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*mobile*/
      8) {
        toggle_class(div2, "gap-2", !/*mobile*/
        ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function findClosestNumber(target, array) {
  return array.reduce((closest, current) => {
    var closestDiff = Math.abs(closest - target);
    var currentDiff = Math.abs(current - target);
    return currentDiff < closestDiff ? current : closest;
  });
}
function scrollIfNeeded(element2, container) {
  container.scrollTop = element2.offsetTop - container.offsetTop - 112;
}
function convertNumberToMinuteString(n) {
  if (n < 10) {
    return `0${n}`;
  }
  return `${n}`;
}
function instance$24($$self, $$props, $$invalidate) {
  let { mobile = false } = $$props;
  let { showTime } = $$props;
  let { hourSelected } = $$props;
  let { minuteSelected } = $$props;
  let { meridianSelected } = $$props;
  let { step } = $$props;
  let { browseDate } = $$props;
  let { closeOnSelect } = $$props;
  let { setValue } = $$props;
  let { handleSelect } = $$props;
  let { format: format2 } = $$props;
  let hoursArray = [...Array(12).keys()];
  let hoursArray24 = [...Array(25).keys()];
  let minutesArray = [...Array(60).keys()];
  minutesArray = minutesArray.filter((x2) => x2 % step === 0);
  let hourScroll;
  let minuteScroll;
  let meridianScroll;
  let hoursVisible = false;
  let minutesVisible = false;
  let meridianVisible = false;
  function toggleHoursVisibility() {
    $$invalidate(9, hoursVisible = !hoursVisible);
    if (hoursVisible) {
      setTimeout(
        () => {
          const hourEl = document.getElementById(`hour-${hourSelected}`);
          const hourDropdownScroll = document.getElementById("hourDropdownScroll");
          if (hourEl && hourDropdownScroll) {
            hourDropdownScroll.scrollTop = hourEl.offsetTop - hourDropdownScroll.offsetTop - 230;
          }
        },
        1
      );
    }
  }
  function closeHoursVisibility() {
    $$invalidate(9, hoursVisible = false);
  }
  function toggleMinutesVisibility() {
    $$invalidate(10, minutesVisible = !minutesVisible);
    setTimeout(
      () => {
        const minuteEl = document.getElementById(`minute-${minuteSelected}`);
        const minuteDropdownScroll = document.getElementById("minuteDropdownScroll");
        if (minuteEl && minuteDropdownScroll) {
          minuteDropdownScroll.scrollTop = minuteEl.offsetTop - minuteDropdownScroll.offsetTop - 230;
        }
      },
      1
    );
  }
  function closeMinutesVisibility() {
    $$invalidate(10, minutesVisible = false);
  }
  function toggleMeridianVisibility() {
    $$invalidate(11, meridianVisible = !meridianVisible);
    setTimeout(
      () => {
        const meridianEl = document.getElementById(`meridian-${meridianSelected}`);
        const meridianDropdownScroll = document.getElementById("meridianDropdownScroll");
        if (meridianEl && meridianDropdownScroll) {
          meridianDropdownScroll.scrollTop = meridianEl.offsetTop - meridianDropdownScroll.offsetTop - 230;
        }
      },
      1
    );
  }
  function closeMeridianVisibility() {
    $$invalidate(11, meridianVisible = false);
  }
  function handleSelectHour(hour) {
    $$invalidate(0, hourSelected = hour);
    if (format2.includes("H")) {
      $$invalidate(20, browseDate = browseDate.set("hour", parseInt(hourSelected)).set("minute", parseInt(minuteSelected)));
    } else if (meridianSelected === "AM") {
      $$invalidate(20, browseDate = browseDate.set("hour", parseInt(hourSelected)).set("minute", parseInt(minuteSelected)));
    } else {
      $$invalidate(20, browseDate = browseDate.set("hour", parseInt(hourSelected) + 12).set("minute", parseInt(minuteSelected)));
    }
    setValue(browseDate);
    handleSelect(browseDate);
    if (mobile) {
      closeHoursVisibility();
    }
  }
  function handleSelectMinute(minute) {
    $$invalidate(1, minuteSelected = minute);
    if (!format2.includes("H")) {
      $$invalidate(20, browseDate = browseDate.set("hour", parseInt(hourSelected)).set("minute", parseInt(minuteSelected)));
    } else if (meridianSelected === "AM") {
      $$invalidate(20, browseDate = browseDate.set("hour", parseInt(hourSelected)).set("minute", parseInt(minuteSelected)));
    } else {
      $$invalidate(20, browseDate = browseDate.set("hour", parseInt(hourSelected) + 12).set("minute", parseInt(minuteSelected)));
    }
    setValue(browseDate);
    handleSelect(browseDate);
    if (mobile) {
      closeMinutesVisibility();
    }
  }
  function handleSelectMeridian(meridian) {
    $$invalidate(2, meridianSelected = meridian);
    if (meridianSelected === "AM") {
      $$invalidate(20, browseDate = browseDate.set("hour", parseInt(hourSelected)).set("minute", parseInt(minuteSelected)));
    } else {
      $$invalidate(20, browseDate = browseDate.set("hour", parseInt(hourSelected) + 12).set("minute", parseInt(minuteSelected)));
    }
    setValue(browseDate);
    handleSelect(browseDate);
    if (mobile) {
      closeMeridianVisibility();
    }
  }
  onMount(() => {
    if (showTime) {
      $$invalidate(21, closeOnSelect = false);
      if (format2.includes("h")) {
        $$invalidate(0, hourSelected = browseDate.format("h"));
      } else if (format2.includes("H")) {
        $$invalidate(0, hourSelected = browseDate.format("H"));
      }
      $$invalidate(1, minuteSelected = convertNumberToMinuteString(findClosestNumber(parseInt(browseDate.format("mm")), minutesArray)));
      if (format2.includes("A")) {
        $$invalidate(2, meridianSelected = browseDate.format("A"));
      } else if (format2.includes("a")) {
        $$invalidate(2, meridianSelected = browseDate.format("a"));
      }
      const hourEl = document.getElementById(`hour-${hourSelected}`);
      const minuteEl = document.getElementById(`minute-${minuteSelected}`);
      const meridianEl = document.getElementById(`meridian-${meridianSelected}`);
      if (hourEl) {
        scrollIfNeeded(hourEl, hourScroll);
      }
      if (minuteEl) {
        scrollIfNeeded(minuteEl, minuteScroll);
      }
      if (meridianEl) {
        scrollIfNeeded(meridianEl, meridianScroll);
      }
    }
  });
  const click_handler = (hour) => handleSelectHour(`${hour}`);
  function dropdown_visible_binding(value) {
    hoursVisible = value;
    $$invalidate(9, hoursVisible);
  }
  const click_handler_1 = (hour) => handleSelectHour(`${hour + 1}`);
  function dropdown_visible_binding_1(value) {
    hoursVisible = value;
    $$invalidate(9, hoursVisible);
  }
  const click_handler_2 = (minute) => handleSelectMinute(`${minute < 10 ? `0${minute}` : minute}`);
  function dropdown_visible_binding_2(value) {
    minutesVisible = value;
    $$invalidate(10, minutesVisible);
  }
  const click_handler_3 = () => handleSelectMeridian("AM");
  const click_handler_4 = () => handleSelectMeridian("PM");
  function dropdown_visible_binding_3(value) {
    meridianVisible = value;
    $$invalidate(11, meridianVisible);
  }
  const click_handler_5 = (hour) => handleSelectHour(`${hour}`);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      hourScroll = $$value;
      $$invalidate(6, hourScroll);
    });
  }
  const click_handler_6 = (hour) => handleSelectHour(`${hour + 1}`);
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      hourScroll = $$value;
      $$invalidate(6, hourScroll);
    });
  }
  const click_handler_7 = (minute) => handleSelectMinute(`${minute < 10 ? `0${minute}` : minute}`);
  function div_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      minuteScroll = $$value;
      $$invalidate(7, minuteScroll);
    });
  }
  const click_handler_8 = () => handleSelectMeridian("AM");
  const click_handler_9 = () => handleSelectMeridian("PM");
  function div_binding_3($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      meridianScroll = $$value;
      $$invalidate(8, meridianScroll);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("mobile" in $$props2)
      $$invalidate(3, mobile = $$props2.mobile);
    if ("showTime" in $$props2)
      $$invalidate(22, showTime = $$props2.showTime);
    if ("hourSelected" in $$props2)
      $$invalidate(0, hourSelected = $$props2.hourSelected);
    if ("minuteSelected" in $$props2)
      $$invalidate(1, minuteSelected = $$props2.minuteSelected);
    if ("meridianSelected" in $$props2)
      $$invalidate(2, meridianSelected = $$props2.meridianSelected);
    if ("step" in $$props2)
      $$invalidate(23, step = $$props2.step);
    if ("browseDate" in $$props2)
      $$invalidate(20, browseDate = $$props2.browseDate);
    if ("closeOnSelect" in $$props2)
      $$invalidate(21, closeOnSelect = $$props2.closeOnSelect);
    if ("setValue" in $$props2)
      $$invalidate(24, setValue = $$props2.setValue);
    if ("handleSelect" in $$props2)
      $$invalidate(25, handleSelect = $$props2.handleSelect);
    if ("format" in $$props2)
      $$invalidate(4, format2 = $$props2.format);
  };
  return [
    hourSelected,
    minuteSelected,
    meridianSelected,
    mobile,
    format2,
    minutesArray,
    hourScroll,
    minuteScroll,
    meridianScroll,
    hoursVisible,
    minutesVisible,
    meridianVisible,
    hoursArray,
    hoursArray24,
    toggleHoursVisibility,
    toggleMinutesVisibility,
    toggleMeridianVisibility,
    handleSelectHour,
    handleSelectMinute,
    handleSelectMeridian,
    browseDate,
    closeOnSelect,
    showTime,
    step,
    setValue,
    handleSelect,
    click_handler,
    dropdown_visible_binding,
    click_handler_1,
    dropdown_visible_binding_1,
    click_handler_2,
    dropdown_visible_binding_2,
    click_handler_3,
    click_handler_4,
    dropdown_visible_binding_3,
    click_handler_5,
    div_binding,
    click_handler_6,
    div_binding_1,
    click_handler_7,
    div_binding_2,
    click_handler_8,
    click_handler_9,
    div_binding_3
  ];
}
class TimePicker extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$24,
      create_fragment$26,
      safe_not_equal,
      {
        mobile: 3,
        showTime: 22,
        hourSelected: 0,
        minuteSelected: 1,
        meridianSelected: 2,
        step: 23,
        browseDate: 20,
        closeOnSelect: 21,
        setValue: 24,
        handleSelect: 25,
        format: 4
      },
      null,
      [-1, -1]
    );
  }
}
const DatePicker_svelte_svelte_type_style_lang = "";
function get_each_context$b(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[50] = list[i2];
  return child_ctx;
}
function get_each_context_1$4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[53] = list[i2];
  child_ctx[55] = i2;
  return child_ctx;
}
function get_each_context_2$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[56] = list[i2];
  return child_ctx;
}
function get_each_context_3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[53] = list[i2];
  child_ctx[60] = i2;
  return child_ctx;
}
function create_default_slot_7$1(ctx) {
  let svg;
  let title;
  let t2;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      title = svg_element("title");
      t2 = text("chevron-double-left");
      path = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, viewBox: true, class: true });
      var svg_nodes = children(svg);
      title = claim_svg_element(svg_nodes, "title", {});
      var title_nodes = children(title);
      t2 = claim_text(title_nodes, "chevron-double-left");
      title_nodes.forEach(detach);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path, "d", "M18.41,7.41L17,6L11,12L17,18L18.41,16.59L13.83,12L18.41,7.41M12.41,7.41L11,6L5,12L11,18L12.41,16.59L7.83,12L12.41,7.41Z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", "svg-icon inline-block outline-none h-5 w-5 fill-current");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, title);
      append_hydration(title, t2);
      append_hydration(svg, path);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot_6$1(ctx) {
  let svg;
  let title;
  let t2;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      title = svg_element("title");
      t2 = text("chevron-left");
      path = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, viewBox: true, class: true });
      var svg_nodes = children(svg);
      title = claim_svg_element(svg_nodes, "title", {});
      var title_nodes = children(title);
      t2 = claim_text(title_nodes, "chevron-left");
      title_nodes.forEach(detach);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path, "d", "M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", "svg-icon inline-block outline-none h-5 w-5 fill-current");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, title);
      append_hydration(title, t2);
      append_hydration(svg, path);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot_5$2(ctx) {
  let svg;
  let title;
  let t2;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      title = svg_element("title");
      t2 = text("chevron-right");
      path = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, viewBox: true, class: true });
      var svg_nodes = children(svg);
      title = claim_svg_element(svg_nodes, "title", {});
      var title_nodes = children(title);
      t2 = claim_text(title_nodes, "chevron-right");
      title_nodes.forEach(detach);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path, "d", "M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", "svg-icon inline-block outline-none h-5 w-5 fill-current");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, title);
      append_hydration(title, t2);
      append_hydration(svg, path);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_default_slot_4$4(ctx) {
  let svg;
  let title;
  let t2;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      title = svg_element("title");
      t2 = text("chevron-double-right");
      path = svg_element("path");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", { xmlns: true, viewBox: true, class: true });
      var svg_nodes = children(svg);
      title = claim_svg_element(svg_nodes, "title", {});
      var title_nodes = children(title);
      t2 = claim_text(title_nodes, "chevron-double-right");
      title_nodes.forEach(detach);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(path, "d", "M5.59,7.41L7,6L13,12L7,18L5.59,16.59L10.17,12L5.59,7.41M11.59,7.41L13,6L19,12L13,18L11.59,16.59L16.17,12L11.59,7.41Z");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "viewBox", "0 0 24 24");
      attr(svg, "class", "svg-icon inline-block outline-none h-5 w-5 fill-current");
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, title);
      append_hydration(title, t2);
      append_hydration(svg, path);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
function create_else_block_1$4(ctx) {
  let div2;
  let t0_value = (
    /*iLocale*/
    ctx[15].weekdays[
      /*iLocale*/
      ctx[15].weekStartsOn + /*i*/
      ctx[60] - 7
    ] + ""
  );
  let t0;
  let t1;
  return {
    c() {
      div2 = element("div");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      t0 = claim_text(div_nodes, t0_value);
      t1 = claim_space(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "w-10 text-center text-sm");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, t0);
      append_hydration(div2, t1);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_if_block_5$d(ctx) {
  let div2;
  let t0_value = (
    /*iLocale*/
    ctx[15].weekdays[
      /*iLocale*/
      ctx[15].weekStartsOn + /*i*/
      ctx[60]
    ] + ""
  );
  let t0;
  let t1;
  return {
    c() {
      div2 = element("div");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      t0 = claim_text(div_nodes, t0_value);
      t1 = claim_space(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "w-10 text-center text-sm");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, t0);
      append_hydration(div2, t1);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_each_block_3(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*i*/
      ctx2[60] + /*iLocale*/
      ctx2[15].weekStartsOn < 7
    )
      return create_if_block_5$d;
    return create_else_block_1$4;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_else_block$h(ctx) {
  let button;
  let span;
  let t_value = (
    /*calendarDay*/
    ctx[56].date() + ""
  );
  let t2;
  let button_aria_label_value;
  let mounted;
  let dispose;
  function click_handler_4() {
    return (
      /*click_handler_4*/
      ctx[32](
        /*calendarDay*/
        ctx[56]
      )
    );
  }
  return {
    c() {
      button = element("button");
      span = element("span");
      t2 = text(t_value);
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { "aria-label": true, class: true });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", {});
      var span_nodes = children(span);
      t2 = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "aria-label", button_aria_label_value = /*iLocale*/
      ctx[15].months[
        /*browseDate*/
        ctx[8].month()
      ] + " " + /*calendarDay*/
      ctx[56].date() + " " + /*browseDate*/
      ctx[8].year() + " ");
      attr(button, "class", "active w-10 flex items-center justify-center cursor-pointer h-10 rounded-full");
      toggle_class(
        button,
        "text-primary-content",
        /*calendarDay*/
        ctx[56].isSame(
          /*value*/
          ctx[0],
          "date"
        )
      );
      toggle_class(
        button,
        "hover:text-primary-content",
        /*calendarDay*/
        ctx[56].isSame(
          /*value*/
          ctx[0],
          "date"
        )
      );
      toggle_class(
        button,
        "text-secondary-content",
        /*calendarDay*/
        ctx[56].month() !== /*browseDate*/
        ctx[8].month()
      );
      toggle_class(
        button,
        "text-opacity-[0.5]",
        /*calendarDay*/
        ctx[56].month() !== /*browseDate*/
        ctx[8].month()
      );
      toggle_class(
        button,
        "text-content",
        /*calendarDay*/
        ctx[56].month() === /*browseDate*/
        ctx[8].month()
      );
      toggle_class(
        button,
        "hover:bg-hover",
        /*dayIsInRange*/
        ctx[18](
          /*calendarDay*/
          ctx[56]
        ) && !/*calendarDay*/
        ctx[56].isSame(
          /*value*/
          ctx[0],
          "date"
        )
      );
      toggle_class(
        button,
        "hover:bg-opacity-[0.07]",
        /*dayIsInRange*/
        ctx[18](
          /*calendarDay*/
          ctx[56]
        ) && !/*calendarDay*/
        ctx[56].isSame(
          /*value*/
          ctx[0],
          "date"
        )
      );
      toggle_class(
        button,
        "bg-hover",
        /*calendarDay*/
        ctx[56].isSame(
          /*browseDate*/
          ctx[8],
          "date"
        ) && !/*calendarDay*/
        ctx[56].isSame(
          /*value*/
          ctx[0],
          "date"
        )
      );
      toggle_class(
        button,
        "bg-opacity-[0.07]",
        /*calendarDay*/
        ctx[56].isSame(
          /*browseDate*/
          ctx[8],
          "date"
        ) && !/*calendarDay*/
        ctx[56].isSame(
          /*value*/
          ctx[0],
          "date"
        )
      );
      toggle_class(
        button,
        "border",
        /*calendarDay*/
        ctx[56].isSame(
          /*defaultDate*/
          ctx[14],
          "day"
        ) && !/*calendarDay*/
        ctx[56].isSame(
          /*value*/
          ctx[0],
          "date"
        )
      );
      toggle_class(
        button,
        "border-primary",
        /*calendarDay*/
        ctx[56].isSame(
          /*defaultDate*/
          ctx[14],
          "day"
        ) && !/*calendarDay*/
        ctx[56].isSame(
          /*value*/
          ctx[0],
          "date"
        )
      );
      toggle_class(
        button,
        "bg-primary",
        /*calendarDay*/
        ctx[56].isSame(
          /*value*/
          ctx[0],
          "date"
        )
      );
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, span);
      append_hydration(span, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_4);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*calendarDays*/
      1024 && t_value !== (t_value = /*calendarDay*/
      ctx[56].date() + ""))
        set_data(t2, t_value);
      if (dirty[0] & /*browseDate, calendarDays*/
      1280 && button_aria_label_value !== (button_aria_label_value = /*iLocale*/
      ctx[15].months[
        /*browseDate*/
        ctx[8].month()
      ] + " " + /*calendarDay*/
      ctx[56].date() + " " + /*browseDate*/
      ctx[8].year() + " ")) {
        attr(button, "aria-label", button_aria_label_value);
      }
      if (dirty[0] & /*calendarDays, value*/
      1025) {
        toggle_class(
          button,
          "text-primary-content",
          /*calendarDay*/
          ctx[56].isSame(
            /*value*/
            ctx[0],
            "date"
          )
        );
      }
      if (dirty[0] & /*calendarDays, value*/
      1025) {
        toggle_class(
          button,
          "hover:text-primary-content",
          /*calendarDay*/
          ctx[56].isSame(
            /*value*/
            ctx[0],
            "date"
          )
        );
      }
      if (dirty[0] & /*calendarDays, browseDate*/
      1280) {
        toggle_class(
          button,
          "text-secondary-content",
          /*calendarDay*/
          ctx[56].month() !== /*browseDate*/
          ctx[8].month()
        );
      }
      if (dirty[0] & /*calendarDays, browseDate*/
      1280) {
        toggle_class(
          button,
          "text-opacity-[0.5]",
          /*calendarDay*/
          ctx[56].month() !== /*browseDate*/
          ctx[8].month()
        );
      }
      if (dirty[0] & /*calendarDays, browseDate*/
      1280) {
        toggle_class(
          button,
          "text-content",
          /*calendarDay*/
          ctx[56].month() === /*browseDate*/
          ctx[8].month()
        );
      }
      if (dirty[0] & /*dayIsInRange, calendarDays, value*/
      263169) {
        toggle_class(
          button,
          "hover:bg-hover",
          /*dayIsInRange*/
          ctx[18](
            /*calendarDay*/
            ctx[56]
          ) && !/*calendarDay*/
          ctx[56].isSame(
            /*value*/
            ctx[0],
            "date"
          )
        );
      }
      if (dirty[0] & /*dayIsInRange, calendarDays, value*/
      263169) {
        toggle_class(
          button,
          "hover:bg-opacity-[0.07]",
          /*dayIsInRange*/
          ctx[18](
            /*calendarDay*/
            ctx[56]
          ) && !/*calendarDay*/
          ctx[56].isSame(
            /*value*/
            ctx[0],
            "date"
          )
        );
      }
      if (dirty[0] & /*calendarDays, browseDate, value*/
      1281) {
        toggle_class(
          button,
          "bg-hover",
          /*calendarDay*/
          ctx[56].isSame(
            /*browseDate*/
            ctx[8],
            "date"
          ) && !/*calendarDay*/
          ctx[56].isSame(
            /*value*/
            ctx[0],
            "date"
          )
        );
      }
      if (dirty[0] & /*calendarDays, browseDate, value*/
      1281) {
        toggle_class(
          button,
          "bg-opacity-[0.07]",
          /*calendarDay*/
          ctx[56].isSame(
            /*browseDate*/
            ctx[8],
            "date"
          ) && !/*calendarDay*/
          ctx[56].isSame(
            /*value*/
            ctx[0],
            "date"
          )
        );
      }
      if (dirty[0] & /*calendarDays, defaultDate, value*/
      17409) {
        toggle_class(
          button,
          "border",
          /*calendarDay*/
          ctx[56].isSame(
            /*defaultDate*/
            ctx[14],
            "day"
          ) && !/*calendarDay*/
          ctx[56].isSame(
            /*value*/
            ctx[0],
            "date"
          )
        );
      }
      if (dirty[0] & /*calendarDays, defaultDate, value*/
      17409) {
        toggle_class(
          button,
          "border-primary",
          /*calendarDay*/
          ctx[56].isSame(
            /*defaultDate*/
            ctx[14],
            "day"
          ) && !/*calendarDay*/
          ctx[56].isSame(
            /*value*/
            ctx[0],
            "date"
          )
        );
      }
      if (dirty[0] & /*calendarDays, value*/
      1025) {
        toggle_class(
          button,
          "bg-primary",
          /*calendarDay*/
          ctx[56].isSame(
            /*value*/
            ctx[0],
            "date"
          )
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4$d(ctx) {
  let span1;
  let span0;
  let t_value = (
    /*calendarDay*/
    ctx[56].date() + ""
  );
  let t2;
  return {
    c() {
      span1 = element("span");
      span0 = element("span");
      t2 = text(t_value);
      this.h();
    },
    l(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", {});
      var span0_nodes = children(span0);
      t2 = claim_text(span0_nodes, t_value);
      span0_nodes.forEach(detach);
      span1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span1, "class", "inactive w-10 flex items-center justify-center h-10 rounded-none bg-default first-of-type:rounded-l-3xl last-of-type:rounded-r-3xl svelte-1xzgw24");
    },
    m(target, anchor) {
      insert_hydration(target, span1, anchor);
      append_hydration(span1, span0);
      append_hydration(span0, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*calendarDays*/
      1024 && t_value !== (t_value = /*calendarDay*/
      ctx2[56].date() + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
    }
  };
}
function create_each_block_2$1(ctx) {
  let show_if;
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (dirty[0] & /*calendarDays*/
    1024)
      show_if = null;
    if (show_if == null)
      show_if = !!!/*dayIsInRange*/
      ctx2[18](
        /*calendarDay*/
        ctx2[56]
      );
    if (show_if)
      return create_if_block_4$d;
    return create_else_block$h;
  }
  let current_block_type = select_block_type_1(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_each_block_1$4(ctx) {
  let div2;
  let t2;
  let each_value_2 = ensure_array_like(
    /*calendarDays*/
    ctx[10].slice(
      /*weekIndex*/
      ctx[55] * 7,
      /*weekIndex*/
      ctx[55] * 7 + 7
    )
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i2));
  }
  return {
    c() {
      div2 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t2 = space();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(div_nodes);
      }
      t2 = claim_space(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "date-container flex items-center justify-evenly h-[20%] svelte-1xzgw24");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div2, null);
        }
      }
      append_hydration(div2, t2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*calendarDays, dayIsInRange, iLocale, browseDate, value, defaultDate, selectDay*/
      443649) {
        each_value_2 = ensure_array_like(
          /*calendarDays*/
          ctx2[10].slice(
            /*weekIndex*/
            ctx2[55] * 7,
            /*weekIndex*/
            ctx2[55] * 7 + 7
          )
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$1(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_2$1(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div2, t2);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_key_block$2(ctx) {
  let div2;
  let div_intro;
  let div_outro;
  let current;
  let each_value_1 = ensure_array_like(Array(5));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i2));
  }
  return {
    c() {
      div2 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(div_nodes);
      }
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "absolute inset-0 p-3 h-full");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div2, null);
        }
      }
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*calendarDays, dayIsInRange, iLocale, browseDate, value, defaultDate, selectDay*/
      443649) {
        each_value_1 = ensure_array_like(Array(5));
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$4(ctx, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$4(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div2, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div_outro)
            div_outro.end(1);
          div_intro = create_in_transition(div2, fly, {
            x: (
              /*transitionDirection*/
              ctx[9] === "forward" ? 250 : -250
            ),
            duration: 250
          });
          div_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(div2, fly, {
          x: (
            /*transitionDirection*/
            ctx[9] === "forward" ? -250 : 250
          ),
          duration: 250
        });
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
      if (detaching && div_outro)
        div_outro.end();
    }
  };
}
function create_if_block_3$i(ctx) {
  let timepicker;
  let updating_hourSelected;
  let updating_minuteSelected;
  let updating_meridianSelected;
  let updating_browseDate;
  let updating_closeOnSelect;
  let current;
  function timepicker_hourSelected_binding(value) {
    ctx[33](value);
  }
  function timepicker_minuteSelected_binding(value) {
    ctx[34](value);
  }
  function timepicker_meridianSelected_binding(value) {
    ctx[35](value);
  }
  function timepicker_browseDate_binding(value) {
    ctx[36](value);
  }
  function timepicker_closeOnSelect_binding(value) {
    ctx[37](value);
  }
  let timepicker_props = {
    step: (
      /*step*/
      ctx[4]
    ),
    showTime: (
      /*showTime*/
      ctx[3]
    ),
    setValue: (
      /*setValue*/
      ctx[16]
    ),
    handleSelect: (
      /*handleSelect*/
      ctx[2]
    ),
    format: (
      /*format*/
      ctx[6]
    )
  };
  if (
    /*hourSelected*/
    ctx[11] !== void 0
  ) {
    timepicker_props.hourSelected = /*hourSelected*/
    ctx[11];
  }
  if (
    /*minuteSelected*/
    ctx[12] !== void 0
  ) {
    timepicker_props.minuteSelected = /*minuteSelected*/
    ctx[12];
  }
  if (
    /*meridianSelected*/
    ctx[13] !== void 0
  ) {
    timepicker_props.meridianSelected = /*meridianSelected*/
    ctx[13];
  }
  if (
    /*browseDate*/
    ctx[8] !== void 0
  ) {
    timepicker_props.browseDate = /*browseDate*/
    ctx[8];
  }
  if (
    /*closeOnSelect*/
    ctx[1] !== void 0
  ) {
    timepicker_props.closeOnSelect = /*closeOnSelect*/
    ctx[1];
  }
  timepicker = new TimePicker({ props: timepicker_props });
  binding_callbacks.push(() => bind(timepicker, "hourSelected", timepicker_hourSelected_binding));
  binding_callbacks.push(() => bind(timepicker, "minuteSelected", timepicker_minuteSelected_binding));
  binding_callbacks.push(() => bind(timepicker, "meridianSelected", timepicker_meridianSelected_binding));
  binding_callbacks.push(() => bind(timepicker, "browseDate", timepicker_browseDate_binding));
  binding_callbacks.push(() => bind(timepicker, "closeOnSelect", timepicker_closeOnSelect_binding));
  return {
    c() {
      create_component(timepicker.$$.fragment);
    },
    l(nodes) {
      claim_component(timepicker.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(timepicker, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const timepicker_changes = {};
      if (dirty[0] & /*step*/
      16)
        timepicker_changes.step = /*step*/
        ctx2[4];
      if (dirty[0] & /*showTime*/
      8)
        timepicker_changes.showTime = /*showTime*/
        ctx2[3];
      if (dirty[0] & /*handleSelect*/
      4)
        timepicker_changes.handleSelect = /*handleSelect*/
        ctx2[2];
      if (dirty[0] & /*format*/
      64)
        timepicker_changes.format = /*format*/
        ctx2[6];
      if (!updating_hourSelected && dirty[0] & /*hourSelected*/
      2048) {
        updating_hourSelected = true;
        timepicker_changes.hourSelected = /*hourSelected*/
        ctx2[11];
        add_flush_callback(() => updating_hourSelected = false);
      }
      if (!updating_minuteSelected && dirty[0] & /*minuteSelected*/
      4096) {
        updating_minuteSelected = true;
        timepicker_changes.minuteSelected = /*minuteSelected*/
        ctx2[12];
        add_flush_callback(() => updating_minuteSelected = false);
      }
      if (!updating_meridianSelected && dirty[0] & /*meridianSelected*/
      8192) {
        updating_meridianSelected = true;
        timepicker_changes.meridianSelected = /*meridianSelected*/
        ctx2[13];
        add_flush_callback(() => updating_meridianSelected = false);
      }
      if (!updating_browseDate && dirty[0] & /*browseDate*/
      256) {
        updating_browseDate = true;
        timepicker_changes.browseDate = /*browseDate*/
        ctx2[8];
        add_flush_callback(() => updating_browseDate = false);
      }
      if (!updating_closeOnSelect && dirty[0] & /*closeOnSelect*/
      2) {
        updating_closeOnSelect = true;
        timepicker_changes.closeOnSelect = /*closeOnSelect*/
        ctx2[1];
        add_flush_callback(() => updating_closeOnSelect = false);
      }
      timepicker.$set(timepicker_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(timepicker.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(timepicker.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(timepicker, detaching);
    }
  };
}
function create_if_block_2$j(ctx) {
  let div2;
  let timepicker;
  let updating_hourSelected;
  let updating_minuteSelected;
  let updating_meridianSelected;
  let updating_browseDate;
  let updating_closeOnSelect;
  let current;
  function timepicker_hourSelected_binding_1(value) {
    ctx[38](value);
  }
  function timepicker_minuteSelected_binding_1(value) {
    ctx[39](value);
  }
  function timepicker_meridianSelected_binding_1(value) {
    ctx[40](value);
  }
  function timepicker_browseDate_binding_1(value) {
    ctx[41](value);
  }
  function timepicker_closeOnSelect_binding_1(value) {
    ctx[42](value);
  }
  let timepicker_props = {
    step: (
      /*step*/
      ctx[4]
    ),
    showTime: (
      /*showTime*/
      ctx[3]
    ),
    setValue: (
      /*setValue*/
      ctx[16]
    ),
    handleSelect: (
      /*handleSelect*/
      ctx[2]
    ),
    format: (
      /*format*/
      ctx[6]
    ),
    mobile: true
  };
  if (
    /*hourSelected*/
    ctx[11] !== void 0
  ) {
    timepicker_props.hourSelected = /*hourSelected*/
    ctx[11];
  }
  if (
    /*minuteSelected*/
    ctx[12] !== void 0
  ) {
    timepicker_props.minuteSelected = /*minuteSelected*/
    ctx[12];
  }
  if (
    /*meridianSelected*/
    ctx[13] !== void 0
  ) {
    timepicker_props.meridianSelected = /*meridianSelected*/
    ctx[13];
  }
  if (
    /*browseDate*/
    ctx[8] !== void 0
  ) {
    timepicker_props.browseDate = /*browseDate*/
    ctx[8];
  }
  if (
    /*closeOnSelect*/
    ctx[1] !== void 0
  ) {
    timepicker_props.closeOnSelect = /*closeOnSelect*/
    ctx[1];
  }
  timepicker = new TimePicker({ props: timepicker_props });
  binding_callbacks.push(() => bind(timepicker, "hourSelected", timepicker_hourSelected_binding_1));
  binding_callbacks.push(() => bind(timepicker, "minuteSelected", timepicker_minuteSelected_binding_1));
  binding_callbacks.push(() => bind(timepicker, "meridianSelected", timepicker_meridianSelected_binding_1));
  binding_callbacks.push(() => bind(timepicker, "browseDate", timepicker_browseDate_binding_1));
  binding_callbacks.push(() => bind(timepicker, "closeOnSelect", timepicker_closeOnSelect_binding_1));
  return {
    c() {
      div2 = element("div");
      create_component(timepicker.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      claim_component(timepicker.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "gap-3 flex items-center justify-evenly w-full border-t border-border");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(timepicker, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const timepicker_changes = {};
      if (dirty[0] & /*step*/
      16)
        timepicker_changes.step = /*step*/
        ctx2[4];
      if (dirty[0] & /*showTime*/
      8)
        timepicker_changes.showTime = /*showTime*/
        ctx2[3];
      if (dirty[0] & /*handleSelect*/
      4)
        timepicker_changes.handleSelect = /*handleSelect*/
        ctx2[2];
      if (dirty[0] & /*format*/
      64)
        timepicker_changes.format = /*format*/
        ctx2[6];
      if (!updating_hourSelected && dirty[0] & /*hourSelected*/
      2048) {
        updating_hourSelected = true;
        timepicker_changes.hourSelected = /*hourSelected*/
        ctx2[11];
        add_flush_callback(() => updating_hourSelected = false);
      }
      if (!updating_minuteSelected && dirty[0] & /*minuteSelected*/
      4096) {
        updating_minuteSelected = true;
        timepicker_changes.minuteSelected = /*minuteSelected*/
        ctx2[12];
        add_flush_callback(() => updating_minuteSelected = false);
      }
      if (!updating_meridianSelected && dirty[0] & /*meridianSelected*/
      8192) {
        updating_meridianSelected = true;
        timepicker_changes.meridianSelected = /*meridianSelected*/
        ctx2[13];
        add_flush_callback(() => updating_meridianSelected = false);
      }
      if (!updating_browseDate && dirty[0] & /*browseDate*/
      256) {
        updating_browseDate = true;
        timepicker_changes.browseDate = /*browseDate*/
        ctx2[8];
        add_flush_callback(() => updating_browseDate = false);
      }
      if (!updating_closeOnSelect && dirty[0] & /*closeOnSelect*/
      2) {
        updating_closeOnSelect = true;
        timepicker_changes.closeOnSelect = /*closeOnSelect*/
        ctx2[1];
        add_flush_callback(() => updating_closeOnSelect = false);
      }
      timepicker.$set(timepicker_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(timepicker.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(timepicker.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(timepicker);
    }
  };
}
function create_if_block_1$v(ctx) {
  let div2;
  let current;
  let each_value = ensure_array_like(
    /*actions*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$b(get_each_context$b(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div2 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(div_nodes);
      }
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "px-3 pt-3 pb-3 gap-3 flex items-center justify-start w-full border-t border-border overflow-x-auto overflow-y-hidden");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div2, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actions*/
      32) {
        each_value = ensure_array_like(
          /*actions*/
          ctx2[5]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$b(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$b(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div2, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_3$6(ctx) {
  let t_value = (
    /*action*/
    ctx[50].label + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    l(nodes) {
      t2 = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actions*/
      32 && t_value !== (t_value = /*action*/
      ctx2[50].label + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_each_block$b(ctx) {
  let button;
  let current;
  button = new Button$1({
    props: {
      size: "sm",
      type: "primary",
      shape: "pill",
      class: "bg-default text-default-content",
      $$slots: { default: [create_default_slot_3$6] },
      $$scope: { ctx }
    }
  });
  button.$on("click", function() {
    if (is_function(
      /*action*/
      ctx[50].action
    ))
      ctx[50].action.apply(this, arguments);
  });
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty[0] & /*actions*/
      32 | dirty[1] & /*$$scope*/
      1073741824) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_if_block$J(ctx) {
  let div2;
  let button0;
  let t2;
  let button1;
  let current;
  button0 = new Button$1({
    props: {
      class: "w-full bg-default text-default-content",
      $$slots: { default: [create_default_slot_2$8] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*handleCancel*/
    ctx[22]
  );
  button1 = new Button$1({
    props: {
      type: "primary",
      class: "w-full",
      $$slots: { default: [create_default_slot_1$a] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*handleApply*/
    ctx[21]
  );
  return {
    c() {
      div2 = element("div");
      create_component(button0.$$.fragment);
      t2 = space();
      create_component(button1.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      claim_component(button0.$$.fragment, div_nodes);
      t2 = claim_space(div_nodes);
      claim_component(button1.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "p-3 gap-3 flex items-center justify-evenly w-full border-t border-border");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(button0, div2, null);
      append_hydration(div2, t2);
      mount_component(button1, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(button0);
      destroy_component(button1);
    }
  };
}
function create_default_slot_2$8(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Clear");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Clear");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_1$a(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Apply");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Apply");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot$e(ctx) {
  let div7;
  let div2;
  let button0;
  let t0;
  let button1;
  let t1;
  let div1;
  let div0;
  let t2_value = (
    /*iLocale*/
    ctx[15].months[
      /*browseDate*/
      ctx[8].month()
    ] + ""
  );
  let t2;
  let t3;
  let t4_value = (
    /*browseDate*/
    ctx[8].year() + ""
  );
  let t4;
  let t5;
  let button2;
  let t6;
  let button3;
  let t7;
  let div6;
  let div5;
  let div3;
  let t8;
  let div4;
  let previous_key = (
    /*calendarDays*/
    ctx[10]
  );
  let t9;
  let t10;
  let t11;
  let t12;
  let current;
  button0 = new Button$1({
    props: {
      ariaLabel: "previous year",
      size: "xs",
      shape: "circle",
      tabindex: "-1",
      class: "mr-1 bg-default text-default-content border-none outline-none",
      $$slots: { default: [create_default_slot_7$1] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*click_handler*/
    ctx[28]
  );
  button1 = new Button$1({
    props: {
      ariaLabel: "previous month",
      size: "xs",
      shape: "circle",
      tabindex: "-1",
      class: "bg-default text-default-content border-none outline-none",
      $$slots: { default: [create_default_slot_6$1] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*click_handler_1*/
    ctx[29]
  );
  button2 = new Button$1({
    props: {
      ariaLabel: "next month",
      size: "xs",
      shape: "circle",
      tabindex: "-1",
      class: "bg-default text-default-content border-none outline-none",
      $$slots: { default: [create_default_slot_5$2] },
      $$scope: { ctx }
    }
  });
  button2.$on(
    "click",
    /*click_handler_2*/
    ctx[30]
  );
  button3 = new Button$1({
    props: {
      ariaLabel: "next month",
      size: "xs",
      shape: "circle",
      tabindex: "-1",
      class: "ml-1 bg-default text-default-content border-none outline-none",
      $$slots: { default: [create_default_slot_4$4] },
      $$scope: { ctx }
    }
  });
  button3.$on(
    "click",
    /*click_handler_3*/
    ctx[31]
  );
  let each_value_3 = ensure_array_like(Array(7));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    each_blocks[i2] = create_each_block_3(get_each_context_3(ctx, each_value_3, i2));
  }
  let key_block = create_key_block$2(ctx);
  let if_block0 = (
    /*showTime*/
    ctx[3] && !/*mobile*/
    ctx[7] && create_if_block_3$i(ctx)
  );
  let if_block1 = (
    /*showTime*/
    ctx[3] && /*mobile*/
    ctx[7] && create_if_block_2$j(ctx)
  );
  let if_block2 = (
    /*actions*/
    ctx[5].length > 0 && create_if_block_1$v(ctx)
  );
  let if_block3 = (
    /*showTime*/
    (ctx[3] || !/*closeOnSelect*/
    ctx[1]) && create_if_block$J(ctx)
  );
  return {
    c() {
      div7 = element("div");
      div2 = element("div");
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      div1 = element("div");
      div0 = element("div");
      t2 = text(t2_value);
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      create_component(button2.$$.fragment);
      t6 = space();
      create_component(button3.$$.fragment);
      t7 = space();
      div6 = element("div");
      div5 = element("div");
      div3 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t8 = space();
      div4 = element("div");
      key_block.c();
      t9 = space();
      if (if_block0)
        if_block0.c();
      t10 = space();
      if (if_block1)
        if_block1.c();
      t11 = space();
      if (if_block2)
        if_block2.c();
      t12 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l(nodes) {
      div7 = claim_element(nodes, "DIV", { class: true });
      var div7_nodes = children(div7);
      div2 = claim_element(div7_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      claim_component(button0.$$.fragment, div2_nodes);
      t0 = claim_space(div2_nodes);
      claim_component(button1.$$.fragment, div2_nodes);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t2 = claim_text(div0_nodes, t2_value);
      t3 = claim_space(div0_nodes);
      t4 = claim_text(div0_nodes, t4_value);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      t5 = claim_space(div2_nodes);
      claim_component(button2.$$.fragment, div2_nodes);
      t6 = claim_space(div2_nodes);
      claim_component(button3.$$.fragment, div2_nodes);
      div2_nodes.forEach(detach);
      t7 = claim_space(div7_nodes);
      div6 = claim_element(div7_nodes, "DIV", { class: true });
      var div6_nodes = children(div6);
      div5 = claim_element(div6_nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      div3 = claim_element(div5_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(div3_nodes);
      }
      div3_nodes.forEach(detach);
      t8 = claim_space(div5_nodes);
      div4 = claim_element(div5_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      key_block.l(div4_nodes);
      div4_nodes.forEach(detach);
      div5_nodes.forEach(detach);
      t9 = claim_space(div6_nodes);
      if (if_block0)
        if_block0.l(div6_nodes);
      div6_nodes.forEach(detach);
      t10 = claim_space(div7_nodes);
      if (if_block1)
        if_block1.l(div7_nodes);
      t11 = claim_space(div7_nodes);
      if (if_block2)
        if_block2.l(div7_nodes);
      t12 = claim_space(div7_nodes);
      if (if_block3)
        if_block3.l(div7_nodes);
      div7_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "absolute inset-0 flex items-center justify-center text-content");
      attr(div1, "class", "flex-grow px-2 text-center font-medium relative overflow-hidden h-full");
      attr(div2, "class", "h-14 px-3 py-2 flex items-center w-full");
      attr(div3, "class", "h-8 flex items-center justify-evenly px-3 pt-3 w-full");
      attr(div4, "class", "overflow-hidden h-[calc(100%-2rem)] relative w-full");
      attr(div5, "class", "flex-grow border-r border-border h-full");
      attr(div6, "class", "w-full overflow-hidden flex flex-row border-t border-border flex-grow");
      toggle_class(
        div6,
        "h-[calc(100%-3.5rem)]",
        /*mobile*/
        ctx[7]
      );
      toggle_class(div6, "h-[254px]", !/*mobile*/
      ctx[7]);
      toggle_class(div6, "max-h-[254px]", !/*mobile*/
      ctx[7]);
      toggle_class(div6, "max-w-[300px]", !/*mobile*/
      ctx[7] && !/*showTime*/
      ctx[3]);
      toggle_class(div6, "max-w-[468px]", !/*mobile*/
      ctx[7] && /*showTime*/
      ctx[3]);
      attr(div7, "class", "h-full flex flex-col");
      toggle_class(
        div7,
        "w-full",
        /*mobile*/
        ctx[7]
      );
      toggle_class(div7, "w-[300px]", !/*mobile*/
      ctx[7] && (!/*showTime*/
      ctx[3] || /*showTime*/
      ctx[3]));
      toggle_class(div7, "max-w-[300px]", !/*mobile*/
      ctx[7] && (!/*showTime*/
      ctx[3] || /*showTime*/
      ctx[3]));
      toggle_class(div7, "w-[468px]", !/*mobile*/
      ctx[7] && /*showTime*/
      ctx[3]);
      toggle_class(div7, "max-w-[468px]", !/*mobile*/
      ctx[7] && /*showTime*/
      ctx[3]);
    },
    m(target, anchor) {
      insert_hydration(target, div7, anchor);
      append_hydration(div7, div2);
      mount_component(button0, div2, null);
      append_hydration(div2, t0);
      mount_component(button1, div2, null);
      append_hydration(div2, t1);
      append_hydration(div2, div1);
      append_hydration(div1, div0);
      append_hydration(div0, t2);
      append_hydration(div0, t3);
      append_hydration(div0, t4);
      append_hydration(div2, t5);
      mount_component(button2, div2, null);
      append_hydration(div2, t6);
      mount_component(button3, div2, null);
      append_hydration(div7, t7);
      append_hydration(div7, div6);
      append_hydration(div6, div5);
      append_hydration(div5, div3);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div3, null);
        }
      }
      append_hydration(div5, t8);
      append_hydration(div5, div4);
      key_block.m(div4, null);
      append_hydration(div6, t9);
      if (if_block0)
        if_block0.m(div6, null);
      append_hydration(div7, t10);
      if (if_block1)
        if_block1.m(div7, null);
      append_hydration(div7, t11);
      if (if_block2)
        if_block2.m(div7, null);
      append_hydration(div7, t12);
      if (if_block3)
        if_block3.m(div7, null);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      if ((!current || dirty[0] & /*browseDate*/
      256) && t2_value !== (t2_value = /*iLocale*/
      ctx2[15].months[
        /*browseDate*/
        ctx2[8].month()
      ] + ""))
        set_data(t2, t2_value);
      if ((!current || dirty[0] & /*browseDate*/
      256) && t4_value !== (t4_value = /*browseDate*/
      ctx2[8].year() + ""))
        set_data(t4, t4_value);
      const button2_changes = {};
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
      const button3_changes = {};
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button3_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button3.$set(button3_changes);
      if (dirty[0] & /*iLocale*/
      32768) {
        each_value_3 = ensure_array_like(Array(7));
        let i2;
        for (i2 = 0; i2 < each_value_3.length; i2 += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_3(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div3, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_3.length;
      }
      if (dirty[0] & /*calendarDays*/
      1024 && safe_not_equal(previous_key, previous_key = /*calendarDays*/
      ctx2[10])) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block$2(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div4, null);
      } else {
        key_block.p(ctx2, dirty);
      }
      if (
        /*showTime*/
        ctx2[3] && !/*mobile*/
        ctx2[7]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*showTime, mobile*/
          136) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3$i(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div6, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*mobile*/
      128) {
        toggle_class(
          div6,
          "h-[calc(100%-3.5rem)]",
          /*mobile*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*mobile*/
      128) {
        toggle_class(div6, "h-[254px]", !/*mobile*/
        ctx2[7]);
      }
      if (!current || dirty[0] & /*mobile*/
      128) {
        toggle_class(div6, "max-h-[254px]", !/*mobile*/
        ctx2[7]);
      }
      if (!current || dirty[0] & /*mobile, showTime*/
      136) {
        toggle_class(div6, "max-w-[300px]", !/*mobile*/
        ctx2[7] && !/*showTime*/
        ctx2[3]);
      }
      if (!current || dirty[0] & /*mobile, showTime*/
      136) {
        toggle_class(div6, "max-w-[468px]", !/*mobile*/
        ctx2[7] && /*showTime*/
        ctx2[3]);
      }
      if (
        /*showTime*/
        ctx2[3] && /*mobile*/
        ctx2[7]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*showTime, mobile*/
          136) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$j(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div7, t11);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*actions*/
        ctx2[5].length > 0
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*actions*/
          32) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$v(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div7, t12);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*showTime*/
        ctx2[3] || !/*closeOnSelect*/
        ctx2[1]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*showTime, closeOnSelect*/
          10) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$J(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div7, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*mobile*/
      128) {
        toggle_class(
          div7,
          "w-full",
          /*mobile*/
          ctx2[7]
        );
      }
      if (!current || dirty[0] & /*mobile, showTime*/
      136) {
        toggle_class(div7, "w-[300px]", !/*mobile*/
        ctx2[7] && (!/*showTime*/
        ctx2[3] || /*showTime*/
        ctx2[3]));
      }
      if (!current || dirty[0] & /*mobile, showTime*/
      136) {
        toggle_class(div7, "max-w-[300px]", !/*mobile*/
        ctx2[7] && (!/*showTime*/
        ctx2[3] || /*showTime*/
        ctx2[3]));
      }
      if (!current || dirty[0] & /*mobile, showTime*/
      136) {
        toggle_class(div7, "w-[468px]", !/*mobile*/
        ctx2[7] && /*showTime*/
        ctx2[3]);
      }
      if (!current || dirty[0] & /*mobile, showTime*/
      136) {
        toggle_class(div7, "max-w-[468px]", !/*mobile*/
        ctx2[7] && /*showTime*/
        ctx2[3]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      transition_in(key_block);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      transition_out(key_block);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div7);
      }
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button2);
      destroy_component(button3);
      destroy_each(each_blocks, detaching);
      key_block.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
    }
  };
}
function create_fragment$25(ctx) {
  let card;
  let current;
  let mounted;
  let dispose;
  card = new Card({
    props: {
      tabindex: "-1",
      class: "h-full",
      $$slots: { default: [create_default_slot$e] },
      $$scope: { ctx }
    }
  });
  card.$on(
    "focusout",
    /*focusout_handler*/
    ctx[43]
  );
  return {
    c() {
      create_component(card.$$.fragment);
    },
    l(nodes) {
      claim_component(card.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(card, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          window,
          "keydown",
          /*keydown*/
          ctx[19]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const card_changes = {};
      if (dirty[0] & /*mobile, showTime, closeOnSelect, actions, step, handleSelect, format, hourSelected, minuteSelected, meridianSelected, browseDate, calendarDays, transitionDirection, value*/
      16383 | dirty[1] & /*$$scope*/
      1073741824) {
        card_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(card, detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$23($$self, $$props, $$invalidate) {
  let { value = null } = $$props;
  let { handleSelect } = $$props;
  let { min: min2 = void 0 } = $$props;
  let { max: max2 = void 0 } = $$props;
  let { locale: locale2 = {} } = $$props;
  let { closeOnSelect = true } = $$props;
  let { showTime = false } = $$props;
  let { step } = $$props;
  let { handleClose } = $$props;
  let { handleClear } = $$props;
  let { actions = [] } = $$props;
  let { format: format2 } = $$props;
  let { mobile = false } = $$props;
  const defaultDate = dayjs();
  let browseDate = value ? value : defaultDate;
  let transitionDirection = "forward";
  let iLocale = getInnerLocale(locale2);
  let calendarDays = [];
  let hourSelected;
  let minuteSelected;
  let meridianSelected;
  function setValue(d3) {
    if (!dayjs(d3).isSame(value, "day")) {
      $$invalidate(8, browseDate = clamp(d3));
      $$invalidate(0, value = browseDate);
    }
  }
  function browse(d3) {
    $$invalidate(8, browseDate = clamp(d3));
    if (value) {
      setValue(browseDate);
    }
  }
  function clamp(d3) {
    if (max2 && d3.isAfter(max2)) {
      return max2;
    } else if (min2 && d3.isBefore(min2)) {
      return min2;
    } else {
      return d3;
    }
  }
  function setYear(date, operation) {
    $$invalidate(8, browseDate = browseDate[operation](1, "year"));
    browse(browseDate);
    if (operation === "add") {
      $$invalidate(9, transitionDirection = "forward");
    } else {
      $$invalidate(9, transitionDirection = "reverse");
    }
    updateCalendarDays();
  }
  function setMonth(date, operation) {
    $$invalidate(8, browseDate = browseDate[operation](1, "month"));
    browse(browseDate);
    if (operation === "add") {
      $$invalidate(9, transitionDirection = "forward");
    } else {
      $$invalidate(9, transitionDirection = "reverse");
    }
    updateCalendarDays();
  }
  function updateCalendarDays() {
    $$invalidate(10, calendarDays = getCalendarDays(browseDate, iLocale.weekStartsOn));
  }
  function selectDay(calendarDay) {
    if (dayIsInRange(calendarDay)) {
      const currentMonth = browseDate.month();
      $$invalidate(8, browseDate = calendarDay);
      const newMonth = browseDate.month();
      if (currentMonth !== newMonth) {
        if (currentMonth === 0 && newMonth === 11) {
          $$invalidate(9, transitionDirection = "reverse");
        } else if (currentMonth === 11 && newMonth === 0) {
          $$invalidate(9, transitionDirection = "forward");
        } else if (currentMonth < newMonth) {
          $$invalidate(9, transitionDirection = "forward");
        } else {
          $$invalidate(9, transitionDirection = "reverse");
        }
        updateCalendarDays();
      }
      if (showTime) {
        if (format2.includes("H")) {
          $$invalidate(8, browseDate = browseDate.set("hour", parseInt(hourSelected)).set("minute", parseInt(minuteSelected)));
        } else if (meridianSelected === "AM") {
          $$invalidate(8, browseDate = browseDate.set("hour", parseInt(hourSelected)).set("minute", parseInt(minuteSelected)));
        } else {
          const hour = parseInt(hourSelected) + 12;
          $$invalidate(8, browseDate = browseDate.set("hour", hour).set("minute", parseInt(minuteSelected)));
        }
      }
      setValue(browseDate);
      handleSelect(browseDate);
    }
  }
  function dayIsInRange(calendarDay) {
    const minDate = min2 ? min2 : void 0;
    const maxDate = max2 ? max2 : void 0;
    if (!minDate && !maxDate) {
      return true;
    }
    if (minDate && maxDate) {
      return calendarDay.isAfter(minDate) && calendarDay.isBefore(maxDate);
    } else if (minDate) {
      return calendarDay.isAfter(minDate);
    } else if (maxDate) {
      return calendarDay.isBefore(maxDate);
    }
    return true;
  }
  function shiftKeydown(e2) {
    if (e2.shiftKey && e2.key === "ArrowUp") {
      const newBrowseDate = browseDate.subtract(1, "year");
      if (dayIsInRange(newBrowseDate)) {
        setYear(browseDate, "subtract");
        $$invalidate(9, transitionDirection = "reverse");
      }
    } else if (e2.shiftKey && e2.key === "ArrowDown") {
      const newBrowseDate = browseDate.add(
        1,
        "year"
      );
      if (dayIsInRange(newBrowseDate)) {
        setYear(browseDate, "add");
        $$invalidate(9, transitionDirection = "forward");
      }
    } else if (e2.shiftKey && e2.key === "ArrowLeft") {
      const newBrowseDate = browseDate.subtract(
        1,
        "month"
      );
      if (dayIsInRange(newBrowseDate)) {
        setMonth(browseDate, "subtract");
        $$invalidate(9, transitionDirection = "reverse");
      }
    } else if (e2.shiftKey && e2.key === "ArrowRight") {
      const newBrowseDate = browseDate.add(
        1,
        "month"
      );
      if (dayIsInRange(newBrowseDate)) {
        setMonth(browseDate, "add");
        $$invalidate(9, transitionDirection = "forward");
      }
    } else {
      return false;
    }
    updateCalendarDays();
    return true;
  }
  function keydown(e2) {
    var _a2;
    e2.preventDefault();
    e2.stopPropagation();
    let shift = e2.shiftKey || e2.altKey;
    if (((_a2 = e2.target) == null ? void 0 : _a2.tagName) === "SELECT") {
      return;
    }
    const currentMonth = browseDate.month();
    if (shift) {
      shiftKeydown(e2);
      return;
    } else if (e2.key === "ArrowUp") {
      const newBrowseDate = browseDate.subtract(7, "days");
      if (dayIsInRange(newBrowseDate)) {
        $$invalidate(8, browseDate = newBrowseDate);
        setValue(browseDate);
        $$invalidate(9, transitionDirection = "reverse");
      }
    } else if (e2.key === "ArrowDown") {
      const newBrowseDate = browseDate.add(
        7,
        "days"
      );
      if (dayIsInRange(newBrowseDate)) {
        $$invalidate(8, browseDate = browseDate.add(7, "days"));
        $$invalidate(9, transitionDirection = "forward");
        setValue(browseDate);
      }
    } else if (e2.key === "ArrowLeft") {
      const newBrowseDate = browseDate.subtract(
        1,
        "days"
      );
      if (dayIsInRange(newBrowseDate)) {
        $$invalidate(8, browseDate = browseDate.subtract(1, "day"));
        $$invalidate(9, transitionDirection = "reverse");
        setValue(browseDate);
      }
    } else if (e2.key === "ArrowRight") {
      console.log(
        "DatePicker ArrowRight"
      );
      const newBrowseDate = browseDate.add(1, "days");
      if (dayIsInRange(newBrowseDate)) {
        $$invalidate(8, browseDate = browseDate.add(1, "day"));
        $$invalidate(9, transitionDirection = "forward");
        setValue(browseDate);
      }
    } else if (e2.key === "Enter") {
      $$invalidate(
        8,
        browseDate
      );
      setValue(browseDate);
      handleSelect(browseDate);
    } else {
      return;
    }
    if (currentMonth !== browseDate.month()) {
      updateCalendarDays();
    }
  }
  function handleArrow(unit, operation) {
    if (unit === "year") {
      const newBrowseDate = browseDate[operation](1, "year");
      if (dayIsInRange(newBrowseDate)) {
        setYear(browseDate, operation);
      }
    } else if (unit === "month") {
      const newBrowseDate = browseDate[operation](1, "month");
      if (dayIsInRange(newBrowseDate)) {
        setMonth(browseDate, operation);
      }
    }
  }
  updateCalendarDays();
  function handleApply() {
    handleSelect(browseDate);
    handleClose();
  }
  function handleCancel() {
    $$invalidate(0, value = null);
    handleClear();
    handleClose();
  }
  const click_handler = () => handleArrow("year", "subtract");
  const click_handler_1 = () => handleArrow("month", "subtract");
  const click_handler_2 = () => handleArrow("month", "add");
  const click_handler_3 = () => handleArrow("year", "add");
  const click_handler_4 = (calendarDay) => selectDay(calendarDay);
  function timepicker_hourSelected_binding(value2) {
    hourSelected = value2;
    $$invalidate(11, hourSelected);
  }
  function timepicker_minuteSelected_binding(value2) {
    minuteSelected = value2;
    $$invalidate(12, minuteSelected);
  }
  function timepicker_meridianSelected_binding(value2) {
    meridianSelected = value2;
    $$invalidate(13, meridianSelected);
  }
  function timepicker_browseDate_binding(value2) {
    browseDate = value2;
    $$invalidate(8, browseDate);
  }
  function timepicker_closeOnSelect_binding(value2) {
    closeOnSelect = value2;
    $$invalidate(1, closeOnSelect);
  }
  function timepicker_hourSelected_binding_1(value2) {
    hourSelected = value2;
    $$invalidate(11, hourSelected);
  }
  function timepicker_minuteSelected_binding_1(value2) {
    minuteSelected = value2;
    $$invalidate(12, minuteSelected);
  }
  function timepicker_meridianSelected_binding_1(value2) {
    meridianSelected = value2;
    $$invalidate(13, meridianSelected);
  }
  function timepicker_browseDate_binding_1(value2) {
    browseDate = value2;
    $$invalidate(8, browseDate);
  }
  function timepicker_closeOnSelect_binding_1(value2) {
    closeOnSelect = value2;
    $$invalidate(1, closeOnSelect);
  }
  function focusout_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("handleSelect" in $$props2)
      $$invalidate(2, handleSelect = $$props2.handleSelect);
    if ("min" in $$props2)
      $$invalidate(23, min2 = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(24, max2 = $$props2.max);
    if ("locale" in $$props2)
      $$invalidate(25, locale2 = $$props2.locale);
    if ("closeOnSelect" in $$props2)
      $$invalidate(1, closeOnSelect = $$props2.closeOnSelect);
    if ("showTime" in $$props2)
      $$invalidate(3, showTime = $$props2.showTime);
    if ("step" in $$props2)
      $$invalidate(4, step = $$props2.step);
    if ("handleClose" in $$props2)
      $$invalidate(26, handleClose = $$props2.handleClose);
    if ("handleClear" in $$props2)
      $$invalidate(27, handleClear = $$props2.handleClear);
    if ("actions" in $$props2)
      $$invalidate(5, actions = $$props2.actions);
    if ("format" in $$props2)
      $$invalidate(6, format2 = $$props2.format);
    if ("mobile" in $$props2)
      $$invalidate(7, mobile = $$props2.mobile);
  };
  return [
    value,
    closeOnSelect,
    handleSelect,
    showTime,
    step,
    actions,
    format2,
    mobile,
    browseDate,
    transitionDirection,
    calendarDays,
    hourSelected,
    minuteSelected,
    meridianSelected,
    defaultDate,
    iLocale,
    setValue,
    selectDay,
    dayIsInRange,
    keydown,
    handleArrow,
    handleApply,
    handleCancel,
    min2,
    max2,
    locale2,
    handleClose,
    handleClear,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    timepicker_hourSelected_binding,
    timepicker_minuteSelected_binding,
    timepicker_meridianSelected_binding,
    timepicker_browseDate_binding,
    timepicker_closeOnSelect_binding,
    timepicker_hourSelected_binding_1,
    timepicker_minuteSelected_binding_1,
    timepicker_meridianSelected_binding_1,
    timepicker_browseDate_binding_1,
    timepicker_closeOnSelect_binding_1,
    focusout_handler
  ];
}
let DatePicker$1 = class DatePicker extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$23,
      create_fragment$25,
      safe_not_equal,
      {
        value: 0,
        handleSelect: 2,
        min: 23,
        max: 24,
        locale: 25,
        closeOnSelect: 1,
        showTime: 3,
        step: 4,
        handleClose: 26,
        handleClear: 27,
        actions: 5,
        format: 6,
        mobile: 7
      },
      null,
      [-1, -1]
    );
  }
};
const get_trailing_slot_changes_1$1 = (dirty) => ({});
const get_trailing_slot_context_1$1 = (ctx) => ({});
const get_leading_slot_changes_1 = (dirty) => ({});
const get_leading_slot_context_1 = (ctx) => ({});
const get_label_slot_changes_1$1 = (dirty) => ({});
const get_label_slot_context_1$1 = (ctx) => ({});
const get_trailing_slot_changes$1 = (dirty) => ({});
const get_trailing_slot_context$1 = (ctx) => ({});
const get_leading_slot_changes$5 = (dirty) => ({});
const get_leading_slot_context$5 = (ctx) => ({});
const get_label_slot_changes$7 = (dirty) => ({});
const get_label_slot_context$7 = (ctx) => ({});
function create_else_block$g(ctx) {
  let div1;
  let t0;
  let div0;
  let input0;
  let t1;
  let input1;
  let input1_readonly_value;
  let input1_name_value;
  let input1_id_value;
  let useActions_action;
  let t2;
  let t3;
  let t4;
  let current_block_type_index;
  let if_block2;
  let t5;
  let div1_class_value;
  let div1_style_value;
  let t6;
  let portal;
  let current;
  let mounted;
  let dispose;
  const label_slot_template = (
    /*#slots*/
    ctx[32].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_label_slot_context_1$1
  );
  let input1_levels = [
    { readOnly: input1_readonly_value = true },
    { autocomplete: "off" },
    {
      name: input1_name_value = /*name*/
      ctx[4] + "-visual"
    },
    {
      id: input1_id_value = /*name*/
      ctx[4] + "-visual"
    },
    { tabindex: (
      /*tabindex*/
      ctx[12]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[6]
    ) },
    { disabled: (
      /*disabled*/
      ctx[14]
    ) },
    { type: "text" },
    {
      class: "block h-[2.5rem] w-full px-3 border outline-none focus:outline-none sm:text-sm rounded-md bg-surface placeholder-secondary-content placeholder-opacity-80"
    },
    exclude(
      /*$$props*/
      ctx[29],
      ["use", "class", "value"]
    )
  ];
  let input_data = {};
  for (let i2 = 0; i2 < input1_levels.length; i2 += 1) {
    input_data = assign$1(input_data, input1_levels[i2]);
  }
  let if_block0 = (
    /*allowClear*/
    ctx[13] && /*value*/
    ctx[0] && create_if_block_11$3(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    ctx[30].leading && create_if_block_10$4(ctx)
  );
  const if_block_creators = [create_if_block_8$5, create_if_block_9$4];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[30].trailing && !/*error*/
      ctx2[5]
    )
      return 0;
    if (
      /*error*/
      ctx2[5]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_2(ctx))) {
    if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block3 = (
    /*error*/
    ctx[5] && create_if_block_7$6(ctx)
  );
  portal = new Portal({
    props: {
      $$slots: { default: [create_default_slot$d] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      if (label_slot)
        label_slot.c();
      t0 = space();
      div0 = element("div");
      input0 = element("input");
      t1 = space();
      input1 = element("input");
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      t4 = space();
      if (if_block2)
        if_block2.c();
      t5 = space();
      if (if_block3)
        if_block3.c();
      t6 = space();
      create_component(portal.$$.fragment);
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      if (label_slot)
        label_slot.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input0 = claim_element(div0_nodes, "INPUT", {
        type: true,
        name: true,
        id: true,
        tabindex: true,
        class: true
      });
      t1 = claim_space(div0_nodes);
      input1 = claim_element(div0_nodes, "INPUT", {
        autocomplete: true,
        name: true,
        id: true,
        tabindex: true,
        placeholder: true,
        type: true,
        class: true
      });
      t2 = claim_space(div0_nodes);
      if (if_block0)
        if_block0.l(div0_nodes);
      t3 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      t4 = claim_space(div0_nodes);
      if (if_block2)
        if_block2.l(div0_nodes);
      div0_nodes.forEach(detach);
      t5 = claim_space(div1_nodes);
      if (if_block3)
        if_block3.l(div1_nodes);
      div1_nodes.forEach(detach);
      t6 = claim_space(nodes);
      claim_component(portal.$$.fragment, nodes);
      this.h();
    },
    h() {
      attr(input0, "type", "text");
      attr(
        input0,
        "name",
        /*name*/
        ctx[4]
      );
      attr(
        input0,
        "id",
        /*name*/
        ctx[4]
      );
      attr(input0, "tabindex", "-1");
      input0.readOnly = true;
      attr(input0, "class", "h-0 w-0 invisible hidden");
      input0.disabled = /*disabled*/
      ctx[14];
      set_attributes(input1, input_data);
      toggle_class(input1, "border-border", !/*error*/
      ctx[5]);
      toggle_class(
        input1,
        "border-danger",
        /*error*/
        ctx[5]
      );
      toggle_class(
        input1,
        "text-danger",
        /*error*/
        ctx[5]
      );
      toggle_class(
        input1,
        "placeholder-danger",
        /*error*/
        ctx[5]
      );
      toggle_class(
        input1,
        "focus:border-red-500",
        /*error*/
        ctx[5]
      );
      toggle_class(input1, "focus:border-primary", !/*error*/
      ctx[5]);
      toggle_class(
        input1,
        "group-focus-within:border-red-500",
        /*error*/
        ctx[5]
      );
      toggle_class(input1, "group-focus-within:border-primary", !/*error*/
      ctx[5]);
      toggle_class(
        input1,
        "group-active:border-red-500",
        /*error*/
        ctx[5]
      );
      toggle_class(input1, "group-active:border-primary", !/*error*/
      ctx[5]);
      toggle_class(
        input1,
        "bg-default",
        /*disabled*/
        ctx[14]
      );
      toggle_class(
        input1,
        "pl-10",
        /*$$slots*/
        ctx[30].leading
      );
      toggle_class(
        input1,
        "pr-10",
        /*$$slots*/
        ctx[30].trailing || /*error*/
        ctx[5] || /*allowClear*/
        ctx[13]
      );
      attr(div0, "class", "mt-1 relative rounded-md h-[2.5rem]");
      toggle_class(
        div0,
        "opacity-75",
        /*disabled*/
        ctx[14]
      );
      toggle_class(
        div0,
        "text-danger",
        /*error*/
        ctx[5]
      );
      attr(div1, "class", div1_class_value = /*$$props*/
      ctx[29].class);
      attr(div1, "style", div1_style_value = /*$$props*/
      ctx[29].style);
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      if (label_slot) {
        label_slot.m(div1, null);
      }
      append_hydration(div1, t0);
      append_hydration(div1, div0);
      append_hydration(div0, input0);
      set_input_value(
        input0,
        /*value*/
        ctx[0]
      );
      ctx[39](input0);
      append_hydration(div0, t1);
      append_hydration(div0, input1);
      if (input1.autofocus)
        input1.focus();
      ctx[40](input1);
      set_input_value(
        input1,
        /*text*/
        ctx[20]
      );
      append_hydration(div0, t2);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration(div0, t3);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration(div0, t4);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div0, null);
      }
      append_hydration(div1, t5);
      if (if_block3)
        if_block3.m(div1, null);
      insert_hydration(target, t6, anchor);
      mount_component(portal, target, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler_1*/
            ctx[38]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler_1*/
            ctx[41]
          ),
          listen(
            input1,
            "focus",
            /*handleOpen*/
            ctx[27]
          ),
          listen(
            input1,
            "mousedown",
            /*handleOpen*/
            ctx[27]
          ),
          listen(
            input1,
            "keydown",
            /*keydown*/
            ctx[24]
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            input1,
            /*use*/
            ctx[2]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[22].call(null, input1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_label_slot_changes_1$1
            ),
            get_label_slot_context_1$1
          );
        }
      }
      if (!current || dirty[0] & /*name*/
      16) {
        attr(
          input0,
          "name",
          /*name*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*name*/
      16) {
        attr(
          input0,
          "id",
          /*name*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      16384) {
        input0.disabled = /*disabled*/
        ctx2[14];
      }
      if (dirty[0] & /*value*/
      1 && input0.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input0,
          /*value*/
          ctx2[0]
        );
      }
      set_attributes(input1, input_data = get_spread_update(input1_levels, [
        { readOnly: input1_readonly_value },
        { autocomplete: "off" },
        (!current || dirty[0] & /*name*/
        16 && input1_name_value !== (input1_name_value = /*name*/
        ctx2[4] + "-visual")) && { name: input1_name_value },
        (!current || dirty[0] & /*name*/
        16 && input1_id_value !== (input1_id_value = /*name*/
        ctx2[4] + "-visual")) && { id: input1_id_value },
        (!current || dirty[0] & /*tabindex*/
        4096) && { tabindex: (
          /*tabindex*/
          ctx2[12]
        ) },
        (!current || dirty[0] & /*placeholder*/
        64) && { placeholder: (
          /*placeholder*/
          ctx2[6]
        ) },
        (!current || dirty[0] & /*disabled*/
        16384) && { disabled: (
          /*disabled*/
          ctx2[14]
        ) },
        { type: "text" },
        {
          class: "block h-[2.5rem] w-full px-3 border outline-none focus:outline-none sm:text-sm rounded-md bg-surface placeholder-secondary-content placeholder-opacity-80"
        },
        dirty[0] & /*$$props*/
        536870912 && exclude(
          /*$$props*/
          ctx2[29],
          ["use", "class", "value"]
        )
      ]));
      if (dirty[0] & /*text*/
      1048576 && input1.value !== /*text*/
      ctx2[20]) {
        set_input_value(
          input1,
          /*text*/
          ctx2[20]
        );
      }
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[2]
        );
      toggle_class(input1, "border-border", !/*error*/
      ctx2[5]);
      toggle_class(
        input1,
        "border-danger",
        /*error*/
        ctx2[5]
      );
      toggle_class(
        input1,
        "text-danger",
        /*error*/
        ctx2[5]
      );
      toggle_class(
        input1,
        "placeholder-danger",
        /*error*/
        ctx2[5]
      );
      toggle_class(
        input1,
        "focus:border-red-500",
        /*error*/
        ctx2[5]
      );
      toggle_class(input1, "focus:border-primary", !/*error*/
      ctx2[5]);
      toggle_class(
        input1,
        "group-focus-within:border-red-500",
        /*error*/
        ctx2[5]
      );
      toggle_class(input1, "group-focus-within:border-primary", !/*error*/
      ctx2[5]);
      toggle_class(
        input1,
        "group-active:border-red-500",
        /*error*/
        ctx2[5]
      );
      toggle_class(input1, "group-active:border-primary", !/*error*/
      ctx2[5]);
      toggle_class(
        input1,
        "bg-default",
        /*disabled*/
        ctx2[14]
      );
      toggle_class(
        input1,
        "pl-10",
        /*$$slots*/
        ctx2[30].leading
      );
      toggle_class(
        input1,
        "pr-10",
        /*$$slots*/
        ctx2[30].trailing || /*error*/
        ctx2[5] || /*allowClear*/
        ctx2[13]
      );
      if (
        /*allowClear*/
        ctx2[13] && /*value*/
        ctx2[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*allowClear, value*/
          8193) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_11$3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t3);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[30].leading
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          1073741824) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_10$4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t4);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block2) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block2 = if_blocks[current_block_type_index];
          if (!if_block2) {
            if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block2.c();
          } else {
            if_block2.p(ctx2, dirty);
          }
          transition_in(if_block2, 1);
          if_block2.m(div0, null);
        } else {
          if_block2 = null;
        }
      }
      if (!current || dirty[0] & /*disabled*/
      16384) {
        toggle_class(
          div0,
          "opacity-75",
          /*disabled*/
          ctx2[14]
        );
      }
      if (!current || dirty[0] & /*error*/
      32) {
        toggle_class(
          div0,
          "text-danger",
          /*error*/
          ctx2[5]
        );
      }
      if (
        /*error*/
        ctx2[5]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*error*/
          32) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_7$6(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div1, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*$$props*/
      536870912 && div1_class_value !== (div1_class_value = /*$$props*/
      ctx2[29].class)) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*$$props*/
      536870912 && div1_style_value !== (div1_style_value = /*$$props*/
      ctx2[29].style)) {
        attr(div1, "style", div1_style_value);
      }
      const portal_changes = {};
      if (dirty[0] & /*min, max, locale, closeOnSelect, showTime, minuteStep, actions, format, mobile, valueDayJS, visible*/
      757642 | dirty[1] & /*$$scope*/
      4096) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal.$set(portal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(portal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(portal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t6);
      }
      if (label_slot)
        label_slot.d(detaching);
      ctx[39](null);
      ctx[40](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block3)
        if_block3.d();
      destroy_component(portal, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$I(ctx) {
  let div2;
  let t2;
  let dropdown;
  let div_class_value;
  let div_style_value;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[32].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_label_slot_context$7
  );
  dropdown = new Dropdown({
    props: {
      handleClose: (
        /*handleClose*/
        ctx[26]
      ),
      visible: (
        /*visible*/
        ctx[1]
      ),
      class: "w-full",
      $$slots: {
        items: [create_items_slot$1],
        trigger: [create_trigger_slot$1]
      },
      $$scope: { ctx }
    }
  });
  dropdown.$on(
    "focusout",
    /*onFocusOut*/
    ctx[23]
  );
  dropdown.$on(
    "keydown",
    /*keydown*/
    ctx[24]
  );
  return {
    c() {
      div2 = element("div");
      if (label_slot)
        label_slot.c();
      t2 = space();
      create_component(dropdown.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div2);
      if (label_slot)
        label_slot.l(div_nodes);
      t2 = claim_space(div_nodes);
      claim_component(dropdown.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", div_class_value = /*$$props*/
      ctx[29].class);
      attr(div2, "style", div_style_value = /*$$props*/
      ctx[29].style);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (label_slot) {
        label_slot.m(div2, null);
      }
      append_hydration(div2, t2);
      mount_component(dropdown, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_label_slot_changes$7
            ),
            get_label_slot_context$7
          );
        }
      }
      const dropdown_changes = {};
      if (dirty[0] & /*visible*/
      2)
        dropdown_changes.visible = /*visible*/
        ctx2[1];
      if (dirty[0] & /*error, min, max, locale, closeOnSelect, showTime, minuteStep, actions, format, valueDayJS, name, disabled, $$slots, allowClear, value, tabindex, placeholder, $$props, input, text, use, valueInput*/
      1614675965 | dirty[1] & /*$$scope*/
      4096) {
        dropdown_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropdown.$set(dropdown_changes);
      if (!current || dirty[0] & /*$$props*/
      536870912 && div_class_value !== (div_class_value = /*$$props*/
      ctx2[29].class)) {
        attr(div2, "class", div_class_value);
      }
      if (!current || dirty[0] & /*$$props*/
      536870912 && div_style_value !== (div_style_value = /*$$props*/
      ctx2[29].style)) {
        attr(div2, "style", div_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (label_slot)
        label_slot.d(detaching);
      destroy_component(dropdown);
    }
  };
}
function create_if_block_11$3(ctx) {
  let button;
  let span;
  let icon;
  let span_transition;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$7({ props: { data: close } });
  return {
    c() {
      button = element("button");
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { "aria-label": true, class: true });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "items-center flex");
      attr(button, "aria-label", "clear");
      attr(button, "class", "absolute inset-y-0 group-focus-within:flex active:flex items-center");
      toggle_class(
        button,
        "right-10",
        /*$$slots*/
        ctx[30].trailing || /*error*/
        ctx[5]
      );
      toggle_class(button, "right-3", !/*$$slots*/
      ctx[30].trailing && !/*error*/
      ctx[5]);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, span);
      mount_component(icon, span, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handleClear*/
          ctx[28]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & /*$$slots, error*/
      1073741856) {
        toggle_class(
          button,
          "right-10",
          /*$$slots*/
          ctx2[30].trailing || /*error*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*$$slots, error*/
      1073741856) {
        toggle_class(button, "right-3", !/*$$slots*/
        ctx2[30].trailing && !/*error*/
        ctx2[5]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!span_transition)
            span_transition = create_bidirectional_transition(span, scale, {}, true);
          span_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      if (local) {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, scale, {}, false);
        span_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(icon);
      if (detaching && span_transition)
        span_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_10$4(ctx) {
  let span;
  let current;
  const leading_slot_template = (
    /*#slots*/
    ctx[32].leading
  );
  const leading_slot = create_slot(
    leading_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_leading_slot_context_1
  );
  return {
    c() {
      span = element("span");
      if (leading_slot)
        leading_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (leading_slot)
        leading_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none");
      toggle_class(
        span,
        "text-danger",
        /*error*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (leading_slot) {
        leading_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (leading_slot) {
        if (leading_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            leading_slot,
            leading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              leading_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_leading_slot_changes_1
            ),
            get_leading_slot_context_1
          );
        }
      }
      if (!current || dirty[0] & /*error*/
      32) {
        toggle_class(
          span,
          "text-danger",
          /*error*/
          ctx2[5]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leading_slot, local);
      current = true;
    },
    o(local) {
      transition_out(leading_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (leading_slot)
        leading_slot.d(detaching);
    }
  };
}
function create_if_block_9$4(ctx) {
  let span;
  let icon;
  let current;
  icon = new Icon$7({ props: { data: error } });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block_8$5(ctx) {
  let span;
  let current;
  const trailing_slot_template = (
    /*#slots*/
    ctx[32].trailing
  );
  const trailing_slot = create_slot(
    trailing_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_trailing_slot_context_1$1
  );
  return {
    c() {
      span = element("span");
      if (trailing_slot)
        trailing_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (trailing_slot)
        trailing_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (trailing_slot) {
        trailing_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (trailing_slot) {
        if (trailing_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            trailing_slot,
            trailing_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              trailing_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_trailing_slot_changes_1$1
            ),
            get_trailing_slot_context_1$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(trailing_slot, local);
      current = true;
    },
    o(local) {
      transition_out(trailing_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (trailing_slot)
        trailing_slot.d(detaching);
    }
  };
}
function create_if_block_7$6(ctx) {
  let p;
  let t2;
  let p_id_value;
  let p_transition;
  let current;
  return {
    c() {
      p = element("p");
      t2 = text(
        /*error*/
        ctx[5]
      );
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true, id: true });
      var p_nodes = children(p);
      t2 = claim_text(
        p_nodes,
        /*error*/
        ctx[5]
      );
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(p, "class", "mt-2 text-sm text-danger");
      attr(p, "id", p_id_value = /*name*/
      ctx[4] + "-error");
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      append_hydration(p, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & /*error*/
      32)
        set_data(
          t2,
          /*error*/
          ctx2[5]
        );
      if (!current || dirty[0] & /*name*/
      16 && p_id_value !== (p_id_value = /*name*/
      ctx2[4] + "-error")) {
        attr(p, "id", p_id_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!p_transition)
            p_transition = create_bidirectional_transition(p, slide, {}, true);
          p_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!p_transition)
          p_transition = create_bidirectional_transition(p, slide, {}, false);
        p_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (detaching && p_transition)
        p_transition.end();
    }
  };
}
function create_if_block_6$6(ctx) {
  let drawer;
  let current;
  drawer = new Drawer$1({
    props: {
      handleClose: (
        /*handleClose*/
        ctx[26]
      ),
      placement: "bottom",
      class: "datepicker-mobile",
      $$slots: { default: [create_default_slot_1$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(drawer.$$.fragment);
    },
    l(nodes) {
      claim_component(drawer.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(drawer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const drawer_changes = {};
      if (dirty[0] & /*min, max, locale, closeOnSelect, showTime, minuteStep, actions, format, mobile, valueDayJS*/
      757640 | dirty[1] & /*$$scope*/
      4096) {
        drawer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      drawer.$set(drawer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(drawer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(drawer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(drawer, detaching);
    }
  };
}
function create_default_slot_1$9(ctx) {
  let datepicker;
  let updating_value;
  let current;
  function datepicker_value_binding_1(value) {
    ctx[42](value);
  }
  let datepicker_props = {
    handleSelect: (
      /*onSelect*/
      ctx[25]
    ),
    min: (
      /*min*/
      ctx[7] ? dayjs(
        /*min*/
        ctx[7]
      ) : void 0
    ),
    max: (
      /*max*/
      ctx[8] ? dayjs(
        /*max*/
        ctx[8]
      ) : void 0
    ),
    locale: (
      /*locale*/
      ctx[10]
    ),
    closeOnSelect: (
      /*closeOnSelect*/
      ctx[11]
    ),
    handleClose: (
      /*handleClose*/
      ctx[26]
    ),
    handleClear: (
      /*handleClear*/
      ctx[28]
    ),
    showTime: (
      /*showTime*/
      ctx[3]
    ),
    step: (
      /*minuteStep*/
      ctx[15]
    ),
    actions: (
      /*actions*/
      ctx[16]
    ),
    format: (
      /*format*/
      ctx[9]
    ),
    mobile: (
      /*mobile*/
      ctx[17]
    )
  };
  if (
    /*valueDayJS*/
    ctx[19] !== void 0
  ) {
    datepicker_props.value = /*valueDayJS*/
    ctx[19];
  }
  datepicker = new DatePicker$1({ props: datepicker_props });
  binding_callbacks.push(() => bind(datepicker, "value", datepicker_value_binding_1));
  datepicker.$on(
    "focusout",
    /*onFocusOut*/
    ctx[23]
  );
  return {
    c() {
      create_component(datepicker.$$.fragment);
    },
    l(nodes) {
      claim_component(datepicker.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(datepicker, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const datepicker_changes = {};
      if (dirty[0] & /*min*/
      128)
        datepicker_changes.min = /*min*/
        ctx2[7] ? dayjs(
          /*min*/
          ctx2[7]
        ) : void 0;
      if (dirty[0] & /*max*/
      256)
        datepicker_changes.max = /*max*/
        ctx2[8] ? dayjs(
          /*max*/
          ctx2[8]
        ) : void 0;
      if (dirty[0] & /*locale*/
      1024)
        datepicker_changes.locale = /*locale*/
        ctx2[10];
      if (dirty[0] & /*closeOnSelect*/
      2048)
        datepicker_changes.closeOnSelect = /*closeOnSelect*/
        ctx2[11];
      if (dirty[0] & /*showTime*/
      8)
        datepicker_changes.showTime = /*showTime*/
        ctx2[3];
      if (dirty[0] & /*minuteStep*/
      32768)
        datepicker_changes.step = /*minuteStep*/
        ctx2[15];
      if (dirty[0] & /*actions*/
      65536)
        datepicker_changes.actions = /*actions*/
        ctx2[16];
      if (dirty[0] & /*format*/
      512)
        datepicker_changes.format = /*format*/
        ctx2[9];
      if (dirty[0] & /*mobile*/
      131072)
        datepicker_changes.mobile = /*mobile*/
        ctx2[17];
      if (!updating_value && dirty[0] & /*valueDayJS*/
      524288) {
        updating_value = true;
        datepicker_changes.value = /*valueDayJS*/
        ctx2[19];
        add_flush_callback(() => updating_value = false);
      }
      datepicker.$set(datepicker_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(datepicker.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(datepicker.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(datepicker, detaching);
    }
  };
}
function create_default_slot$d(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*visible*/
    ctx[1] && create_if_block_6$6(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*visible*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*visible*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_6$6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_5$c(ctx) {
  let button;
  let span;
  let icon;
  let span_transition;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$7({ props: { data: close } });
  return {
    c() {
      button = element("button");
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { "aria-label": true, class: true });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "items-center flex");
      attr(button, "aria-label", "clear");
      attr(button, "class", "absolute inset-y-0 group-focus-within:flex active:flex items-center");
      toggle_class(
        button,
        "right-10",
        /*$$slots*/
        ctx[30].trailing || /*error*/
        ctx[5]
      );
      toggle_class(button, "right-3", !/*$$slots*/
      ctx[30].trailing && !/*error*/
      ctx[5]);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, span);
      mount_component(icon, span, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handleClear*/
          ctx[28]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & /*$$slots, error*/
      1073741856) {
        toggle_class(
          button,
          "right-10",
          /*$$slots*/
          ctx2[30].trailing || /*error*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*$$slots, error*/
      1073741856) {
        toggle_class(button, "right-3", !/*$$slots*/
        ctx2[30].trailing && !/*error*/
        ctx2[5]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!span_transition)
            span_transition = create_bidirectional_transition(span, scale, {}, true);
          span_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      if (local) {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, scale, {}, false);
        span_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(icon);
      if (detaching && span_transition)
        span_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4$c(ctx) {
  let span;
  let current;
  const leading_slot_template = (
    /*#slots*/
    ctx[32].leading
  );
  const leading_slot = create_slot(
    leading_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_leading_slot_context$5
  );
  return {
    c() {
      span = element("span");
      if (leading_slot)
        leading_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (leading_slot)
        leading_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none");
      toggle_class(
        span,
        "text-danger",
        /*error*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (leading_slot) {
        leading_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (leading_slot) {
        if (leading_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            leading_slot,
            leading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              leading_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_leading_slot_changes$5
            ),
            get_leading_slot_context$5
          );
        }
      }
      if (!current || dirty[0] & /*error*/
      32) {
        toggle_class(
          span,
          "text-danger",
          /*error*/
          ctx2[5]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leading_slot, local);
      current = true;
    },
    o(local) {
      transition_out(leading_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (leading_slot)
        leading_slot.d(detaching);
    }
  };
}
function create_if_block_3$h(ctx) {
  let span;
  let icon;
  let current;
  icon = new Icon$7({ props: { data: error } });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block_2$i(ctx) {
  let span;
  let current;
  const trailing_slot_template = (
    /*#slots*/
    ctx[32].trailing
  );
  const trailing_slot = create_slot(
    trailing_slot_template,
    ctx,
    /*$$scope*/
    ctx[43],
    get_trailing_slot_context$1
  );
  return {
    c() {
      span = element("span");
      if (trailing_slot)
        trailing_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (trailing_slot)
        trailing_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (trailing_slot) {
        trailing_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (trailing_slot) {
        if (trailing_slot.p && (!current || dirty[1] & /*$$scope*/
        4096)) {
          update_slot_base(
            trailing_slot,
            trailing_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[43],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[43]
            ) : get_slot_changes(
              trailing_slot_template,
              /*$$scope*/
              ctx2[43],
              dirty,
              get_trailing_slot_changes$1
            ),
            get_trailing_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(trailing_slot, local);
      current = true;
    },
    o(local) {
      transition_out(trailing_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (trailing_slot)
        trailing_slot.d(detaching);
    }
  };
}
function create_if_block_1$u(ctx) {
  let p;
  let t2;
  let p_id_value;
  let p_transition;
  let current;
  return {
    c() {
      p = element("p");
      t2 = text(
        /*error*/
        ctx[5]
      );
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true, id: true });
      var p_nodes = children(p);
      t2 = claim_text(
        p_nodes,
        /*error*/
        ctx[5]
      );
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(p, "class", "mt-2 text-sm text-danger");
      attr(p, "id", p_id_value = /*name*/
      ctx[4] + "-error");
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      append_hydration(p, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & /*error*/
      32)
        set_data(
          t2,
          /*error*/
          ctx2[5]
        );
      if (!current || dirty[0] & /*name*/
      16 && p_id_value !== (p_id_value = /*name*/
      ctx2[4] + "-error")) {
        attr(p, "id", p_id_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!p_transition)
            p_transition = create_bidirectional_transition(p, slide, {}, true);
          p_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!p_transition)
          p_transition = create_bidirectional_transition(p, slide, {}, false);
        p_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (detaching && p_transition)
        p_transition.end();
    }
  };
}
function create_trigger_slot$1(ctx) {
  let div2;
  let input0;
  let t0;
  let input1;
  let input1_readonly_value;
  let input1_name_value;
  let input1_id_value;
  let useActions_action;
  let t1;
  let t2;
  let t3;
  let current_block_type_index;
  let if_block2;
  let t4;
  let if_block3_anchor;
  let current;
  let mounted;
  let dispose;
  let input1_levels = [
    { readOnly: input1_readonly_value = true },
    { autocomplete: "off" },
    {
      name: input1_name_value = /*name*/
      ctx[4] + "-visual"
    },
    {
      id: input1_id_value = /*name*/
      ctx[4] + "-visual"
    },
    { tabindex: (
      /*tabindex*/
      ctx[12]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[6]
    ) },
    { disabled: (
      /*disabled*/
      ctx[14]
    ) },
    { type: "text" },
    {
      class: "block h-[2.5rem] w-full px-3 border outline-none focus:outline-none sm:text-sm rounded-md bg-surface placeholder-secondary-content placeholder-opacity-80"
    },
    exclude(
      /*$$props*/
      ctx[29],
      ["use", "class", "value"]
    )
  ];
  let input_data = {};
  for (let i2 = 0; i2 < input1_levels.length; i2 += 1) {
    input_data = assign$1(input_data, input1_levels[i2]);
  }
  let if_block0 = (
    /*allowClear*/
    ctx[13] && /*value*/
    ctx[0] && create_if_block_5$c(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    ctx[30].leading && create_if_block_4$c(ctx)
  );
  const if_block_creators = [create_if_block_2$i, create_if_block_3$h];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[30].trailing && !/*error*/
      ctx2[5]
    )
      return 0;
    if (
      /*error*/
      ctx2[5]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block3 = (
    /*error*/
    ctx[5] && create_if_block_1$u(ctx)
  );
  return {
    c() {
      div2 = element("div");
      input0 = element("input");
      t0 = space();
      input1 = element("input");
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      if_block3_anchor = empty();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      input0 = claim_element(div_nodes, "INPUT", {
        type: true,
        name: true,
        id: true,
        tabindex: true,
        class: true
      });
      t0 = claim_space(div_nodes);
      input1 = claim_element(div_nodes, "INPUT", {
        autocomplete: true,
        name: true,
        id: true,
        tabindex: true,
        placeholder: true,
        type: true,
        class: true
      });
      t1 = claim_space(div_nodes);
      if (if_block0)
        if_block0.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      t3 = claim_space(div_nodes);
      if (if_block2)
        if_block2.l(div_nodes);
      div_nodes.forEach(detach);
      t4 = claim_space(nodes);
      if (if_block3)
        if_block3.l(nodes);
      if_block3_anchor = empty();
      this.h();
    },
    h() {
      attr(input0, "type", "text");
      attr(
        input0,
        "name",
        /*name*/
        ctx[4]
      );
      attr(
        input0,
        "id",
        /*name*/
        ctx[4]
      );
      attr(input0, "tabindex", "-1");
      input0.readOnly = true;
      attr(input0, "class", "h-0 w-0 invisible hidden");
      input0.disabled = /*disabled*/
      ctx[14];
      set_attributes(input1, input_data);
      toggle_class(input1, "border-border", !/*error*/
      ctx[5]);
      toggle_class(
        input1,
        "border-danger",
        /*error*/
        ctx[5]
      );
      toggle_class(
        input1,
        "text-danger",
        /*error*/
        ctx[5]
      );
      toggle_class(
        input1,
        "placeholder-danger",
        /*error*/
        ctx[5]
      );
      toggle_class(
        input1,
        "focus:border-red-500",
        /*error*/
        ctx[5]
      );
      toggle_class(input1, "focus:border-primary", !/*error*/
      ctx[5]);
      toggle_class(
        input1,
        "group-focus-within:border-red-500",
        /*error*/
        ctx[5]
      );
      toggle_class(input1, "group-focus-within:border-primary", !/*error*/
      ctx[5]);
      toggle_class(
        input1,
        "group-active:border-red-500",
        /*error*/
        ctx[5]
      );
      toggle_class(input1, "group-active:border-primary", !/*error*/
      ctx[5]);
      toggle_class(
        input1,
        "bg-default",
        /*disabled*/
        ctx[14]
      );
      toggle_class(
        input1,
        "pl-10",
        /*$$slots*/
        ctx[30].leading
      );
      toggle_class(
        input1,
        "pr-10",
        /*$$slots*/
        ctx[30].trailing || /*error*/
        ctx[5] || /*allowClear*/
        ctx[13]
      );
      attr(div2, "class", "mt-1 relative rounded-md h-[2.5rem]");
      toggle_class(
        div2,
        "opacity-75",
        /*disabled*/
        ctx[14]
      );
      toggle_class(
        div2,
        "text-danger",
        /*error*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, input0);
      set_input_value(
        input0,
        /*value*/
        ctx[0]
      );
      ctx[35](input0);
      append_hydration(div2, t0);
      append_hydration(div2, input1);
      if (input1.autofocus)
        input1.focus();
      ctx[36](input1);
      set_input_value(
        input1,
        /*text*/
        ctx[20]
      );
      append_hydration(div2, t1);
      if (if_block0)
        if_block0.m(div2, null);
      append_hydration(div2, t2);
      if (if_block1)
        if_block1.m(div2, null);
      append_hydration(div2, t3);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      insert_hydration(target, t4, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert_hydration(target, if_block3_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[34]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[37]
          ),
          listen(
            input1,
            "focus",
            /*handleOpen*/
            ctx[27]
          ),
          listen(
            input1,
            "mousedown",
            /*handleOpen*/
            ctx[27]
          ),
          listen(
            input1,
            "keydown",
            /*keydown*/
            ctx[24]
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            input1,
            /*use*/
            ctx[2]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[22].call(null, input1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & /*name*/
      16) {
        attr(
          input0,
          "name",
          /*name*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*name*/
      16) {
        attr(
          input0,
          "id",
          /*name*/
          ctx2[4]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      16384) {
        input0.disabled = /*disabled*/
        ctx2[14];
      }
      if (dirty[0] & /*value*/
      1 && input0.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input0,
          /*value*/
          ctx2[0]
        );
      }
      set_attributes(input1, input_data = get_spread_update(input1_levels, [
        { readOnly: input1_readonly_value },
        { autocomplete: "off" },
        (!current || dirty[0] & /*name*/
        16 && input1_name_value !== (input1_name_value = /*name*/
        ctx2[4] + "-visual")) && { name: input1_name_value },
        (!current || dirty[0] & /*name*/
        16 && input1_id_value !== (input1_id_value = /*name*/
        ctx2[4] + "-visual")) && { id: input1_id_value },
        (!current || dirty[0] & /*tabindex*/
        4096) && { tabindex: (
          /*tabindex*/
          ctx2[12]
        ) },
        (!current || dirty[0] & /*placeholder*/
        64) && { placeholder: (
          /*placeholder*/
          ctx2[6]
        ) },
        (!current || dirty[0] & /*disabled*/
        16384) && { disabled: (
          /*disabled*/
          ctx2[14]
        ) },
        { type: "text" },
        {
          class: "block h-[2.5rem] w-full px-3 border outline-none focus:outline-none sm:text-sm rounded-md bg-surface placeholder-secondary-content placeholder-opacity-80"
        },
        dirty[0] & /*$$props*/
        536870912 && exclude(
          /*$$props*/
          ctx2[29],
          ["use", "class", "value"]
        )
      ]));
      if (dirty[0] & /*text*/
      1048576 && input1.value !== /*text*/
      ctx2[20]) {
        set_input_value(
          input1,
          /*text*/
          ctx2[20]
        );
      }
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[2]
        );
      toggle_class(input1, "border-border", !/*error*/
      ctx2[5]);
      toggle_class(
        input1,
        "border-danger",
        /*error*/
        ctx2[5]
      );
      toggle_class(
        input1,
        "text-danger",
        /*error*/
        ctx2[5]
      );
      toggle_class(
        input1,
        "placeholder-danger",
        /*error*/
        ctx2[5]
      );
      toggle_class(
        input1,
        "focus:border-red-500",
        /*error*/
        ctx2[5]
      );
      toggle_class(input1, "focus:border-primary", !/*error*/
      ctx2[5]);
      toggle_class(
        input1,
        "group-focus-within:border-red-500",
        /*error*/
        ctx2[5]
      );
      toggle_class(input1, "group-focus-within:border-primary", !/*error*/
      ctx2[5]);
      toggle_class(
        input1,
        "group-active:border-red-500",
        /*error*/
        ctx2[5]
      );
      toggle_class(input1, "group-active:border-primary", !/*error*/
      ctx2[5]);
      toggle_class(
        input1,
        "bg-default",
        /*disabled*/
        ctx2[14]
      );
      toggle_class(
        input1,
        "pl-10",
        /*$$slots*/
        ctx2[30].leading
      );
      toggle_class(
        input1,
        "pr-10",
        /*$$slots*/
        ctx2[30].trailing || /*error*/
        ctx2[5] || /*allowClear*/
        ctx2[13]
      );
      if (
        /*allowClear*/
        ctx2[13] && /*value*/
        ctx2[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*allowClear, value*/
          8193) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5$c(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[30].leading
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          1073741824) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4$c(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block2) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block2 = if_blocks[current_block_type_index];
          if (!if_block2) {
            if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block2.c();
          } else {
            if_block2.p(ctx2, dirty);
          }
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        } else {
          if_block2 = null;
        }
      }
      if (!current || dirty[0] & /*disabled*/
      16384) {
        toggle_class(
          div2,
          "opacity-75",
          /*disabled*/
          ctx2[14]
        );
      }
      if (!current || dirty[0] & /*error*/
      32) {
        toggle_class(
          div2,
          "text-danger",
          /*error*/
          ctx2[5]
        );
      }
      if (
        /*error*/
        ctx2[5]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*error*/
          32) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1$u(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t4);
        detach(if_block3_anchor);
      }
      ctx[35](null);
      ctx[36](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block3)
        if_block3.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_items_slot$1(ctx) {
  let div2;
  let datepicker;
  let updating_value;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  function datepicker_value_binding(value) {
    ctx[33](value);
  }
  let datepicker_props = {
    handleSelect: (
      /*onSelect*/
      ctx[25]
    ),
    min: (
      /*min*/
      ctx[7] ? dayjs(
        /*min*/
        ctx[7]
      ) : void 0
    ),
    max: (
      /*max*/
      ctx[8] ? dayjs(
        /*max*/
        ctx[8]
      ) : void 0
    ),
    locale: (
      /*locale*/
      ctx[10]
    ),
    closeOnSelect: (
      /*closeOnSelect*/
      ctx[11]
    ),
    handleClose: (
      /*handleClose*/
      ctx[26]
    ),
    handleClear: (
      /*handleClear*/
      ctx[28]
    ),
    showTime: (
      /*showTime*/
      ctx[3]
    ),
    step: (
      /*minuteStep*/
      ctx[15]
    ),
    actions: (
      /*actions*/
      ctx[16]
    ),
    format: (
      /*format*/
      ctx[9]
    )
  };
  if (
    /*valueDayJS*/
    ctx[19] !== void 0
  ) {
    datepicker_props.value = /*valueDayJS*/
    ctx[19];
  }
  datepicker = new DatePicker$1({ props: datepicker_props });
  binding_callbacks.push(() => bind(datepicker, "value", datepicker_value_binding));
  datepicker.$on(
    "focusout",
    /*onFocusOut*/
    ctx[23]
  );
  return {
    c() {
      div2 = element("div");
      create_component(datepicker.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { slot: true, class: true });
      var div_nodes = children(div2);
      claim_component(datepicker.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "slot", "items");
      attr(div2, "class", "z-10 absolute inline-block");
      toggle_class(
        div2,
        "-mt-7",
        /*error*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(datepicker, div2, null);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(floatingUI.call(null, div2, { placement: "bottom-start", offset: 8 }));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const datepicker_changes = {};
      if (dirty[0] & /*min*/
      128)
        datepicker_changes.min = /*min*/
        ctx2[7] ? dayjs(
          /*min*/
          ctx2[7]
        ) : void 0;
      if (dirty[0] & /*max*/
      256)
        datepicker_changes.max = /*max*/
        ctx2[8] ? dayjs(
          /*max*/
          ctx2[8]
        ) : void 0;
      if (dirty[0] & /*locale*/
      1024)
        datepicker_changes.locale = /*locale*/
        ctx2[10];
      if (dirty[0] & /*closeOnSelect*/
      2048)
        datepicker_changes.closeOnSelect = /*closeOnSelect*/
        ctx2[11];
      if (dirty[0] & /*showTime*/
      8)
        datepicker_changes.showTime = /*showTime*/
        ctx2[3];
      if (dirty[0] & /*minuteStep*/
      32768)
        datepicker_changes.step = /*minuteStep*/
        ctx2[15];
      if (dirty[0] & /*actions*/
      65536)
        datepicker_changes.actions = /*actions*/
        ctx2[16];
      if (dirty[0] & /*format*/
      512)
        datepicker_changes.format = /*format*/
        ctx2[9];
      if (!updating_value && dirty[0] & /*valueDayJS*/
      524288) {
        updating_value = true;
        datepicker_changes.value = /*valueDayJS*/
        ctx2[19];
        add_flush_callback(() => updating_value = false);
      }
      datepicker.$set(datepicker_changes);
      if (!current || dirty[0] & /*error*/
      32) {
        toggle_class(
          div2,
          "-mt-7",
          /*error*/
          ctx2[5]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(datepicker.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div_outro)
            div_outro.end(1);
          div_intro = create_in_transition(div2, scale, { start: 0.9, duration: 100, delay: 150 });
          div_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(datepicker.$$.fragment, local);
      if (div_intro)
        div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(div2, scale, { start: 0.95, duration: 75 });
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(datepicker);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$24(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$I, create_else_block$g];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (!/*mobile*/
    ctx2[17])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let input;
  let valueInput;
  let { showTime = false } = $$props;
  let { name } = $$props;
  let { error: error2 = void 0 } = $$props;
  let { placeholder = void 0 } = $$props;
  let { value = null } = $$props;
  let { min: min2 = void 0 } = $$props;
  let { max: max2 = void 0 } = $$props;
  let { format: format2 = showTime ? "MMMM D, YYYY @ h:mm A" : "MMMM D, YYYY" } = $$props;
  let { locale: locale2 = {} } = $$props;
  let { visible = false } = $$props;
  let { closeOnSelect = true } = $$props;
  let { handleSelect = void 0 } = $$props;
  let { tabindex = void 0 } = $$props;
  let { allowClear = false } = $$props;
  let { disabled = false } = $$props;
  let { minuteStep = 1 } = $$props;
  let { actions = [] } = $$props;
  let { mobile = false } = $$props;
  let valueDayJS;
  let text2;
  let currentError = writable(error2);
  function onFocusOut(event) {
    const e2 = event;
    if ((e2 == null ? void 0 : e2.currentTarget) instanceof HTMLElement && e2.relatedTarget && e2.relatedTarget instanceof Node && e2.currentTarget.contains(e2.relatedTarget)) {
      return;
    } else if ((e2 == null ? void 0 : e2.target) instanceof HTMLButtonElement && (e2.target.id.includes("hour") || e2.target.id.includes("minute") || e2.target.id.includes("meridian"))) {
      return;
    } else {
      $$invalidate(1, visible = false);
    }
  }
  function keydown(event) {
    const e2 = event;
    if (e2.key === "Escape" && visible) {
      $$invalidate(1, visible = false);
    } else if (e2.key === "Tab") {
      $$invalidate(1, visible = !visible);
    }
  }
  function onSelect(d3) {
    $$invalidate(0, value = new Date(d3.toISOString()));
    $$invalidate(21, valueInput.value = value.toISOString(), valueInput);
    if (handleSelect)
      handleSelect(value);
    if (closeOnSelect && !showTime) {
      $$invalidate(1, visible = false);
    }
  }
  function handleClose() {
    $$invalidate(1, visible = false);
  }
  function handleOpen() {
    if (!disabled) {
      $$invalidate(1, visible = true);
    }
  }
  function handleClear() {
    $$invalidate(18, input.value = "", input);
    $$invalidate(0, value = null);
  }
  setContext("datepicker-name", name);
  setContext("datepicker-error", currentError);
  function datepicker_value_binding(value$1) {
    valueDayJS = value$1;
    $$invalidate(19, valueDayJS), $$invalidate(0, value), $$invalidate(9, format2), $$invalidate(18, input), $$invalidate(20, text2);
  }
  function input0_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      valueInput = $$value;
      $$invalidate(21, valueInput);
    });
  }
  function input1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(18, input), $$invalidate(0, value), $$invalidate(19, valueDayJS), $$invalidate(9, format2), $$invalidate(20, text2);
    });
  }
  function input1_input_handler() {
    text2 = this.value;
    $$invalidate(20, text2), $$invalidate(0, value), $$invalidate(19, valueDayJS), $$invalidate(9, format2), $$invalidate(18, input);
  }
  function input0_input_handler_1() {
    value = this.value;
    $$invalidate(0, value);
  }
  function input0_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      valueInput = $$value;
      $$invalidate(21, valueInput);
    });
  }
  function input1_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(18, input), $$invalidate(0, value), $$invalidate(19, valueDayJS), $$invalidate(9, format2), $$invalidate(20, text2);
    });
  }
  function input1_input_handler_1() {
    text2 = this.value;
    $$invalidate(20, text2), $$invalidate(0, value), $$invalidate(19, valueDayJS), $$invalidate(9, format2), $$invalidate(18, input);
  }
  function datepicker_value_binding_1(value$1) {
    valueDayJS = value$1;
    $$invalidate(19, valueDayJS), $$invalidate(0, value), $$invalidate(9, format2), $$invalidate(18, input), $$invalidate(20, text2);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(29, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("showTime" in $$new_props)
      $$invalidate(3, showTime = $$new_props.showTime);
    if ("name" in $$new_props)
      $$invalidate(4, name = $$new_props.name);
    if ("error" in $$new_props)
      $$invalidate(5, error2 = $$new_props.error);
    if ("placeholder" in $$new_props)
      $$invalidate(6, placeholder = $$new_props.placeholder);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("min" in $$new_props)
      $$invalidate(7, min2 = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(8, max2 = $$new_props.max);
    if ("format" in $$new_props)
      $$invalidate(9, format2 = $$new_props.format);
    if ("locale" in $$new_props)
      $$invalidate(10, locale2 = $$new_props.locale);
    if ("visible" in $$new_props)
      $$invalidate(1, visible = $$new_props.visible);
    if ("closeOnSelect" in $$new_props)
      $$invalidate(11, closeOnSelect = $$new_props.closeOnSelect);
    if ("handleSelect" in $$new_props)
      $$invalidate(31, handleSelect = $$new_props.handleSelect);
    if ("tabindex" in $$new_props)
      $$invalidate(12, tabindex = $$new_props.tabindex);
    if ("allowClear" in $$new_props)
      $$invalidate(13, allowClear = $$new_props.allowClear);
    if ("disabled" in $$new_props)
      $$invalidate(14, disabled = $$new_props.disabled);
    if ("minuteStep" in $$new_props)
      $$invalidate(15, minuteStep = $$new_props.minuteStep);
    if ("actions" in $$new_props)
      $$invalidate(16, actions = $$new_props.actions);
    if ("mobile" in $$new_props)
      $$invalidate(17, mobile = $$new_props.mobile);
    if ("$$scope" in $$new_props)
      $$invalidate(43, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value, valueDayJS, format, input, text*/
    1835521) {
      {
        $$invalidate(19, valueDayJS = value === null ? null : dayjs(value));
        $$invalidate(20, text2 = valueDayJS == null ? void 0 : valueDayJS.format(format2));
        if (input && input.value) {
          $$invalidate(18, input.value = text2 || "", input);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*error*/
    32) {
      currentError.set(error2);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    visible,
    use,
    showTime,
    name,
    error2,
    placeholder,
    min2,
    max2,
    format2,
    locale2,
    closeOnSelect,
    tabindex,
    allowClear,
    disabled,
    minuteStep,
    actions,
    mobile,
    input,
    valueDayJS,
    text2,
    valueInput,
    forwardEvents,
    onFocusOut,
    keydown,
    onSelect,
    handleClose,
    handleOpen,
    handleClear,
    $$props,
    $$slots,
    handleSelect,
    slots,
    datepicker_value_binding,
    input0_input_handler,
    input0_binding,
    input1_binding,
    input1_input_handler,
    input0_input_handler_1,
    input0_binding_1,
    input1_binding_1,
    input1_input_handler_1,
    datepicker_value_binding_1,
    $$scope
  ];
}
class DateInput extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$22,
      create_fragment$24,
      safe_not_equal,
      {
        use: 2,
        showTime: 3,
        name: 4,
        error: 5,
        placeholder: 6,
        value: 0,
        min: 7,
        max: 8,
        format: 9,
        locale: 10,
        visible: 1,
        closeOnSelect: 11,
        handleSelect: 31,
        tabindex: 12,
        allowClear: 13,
        disabled: 14,
        minuteStep: 15,
        actions: 16,
        mobile: 17
      },
      null,
      [-1, -1]
    );
  }
}
function create_fragment$23(ctx) {
  let label;
  let label_for_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let label_levels = [
    {
      for: label_for_value = /*name*/
      ctx[3] + "-visual"
    },
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[5],
      ["use", "class"]
    )
  ];
  let label_data = {};
  for (let i2 = 0; i2 < label_levels.length; i2 += 1) {
    label_data = assign$1(label_data, label_levels[i2]);
  }
  return {
    c() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      label = claim_element(nodes, "LABEL", { for: true, class: true });
      var label_nodes = children(label);
      if (default_slot)
        default_slot.l(label_nodes);
      label_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(label, label_data);
    },
    m(target, anchor) {
      insert_hydration(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            label,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, label)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        { for: label_for_value },
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        32 && exclude(
          /*$$props*/
          ctx2[5],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1w = "block text-sm font-medium text-secondary-content";
const errorClass$3 = "text-danger";
function instance$21($$self, $$props, $$invalidate) {
  let finalClass;
  let $error;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const name = getContext("datepicker-name");
  const error2 = getContext("datepicker-error");
  component_subscribe($$self, error2, (value) => $$invalidate(6, $error = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1w, $error && $error.length > 0 ? errorClass$3 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, name, error2, $$props, $error, $$scope, slots];
}
let Label$6 = class Label6 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$21, create_fragment$23, safe_not_equal, { use: 0 });
  }
};
const DatePicker2 = DateInput;
DatePicker2.Label = Label$6;
DatePicker2.Leading = Icon$7;
DatePicker2.Trailing = Icon$7;
const get_action_slot_changes$2 = (dirty) => ({});
const get_action_slot_context$2 = (ctx) => ({});
const get_description_slot_changes$5 = (dirty) => ({});
const get_description_slot_context$5 = (ctx) => ({});
const get_title_slot_changes$6 = (dirty) => ({});
const get_title_slot_context$6 = (ctx) => ({});
const get_icon_slot_changes$d = (dirty) => ({});
const get_icon_slot_context$d = (ctx) => ({});
function create_fragment$22(ctx) {
  let div2;
  let t0;
  let t1;
  let t2;
  let t3;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = (
    /*#slots*/
    ctx[5].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_icon_slot_context$d
  );
  const title_slot_template = (
    /*#slots*/
    ctx[5].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_title_slot_context$6
  );
  const description_slot_template = (
    /*#slots*/
    ctx[5].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_description_slot_context$5
  );
  const action_slot_template = (
    /*#slots*/
    ctx[5].action
  );
  const action_slot = create_slot(
    action_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_action_slot_context$2
  );
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (icon_slot)
        icon_slot.c();
      t0 = space();
      if (title_slot)
        title_slot.c();
      t1 = space();
      if (description_slot)
        description_slot.c();
      t2 = space();
      if (action_slot)
        action_slot.c();
      t3 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (icon_slot)
        icon_slot.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (title_slot)
        title_slot.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (description_slot)
        description_slot.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (action_slot)
        action_slot.l(div_nodes);
      t3 = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (icon_slot) {
        icon_slot.m(div2, null);
      }
      append_hydration(div2, t0);
      if (title_slot) {
        title_slot.m(div2, null);
      }
      append_hydration(div2, t1);
      if (description_slot) {
        description_slot.m(div2, null);
      }
      append_hydration(div2, t2);
      if (action_slot) {
        action_slot.m(div2, null);
      }
      append_hydration(div2, t3);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_icon_slot_changes$d
            ),
            get_icon_slot_context$d
          );
        }
      }
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_title_slot_changes$6
            ),
            get_title_slot_context$6
          );
        }
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_description_slot_changes$5
            ),
            get_description_slot_context$5
          );
        }
      }
      if (action_slot) {
        if (action_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            action_slot,
            action_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              action_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_action_slot_changes$2
            ),
            get_action_slot_context$2
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(title_slot, local);
      transition_in(description_slot, local);
      transition_in(action_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(title_slot, local);
      transition_out(description_slot, local);
      transition_out(action_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (icon_slot)
        icon_slot.d(detaching);
      if (title_slot)
        title_slot.d(detaching);
      if (description_slot)
        description_slot.d(detaching);
      if (action_slot)
        action_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1v = "text-center py-12";
function instance$20($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1v, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Empty$1 = class Empty extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$20, create_fragment$22, safe_not_equal, { use: 0 });
  }
};
function create_fragment$21(ctx) {
  let span;
  let svg;
  let useActions_action;
  let span_style_value;
  let mounted;
  let dispose;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: (
      /*width*/
      ctx[2]
    ) },
    { height: (
      /*height*/
      ctx[3]
    ) },
    { viewBox: (
      /*viewBox*/
      ctx[1]
    ) },
    { stroke: (
      /*stroke*/
      ctx[5]
    ) },
    { fill: (
      /*fill*/
      ctx[6]
    ) },
    { color: (
      /*color*/
      ctx[4]
    ) },
    exclude(
      /*$$props*/
      ctx[10],
      [
        "use",
        "data",
        "class",
        "style",
        "fill",
        "viewBox",
        "width",
        "height",
        "stroke"
      ]
    )
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      svg = svg_element("svg");
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, style: true });
      var span_nodes = children(span);
      svg = claim_svg_element(span_nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        stroke: true,
        fill: true,
        color: true
      });
      var svg_nodes = children(svg);
      svg_nodes.forEach(detach);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_svg_attributes(svg, svg_data);
      attr(
        span,
        "class",
        /*finalClass*/
        ctx[7]
      );
      attr(span, "style", span_style_value = /*$$props*/
      ctx[10].style);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, svg);
      svg.innerHTML = /*elements*/
      ctx[8];
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svg,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[9].call(null, svg)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*elements*/
      256)
        svg.innerHTML = /*elements*/
        ctx2[8];
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty & /*width*/
        4 && { width: (
          /*width*/
          ctx2[2]
        ) },
        dirty & /*height*/
        8 && { height: (
          /*height*/
          ctx2[3]
        ) },
        dirty & /*viewBox*/
        2 && { viewBox: (
          /*viewBox*/
          ctx2[1]
        ) },
        dirty & /*stroke*/
        32 && { stroke: (
          /*stroke*/
          ctx2[5]
        ) },
        dirty & /*fill*/
        64 && { fill: (
          /*fill*/
          ctx2[6]
        ) },
        dirty & /*color*/
        16 && { color: (
          /*color*/
          ctx2[4]
        ) },
        dirty & /*$$props*/
        1024 && exclude(
          /*$$props*/
          ctx2[10],
          [
            "use",
            "data",
            "class",
            "style",
            "fill",
            "viewBox",
            "width",
            "height",
            "stroke"
          ]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      if (dirty & /*finalClass*/
      128) {
        attr(
          span,
          "class",
          /*finalClass*/
          ctx2[7]
        );
      }
      if (dirty & /*$$props*/
      1024 && span_style_value !== (span_style_value = /*$$props*/
      ctx2[10].style)) {
        attr(span, "style", span_style_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1u = "text-content flex items-center justify-center";
function extractViewBox$7(svg) {
  const regex = /viewBox="([\d\- ]+)"/;
  const res = regex.exec(svg);
  if (!res)
    return "0 0 24 24";
  return res[1];
}
function instance$1$($$self, $$props, $$invalidate) {
  let elements2;
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { data = "" } = $$props;
  let { viewBox = extractViewBox$7(data) } = $$props;
  let { size = "48px" } = $$props;
  let { width: width2 = size } = $$props;
  let { height = size } = $$props;
  let { color: color2 = "currentColor" } = $$props;
  let { stroke = void 0 } = $$props;
  let { fill: fill2 = color2 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("data" in $$new_props)
      $$invalidate(11, data = $$new_props.data);
    if ("viewBox" in $$new_props)
      $$invalidate(1, viewBox = $$new_props.viewBox);
    if ("size" in $$new_props)
      $$invalidate(12, size = $$new_props.size);
    if ("width" in $$new_props)
      $$invalidate(2, width2 = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(3, height = $$new_props.height);
    if ("color" in $$new_props)
      $$invalidate(4, color2 = $$new_props.color);
    if ("stroke" in $$new_props)
      $$invalidate(5, stroke = $$new_props.stroke);
    if ("fill" in $$new_props)
      $$invalidate(6, fill2 = $$new_props.fill);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data*/
    2048) {
      $$invalidate(8, elements2 = data.replace(/<svg ([^>]*)>/, "").replace("</svg>", ""));
    }
    $$invalidate(7, finalClass = twMerge(defaultClass$1u, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    viewBox,
    width2,
    height,
    color2,
    stroke,
    fill2,
    finalClass,
    elements2,
    forwardEvents,
    $$props,
    data,
    size
  ];
}
let Icon$5 = class Icon2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1$, create_fragment$21, safe_not_equal, {
      use: 0,
      data: 11,
      viewBox: 1,
      size: 12,
      width: 2,
      height: 3,
      color: 4,
      stroke: 5,
      fill: 6
    });
  }
};
function create_fragment$20(ctx) {
  let h32;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let h3_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let h3_data = {};
  for (let i2 = 0; i2 < h3_levels.length; i2 += 1) {
    h3_data = assign$1(h3_data, h3_levels[i2]);
  }
  return {
    c() {
      h32 = element("h3");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      h32 = claim_element(nodes, "H3", { class: true });
      var h3_nodes = children(h32);
      if (default_slot)
        default_slot.l(h3_nodes);
      h3_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(h32, h3_data);
    },
    m(target, anchor) {
      insert_hydration(target, h32, anchor);
      if (default_slot) {
        default_slot.m(h32, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            h32,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, h32)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h32, h3_data = get_spread_update(h3_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h32);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1t = "mt-2 text-lg font-medium text-content";
function instance$1_($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1t, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Title$7 = class Title3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1_, create_fragment$20, safe_not_equal, { use: 0 });
  }
};
function create_fragment$1$(ctx) {
  let p;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let p_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let p_data = {};
  for (let i2 = 0; i2 < p_levels.length; i2 += 1) {
    p_data = assign$1(p_data, p_levels[i2]);
  }
  return {
    c() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(p, p_data);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            p,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, p)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1s = "mt-1 text-sm text-secondary-content";
function instance$1Z($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1s, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Description$5 = class Description3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1Z, create_fragment$1$, safe_not_equal, { use: 0 });
  }
};
function create_fragment$1_(ctx) {
  let p;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let p_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let p_data = {};
  for (let i2 = 0; i2 < p_levels.length; i2 += 1) {
    p_data = assign$1(p_data, p_levels[i2]);
  }
  return {
    c() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(p, p_data);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            p,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, p)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1r = "mt-6 text-sm";
function instance$1Y($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1r, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Action$3 = class Action extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1Y, create_fragment$1_, safe_not_equal, { use: 0 });
  }
};
const Empty2 = Empty$1;
Empty2.Icon = Icon$5;
Empty2.Title = Title$7;
Empty2.Description = Description$5;
Empty2.Action = Action$3;
const Feed_svelte_svelte_type_style_lang = "";
function create_fragment$1Z(ctx) {
  let div2;
  let ul;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let ul_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let ul_data = {};
  for (let i2 = 0; i2 < ul_levels.length; i2 += 1) {
    ul_data = assign$1(ul_data, ul_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      ul = claim_element(div_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(ul, ul_data);
      attr(div2, "class", "flow-root");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            ul,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, ul)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1q = "feed -mb-8";
function instance$1X($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1q, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Feed$1 = class Feed extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1X, create_fragment$1Z, safe_not_equal, { use: 0 });
  }
};
function create_fragment$1Y(ctx) {
  let span;
  let useActions_action;
  let mounted;
  let dispose;
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      children(span).forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*finalClass*/
        2 && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1p = "connector absolute top-4 left-4 -ml-px h-full w-0.5 bg-border";
function instance$1W($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1p, $$props.cass));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props];
}
class Connector extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1W, create_fragment$1Y, safe_not_equal, { use: 0 });
  }
}
const get_datetime_slot_changes = (dirty) => ({});
const get_datetime_slot_context = (ctx) => ({});
const get_content_slot_changes$2 = (dirty) => ({});
const get_content_slot_context$2 = (ctx) => ({});
const get_leading_slot_changes$4 = (dirty) => ({});
const get_leading_slot_context$4 = (ctx) => ({});
const get_connector_slot_changes = (dirty) => ({});
const get_connector_slot_context = (ctx) => ({});
function create_else_block$f(ctx) {
  let connector;
  let current;
  connector = new Connector({});
  return {
    c() {
      create_component(connector.$$.fragment);
    },
    l(nodes) {
      claim_component(connector.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(connector, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(connector.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(connector.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(connector, detaching);
    }
  };
}
function create_if_block$H(ctx) {
  let current;
  const connector_slot_template = (
    /*#slots*/
    ctx[3].connector
  );
  const connector_slot = create_slot(
    connector_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_connector_slot_context
  );
  return {
    c() {
      if (connector_slot)
        connector_slot.c();
    },
    l(nodes) {
      if (connector_slot)
        connector_slot.l(nodes);
    },
    m(target, anchor) {
      if (connector_slot) {
        connector_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (connector_slot) {
        if (connector_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            connector_slot,
            connector_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              connector_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_connector_slot_changes
            ),
            get_connector_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(connector_slot, local);
      current = true;
    },
    o(local) {
      transition_out(connector_slot, local);
      current = false;
    },
    d(detaching) {
      if (connector_slot)
        connector_slot.d(detaching);
    }
  };
}
function create_fragment$1X(ctx) {
  let li;
  let div3;
  let current_block_type_index;
  let if_block;
  let t0;
  let div2;
  let t1;
  let div1;
  let div0;
  let t2;
  let current;
  const if_block_creators = [create_if_block$H, create_else_block$f];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[1].connector
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const leading_slot_template = (
    /*#slots*/
    ctx[3].leading
  );
  const leading_slot = create_slot(
    leading_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_leading_slot_context$4
  );
  const content_slot_template = (
    /*#slots*/
    ctx[3].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_content_slot_context$2
  );
  const datetime_slot_template = (
    /*#slots*/
    ctx[3].datetime
  );
  const datetime_slot = create_slot(
    datetime_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_datetime_slot_context
  );
  return {
    c() {
      li = element("li");
      div3 = element("div");
      if_block.c();
      t0 = space();
      div2 = element("div");
      if (leading_slot)
        leading_slot.c();
      t1 = space();
      div1 = element("div");
      div0 = element("div");
      if (content_slot)
        content_slot.c();
      t2 = space();
      if (datetime_slot)
        datetime_slot.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      div3 = claim_element(li_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      if_block.l(div3_nodes);
      t0 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (leading_slot)
        leading_slot.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {});
      var div0_nodes = children(div0);
      if (content_slot)
        content_slot.l(div0_nodes);
      div0_nodes.forEach(detach);
      t2 = claim_space(div1_nodes);
      if (datetime_slot)
        datetime_slot.l(div1_nodes);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      div3_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div1, "class", "flex min-w-0 flex-1 justify-between space-x-4 pt-1.5");
      attr(div2, "class", "relative flex space-x-3");
      attr(
        div3,
        "class",
        /*finalClass*/
        ctx[0]
      );
      attr(li, "class", "item");
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, div3);
      if_blocks[current_block_type_index].m(div3, null);
      append_hydration(div3, t0);
      append_hydration(div3, div2);
      if (leading_slot) {
        leading_slot.m(div2, null);
      }
      append_hydration(div2, t1);
      append_hydration(div2, div1);
      append_hydration(div1, div0);
      if (content_slot) {
        content_slot.m(div0, null);
      }
      append_hydration(div1, t2);
      if (datetime_slot) {
        datetime_slot.m(div1, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div3, t0);
      }
      if (leading_slot) {
        if (leading_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            leading_slot,
            leading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              leading_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_leading_slot_changes$4
            ),
            get_leading_slot_context$4
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_content_slot_changes$2
            ),
            get_content_slot_context$2
          );
        }
      }
      if (datetime_slot) {
        if (datetime_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            datetime_slot,
            datetime_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              datetime_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_datetime_slot_changes
            ),
            get_datetime_slot_context
          );
        }
      }
      if (!current || dirty & /*finalClass*/
      1) {
        attr(
          div3,
          "class",
          /*finalClass*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(leading_slot, local);
      transition_in(content_slot, local);
      transition_in(datetime_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(leading_slot, local);
      transition_out(content_slot, local);
      transition_out(datetime_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if_blocks[current_block_type_index].d();
      if (leading_slot)
        leading_slot.d(detaching);
      if (content_slot)
        content_slot.d(detaching);
      if (datetime_slot)
        datetime_slot.d(detaching);
    }
  };
}
const defaultClass$1o = "relative pb-8";
function instance$1V($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(0, finalClass = twMerge(defaultClass$1o, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [finalClass, $$slots, $$scope, slots];
}
let Item$3 = class Item2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1V, create_fragment$1X, safe_not_equal, {});
  }
};
const Placeholder_svelte_svelte_type_style_lang$3 = "";
const get_icon_slot_changes$c = (dirty) => ({});
const get_icon_slot_context$c = (ctx) => ({});
function create_if_block_1$t(ctx) {
  let span;
  let icon;
  let current;
  icon = new Icon$7({ props: { data: account } });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", null_to_empty(iconContainerClass$1) + " svelte-13m79ia");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block$G(ctx) {
  let t2;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[8].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_icon_slot_context$c
  );
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
    },
    l(nodes) {
      if (icon_slot)
        icon_slot.l(nodes);
      t2 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      insert_hydration(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_icon_slot_changes$c
            ),
            get_icon_slot_context$c
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (icon_slot)
        icon_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$1W(ctx) {
  let div2;
  let current_block_type_index;
  let if_block;
  let useActions_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$G, create_if_block_1$t];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[5].icon || /*$$slots*/
      ctx2[5].default
    )
      return 0;
    if (
      /*placeholder*/
      ctx2[3]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
      toggle_class(div2, "svelte-13m79ia", true);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div2, null);
        } else {
          if_block = null;
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(div2, "svelte-13m79ia", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, fade, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, fade, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
const iconContainerClass$1 = "absolute text-content h-full w-full";
const defaultClass$1n = "absolute inset-0 h-full w-full flex items-center justify-center overflow-hidden bg-default";
const circleClass$6 = "rounded-full";
const roundedClass$6 = "rounded-md";
function instance$1U($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { loading = false } = $$props;
  const shape = getContext("feed-avatar-shape");
  const placeholder = getContext("feed-avatar-placeholder");
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("loading" in $$new_props)
      $$invalidate(6, loading = $$new_props.loading);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1n, shape === "circle" ? circleClass$6 : false, shape === "rounded" ? roundedClass$6 : false, loading ? "loading" : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    finalClass,
    forwardEvents,
    placeholder,
    $$props,
    $$slots,
    loading,
    $$scope,
    slots
  ];
}
let Placeholder$3 = class Placeholder4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1U, create_fragment$1W, safe_not_equal, { use: 0, loading: 6 });
  }
};
const get_indicator_slot_changes$3 = (dirty) => ({});
const get_indicator_slot_context$3 = (ctx) => ({});
const get_placeholder_slot_changes$3 = (dirty) => ({});
const get_placeholder_slot_context$3 = (ctx) => ({});
function create_if_block_5$b(ctx) {
  let span1;
  let span0;
  let t2;
  let useActions_action;
  let mounted;
  let dispose;
  let span1_levels = [
    { class: (
      /*finalClass*/
      ctx[8]
    ) },
    exclude(
      /*$$props*/
      ctx[10],
      ["use", "class"]
    )
  ];
  let span_data_1 = {};
  for (let i2 = 0; i2 < span1_levels.length; i2 += 1) {
    span_data_1 = assign$1(span_data_1, span1_levels[i2]);
  }
  return {
    c() {
      span1 = element("span");
      span0 = element("span");
      t2 = text(
        /*initials*/
        ctx[3]
      );
      this.h();
    },
    l(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t2 = claim_text(
        span0_nodes,
        /*initials*/
        ctx[3]
      );
      span0_nodes.forEach(detach);
      span1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "class", "font-bold leading-none text-current text-xl");
      set_attributes(span1, span_data_1);
    },
    m(target, anchor) {
      insert_hydration(target, span1, anchor);
      append_hydration(span1, span0);
      append_hydration(span0, t2);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span1,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[9].call(null, span1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*initials*/
      8)
        set_data(
          t2,
          /*initials*/
          ctx2[3]
        );
      set_attributes(span1, span_data_1 = get_spread_update(span1_levels, [
        dirty & /*finalClass*/
        256 && { class: (
          /*finalClass*/
          ctx2[8]
        ) },
        dirty & /*$$props*/
        1024 && exclude(
          /*$$props*/
          ctx2[10],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$F(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$s, create_if_block_2$h, create_if_block_4$b];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*loaded*/
      ctx2[4]
    )
      return 0;
    if (
      /*failed*/
      ctx2[5]
    )
      return 1;
    if (
      /*loading*/
      ctx2[6]
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const indicator_slot_template = (
    /*#slots*/
    ctx[15].indicator
  );
  const indicator_slot = create_slot(
    indicator_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_indicator_slot_context$3
  );
  let span_levels = [
    { class: (
      /*finalContainerClass*/
      ctx[7]
    ) },
    exclude(
      /*$$props*/
      ctx[10],
      ["use", "class", "src"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (if_block)
        if_block.c();
      t2 = space();
      if (indicator_slot)
        indicator_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      t2 = claim_space(span_nodes);
      if (indicator_slot)
        indicator_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(span, null);
      }
      append_hydration(span, t2);
      if (indicator_slot) {
        indicator_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[9].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(span, t2);
        } else {
          if_block = null;
        }
      }
      if (indicator_slot) {
        if (indicator_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            indicator_slot,
            indicator_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              indicator_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_indicator_slot_changes$3
            ),
            get_indicator_slot_context$3
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalContainerClass*/
        128) && { class: (
          /*finalContainerClass*/
          ctx2[7]
        ) },
        dirty & /*$$props*/
        1024 && exclude(
          /*$$props*/
          ctx2[10],
          ["use", "class", "src"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(indicator_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(indicator_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (indicator_slot)
        indicator_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4$b(ctx) {
  let placeholder_1;
  let current;
  placeholder_1 = new Placeholder$3({ props: { loading: true } });
  return {
    c() {
      create_component(placeholder_1.$$.fragment);
    },
    l(nodes) {
      claim_component(placeholder_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(placeholder_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(placeholder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(placeholder_1, detaching);
    }
  };
}
function create_if_block_2$h(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3$g, create_else_block$e];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[11].placeholder
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_1$s(ctx) {
  let img;
  let img_style_value;
  let img_src_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", {
        class: true,
        style: true,
        src: true,
        alt: true
      });
      this.h();
    },
    h() {
      attr(
        img,
        "class",
        /*finalClass*/
        ctx[8]
      );
      attr(img, "style", img_style_value = /*$$props*/
      ctx[10].style);
      if (!src_url_equal(img.src, img_src_value = /*src*/
      ctx[1] || ""))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*alt*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*finalClass*/
      256) {
        attr(
          img,
          "class",
          /*finalClass*/
          ctx2[8]
        );
      }
      if (dirty & /*$$props*/
      1024 && img_style_value !== (img_style_value = /*$$props*/
      ctx2[10].style)) {
        attr(img, "style", img_style_value);
      }
      if (dirty & /*src*/
      2 && !src_url_equal(img.src, img_src_value = /*src*/
      ctx2[1] || "")) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*alt*/
      4) {
        attr(
          img,
          "alt",
          /*alt*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_else_block$e(ctx) {
  let placeholder_1;
  let current;
  placeholder_1 = new Placeholder$3({});
  return {
    c() {
      create_component(placeholder_1.$$.fragment);
    },
    l(nodes) {
      claim_component(placeholder_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(placeholder_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(placeholder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(placeholder_1, detaching);
    }
  };
}
function create_if_block_3$g(ctx) {
  let current;
  const placeholder_slot_template = (
    /*#slots*/
    ctx[15].placeholder
  );
  const placeholder_slot = create_slot(
    placeholder_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    get_placeholder_slot_context$3
  );
  return {
    c() {
      if (placeholder_slot)
        placeholder_slot.c();
    },
    l(nodes) {
      if (placeholder_slot)
        placeholder_slot.l(nodes);
    },
    m(target, anchor) {
      if (placeholder_slot) {
        placeholder_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (placeholder_slot) {
        if (placeholder_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            placeholder_slot,
            placeholder_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              placeholder_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              get_placeholder_slot_changes$3
            ),
            get_placeholder_slot_context$3
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(placeholder_slot, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_slot, local);
      current = false;
    },
    d(detaching) {
      if (placeholder_slot)
        placeholder_slot.d(detaching);
    }
  };
}
function create_fragment$1V(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$F, create_if_block_5$b];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*src*/
      ctx2[1]
    )
      return 0;
    if (
      /*initials*/
      ctx2[3]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
const srcClass$2 = "inline-block absolute";
const srcContainerClass$2 = "inline-block h-8 w-8 relative align-middle";
const initialsClass = "inline-flex h-8 w-8 items-center justify-center align-middle bg-default text-default-content";
const circleClass$5 = "rounded-full";
const roundedClass$5 = "rounded-md";
function instance$1T($$self, $$props, $$invalidate) {
  let finalClass;
  let finalContainerClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { src = void 0 } = $$props;
  let { alt = "avatar" } = $$props;
  let { shape = "circle" } = $$props;
  let { initials = void 0 } = $$props;
  let { placeholder = true } = $$props;
  let loaded = false;
  let failed = false;
  let loading = true;
  setContext("feed-avatar-shape", shape);
  setContext("feed-avatar-placeholder", placeholder);
  onMount(() => {
    if (src) {
      const image = new Image();
      image.src = src;
      $$invalidate(6, loading = true);
      image.onload = () => {
        $$invalidate(6, loading = false);
        $$invalidate(4, loaded = true);
      };
      image.onerror = () => {
        $$invalidate(6, loading = false);
        $$invalidate(5, failed = true);
      };
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("src" in $$new_props)
      $$invalidate(1, src = $$new_props.src);
    if ("alt" in $$new_props)
      $$invalidate(2, alt = $$new_props.alt);
    if ("shape" in $$new_props)
      $$invalidate(12, shape = $$new_props.shape);
    if ("initials" in $$new_props)
      $$invalidate(3, initials = $$new_props.initials);
    if ("placeholder" in $$new_props)
      $$invalidate(13, placeholder = $$new_props.placeholder);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(8, finalClass = twMerge(src && !initials ? srcClass$2 : false, initials && !src ? initialsClass : false, shape === "circle" ? circleClass$5 : false, shape === "rounded" ? roundedClass$5 : false, $$props.class));
    $$invalidate(7, finalContainerClass = twMerge(src && !initials ? srcContainerClass$2 : false, shape === "circle" ? circleClass$5 : false, shape === "rounded" ? roundedClass$5 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    src,
    alt,
    initials,
    loaded,
    failed,
    loading,
    finalContainerClass,
    finalClass,
    forwardEvents,
    $$props,
    $$slots,
    shape,
    placeholder,
    $$scope,
    slots
  ];
}
let Avatar$3 = class Avatar4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1T, create_fragment$1V, safe_not_equal, {
      use: 0,
      src: 1,
      alt: 2,
      shape: 12,
      initials: 3,
      placeholder: 13
    });
  }
};
function create_fragment$1U(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1m = "whitespace-nowrap text-right text-sm text-secondary-content";
function instance$1S($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1m, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
class DateTime extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1S, create_fragment$1U, safe_not_equal, { use: 0 });
  }
}
function create_fragment$1T(ctx) {
  let span;
  let svg;
  let useActions_action;
  let span_style_value;
  let mounted;
  let dispose;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: (
      /*width*/
      ctx[2]
    ) },
    { height: (
      /*height*/
      ctx[3]
    ) },
    { viewBox: (
      /*viewBox*/
      ctx[1]
    ) },
    { stroke: (
      /*stroke*/
      ctx[5]
    ) },
    { fill: (
      /*fill*/
      ctx[6]
    ) },
    { color: (
      /*color*/
      ctx[4]
    ) },
    exclude(
      /*$$props*/
      ctx[10],
      [
        "use",
        "data",
        "fill",
        "class",
        "style",
        "viewBox",
        "width",
        "height",
        "stroke"
      ]
    )
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      svg = svg_element("svg");
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, style: true });
      var span_nodes = children(span);
      svg = claim_svg_element(span_nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        stroke: true,
        fill: true,
        color: true
      });
      var svg_nodes = children(svg);
      svg_nodes.forEach(detach);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_svg_attributes(svg, svg_data);
      attr(
        span,
        "class",
        /*finalClass*/
        ctx[7]
      );
      attr(span, "style", span_style_value = /*$$props*/
      ctx[10].style);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, svg);
      svg.innerHTML = /*elements*/
      ctx[8];
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svg,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[9].call(null, svg)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*elements*/
      256)
        svg.innerHTML = /*elements*/
        ctx2[8];
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty & /*width*/
        4 && { width: (
          /*width*/
          ctx2[2]
        ) },
        dirty & /*height*/
        8 && { height: (
          /*height*/
          ctx2[3]
        ) },
        dirty & /*viewBox*/
        2 && { viewBox: (
          /*viewBox*/
          ctx2[1]
        ) },
        dirty & /*stroke*/
        32 && { stroke: (
          /*stroke*/
          ctx2[5]
        ) },
        dirty & /*fill*/
        64 && { fill: (
          /*fill*/
          ctx2[6]
        ) },
        dirty & /*color*/
        16 && { color: (
          /*color*/
          ctx2[4]
        ) },
        dirty & /*$$props*/
        1024 && exclude(
          /*$$props*/
          ctx2[10],
          [
            "use",
            "data",
            "fill",
            "class",
            "style",
            "viewBox",
            "width",
            "height",
            "stroke"
          ]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      if (dirty & /*finalClass*/
      128) {
        attr(
          span,
          "class",
          /*finalClass*/
          ctx2[7]
        );
      }
      if (dirty & /*$$props*/
      1024 && span_style_value !== (span_style_value = /*$$props*/
      ctx2[10].style)) {
        attr(span, "style", span_style_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1l = "text-white";
function extractViewBox$6(svg) {
  const regex = /viewBox="([\d\- ]+)"/;
  const res = regex.exec(svg);
  if (!res)
    return "0 0 24 24";
  return res[1];
}
function instance$1R($$self, $$props, $$invalidate) {
  let elements2;
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { data = "" } = $$props;
  let { viewBox = extractViewBox$6(data) } = $$props;
  let { size = "24px" } = $$props;
  let { width: width2 = size } = $$props;
  let { height = size } = $$props;
  let { color: color2 = "currentColor" } = $$props;
  let { stroke = void 0 } = $$props;
  let { fill: fill2 = color2 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("data" in $$new_props)
      $$invalidate(11, data = $$new_props.data);
    if ("viewBox" in $$new_props)
      $$invalidate(1, viewBox = $$new_props.viewBox);
    if ("size" in $$new_props)
      $$invalidate(12, size = $$new_props.size);
    if ("width" in $$new_props)
      $$invalidate(2, width2 = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(3, height = $$new_props.height);
    if ("color" in $$new_props)
      $$invalidate(4, color2 = $$new_props.color);
    if ("stroke" in $$new_props)
      $$invalidate(5, stroke = $$new_props.stroke);
    if ("fill" in $$new_props)
      $$invalidate(6, fill2 = $$new_props.fill);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data*/
    2048) {
      $$invalidate(8, elements2 = data.replace(/<svg ([^>]*)>/, "").replace("</svg>", ""));
    }
    $$invalidate(7, finalClass = twMerge(defaultClass$1l, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    viewBox,
    width2,
    height,
    color2,
    stroke,
    fill2,
    finalClass,
    elements2,
    forwardEvents,
    $$props,
    data,
    size
  ];
}
let Icon$4 = class Icon3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1R, create_fragment$1T, safe_not_equal, {
      use: 0,
      data: 11,
      viewBox: 1,
      size: 12,
      width: 2,
      height: 3,
      color: 4,
      stroke: 5,
      fill: 6
    });
  }
};
const get_avatar_slot_changes$3 = (dirty) => ({});
const get_avatar_slot_context$3 = (ctx) => ({});
const get_icon_slot_changes$b = (dirty) => ({});
const get_icon_slot_context$b = (ctx) => ({});
function create_fragment$1S(ctx) {
  let div2;
  let span;
  let t0;
  let t1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = (
    /*#slots*/
    ctx[5].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_icon_slot_context$b
  );
  const avatar_slot_template = (
    /*#slots*/
    ctx[5].avatar
  );
  const avatar_slot = create_slot(
    avatar_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_avatar_slot_context$3
  );
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      span = element("span");
      if (icon_slot)
        icon_slot.c();
      t0 = space();
      if (avatar_slot)
        avatar_slot.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div_nodes = children(div2);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (icon_slot)
        icon_slot.l(span_nodes);
      t0 = claim_space(span_nodes);
      if (avatar_slot)
        avatar_slot.l(span_nodes);
      t1 = claim_space(span_nodes);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, span);
      if (icon_slot) {
        icon_slot.m(span, null);
      }
      append_hydration(span, t0);
      if (avatar_slot) {
        avatar_slot.m(span, null);
      }
      append_hydration(span, t1);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_icon_slot_changes$b
            ),
            get_icon_slot_context$b
          );
        }
      }
      if (avatar_slot) {
        if (avatar_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            avatar_slot,
            avatar_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              avatar_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_avatar_slot_changes$3
            ),
            get_avatar_slot_context$3
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(avatar_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(avatar_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (icon_slot)
        icon_slot.d(detaching);
      if (avatar_slot)
        avatar_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1k = "h-8 w-8 bg-default rounded-full flex items-center justify-center ring-8 ring-surface";
function instance$1Q($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1k, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Leading$2 = class Leading extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1Q, create_fragment$1S, safe_not_equal, { use: 0 });
  }
};
function create_fragment$1R(ctx) {
  let p;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let p_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let p_data = {};
  for (let i2 = 0; i2 < p_levels.length; i2 += 1) {
    p_data = assign$1(p_data, p_levels[i2]);
  }
  return {
    c() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(p, p_data);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            p,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, p)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1j = "text-sm text-secondary-content";
function instance$1P($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1j, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Content$3 = class Content3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1P, create_fragment$1R, safe_not_equal, { use: 0 });
  }
};
const Feed2 = Feed$1;
Feed2.Item = Item$3;
Feed2.Item.Connector = Connector;
Feed2.Item.Leading = Leading$2;
Feed2.Item.Leading.Avatar = Avatar$3;
Feed2.Item.Leading.Icon = Icon$4;
Feed2.Item.DateTime = DateTime;
Feed2.Item.Content = Content$3;
const get_action_slot_changes$1 = (dirty) => ({});
const get_action_slot_context$1 = (ctx) => ({});
const get_divider_slot_changes = (dirty) => ({});
const get_divider_slot_context = (ctx) => ({});
const get_description_slot_changes$4 = (dirty) => ({});
const get_description_slot_context$4 = (ctx) => ({});
const get_title_slot_changes$5 = (dirty) => ({});
const get_title_slot_context$5 = (ctx) => ({});
const get_icon_slot_changes$a = (dirty) => ({});
const get_icon_slot_context$a = (ctx) => ({});
function create_fragment$1Q(ctx) {
  let button;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let input_1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = (
    /*#slots*/
    ctx[27].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    get_icon_slot_context$a
  );
  const title_slot_template = (
    /*#slots*/
    ctx[27].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    get_title_slot_context$5
  );
  const description_slot_template = (
    /*#slots*/
    ctx[27].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    get_description_slot_context$4
  );
  const divider_slot_template = (
    /*#slots*/
    ctx[27].divider
  );
  const divider_slot = create_slot(
    divider_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    get_divider_slot_context
  );
  const action_slot_template = (
    /*#slots*/
    ctx[27].action
  );
  const action_slot = create_slot(
    action_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    get_action_slot_context$1
  );
  const default_slot_template = (
    /*#slots*/
    ctx[27].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    null
  );
  let button_levels = [
    { type: "button" },
    { class: (
      /*finalClass*/
      ctx[6]
    ) },
    exclude(
      /*$$props*/
      ctx[17],
      ["use", "class"]
    )
  ];
  let button_data = {};
  for (let i2 = 0; i2 < button_levels.length; i2 += 1) {
    button_data = assign$1(button_data, button_levels[i2]);
  }
  return {
    c() {
      button = element("button");
      if (icon_slot)
        icon_slot.c();
      t0 = space();
      if (title_slot)
        title_slot.c();
      t1 = space();
      if (description_slot)
        description_slot.c();
      t2 = space();
      if (divider_slot)
        divider_slot.c();
      t3 = space();
      if (action_slot)
        action_slot.c();
      t4 = space();
      if (default_slot)
        default_slot.c();
      t5 = space();
      input_1 = element("input");
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      if (icon_slot)
        icon_slot.l(button_nodes);
      t0 = claim_space(button_nodes);
      if (title_slot)
        title_slot.l(button_nodes);
      t1 = claim_space(button_nodes);
      if (description_slot)
        description_slot.l(button_nodes);
      t2 = claim_space(button_nodes);
      if (divider_slot)
        divider_slot.l(button_nodes);
      t3 = claim_space(button_nodes);
      if (action_slot)
        action_slot.l(button_nodes);
      t4 = claim_space(button_nodes);
      if (default_slot)
        default_slot.l(button_nodes);
      t5 = claim_space(button_nodes);
      input_1 = claim_element(button_nodes, "INPUT", {
        id: true,
        name: true,
        class: true,
        type: true,
        accept: true
      });
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(
        input_1,
        "id",
        /*name*/
        ctx[1]
      );
      attr(
        input_1,
        "name",
        /*name*/
        ctx[1]
      );
      attr(input_1, "class", "opacity-0 absolute top-0 left-0 pointer-events-none");
      attr(input_1, "type", "file");
      input_1.multiple = /*multiple*/
      ctx[2];
      attr(
        input_1,
        "accept",
        /*accept*/
        ctx[4]
      );
      input_1.disabled = /*disabled*/
      ctx[3];
      set_attributes(button, button_data);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      if (icon_slot) {
        icon_slot.m(button, null);
      }
      append_hydration(button, t0);
      if (title_slot) {
        title_slot.m(button, null);
      }
      append_hydration(button, t1);
      if (description_slot) {
        description_slot.m(button, null);
      }
      append_hydration(button, t2);
      if (divider_slot) {
        divider_slot.m(button, null);
      }
      append_hydration(button, t3);
      if (action_slot) {
        action_slot.m(button, null);
      }
      append_hydration(button, t4);
      if (default_slot) {
        default_slot.m(button, null);
      }
      append_hydration(button, t5);
      append_hydration(button, input_1);
      ctx[28](input_1);
      if (button.autofocus)
        button.focus();
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input_1,
            "change",
            /*handleChange*/
            ctx[10]
          ),
          listen(
            input_1,
            "focus",
            /*handleFocus*/
            ctx[15]
          ),
          listen(
            input_1,
            "blur",
            /*handleBlur*/
            ctx[16]
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            button,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[7].call(null, button)
          ),
          listen(
            button,
            "dragenter",
            /*handleEnter*/
            ctx[12]
          ),
          listen(
            button,
            "dragover",
            /*handleDragOver*/
            ctx[14]
          ),
          listen(
            button,
            "drop",
            /*handleDrop*/
            ctx[11]
          ),
          listen(
            button,
            "dragleave",
            /*handleLeave*/
            ctx[13]
          ),
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[29]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        67108864)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[26]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[26],
              dirty,
              get_icon_slot_changes$a
            ),
            get_icon_slot_context$a
          );
        }
      }
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        67108864)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[26]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[26],
              dirty,
              get_title_slot_changes$5
            ),
            get_title_slot_context$5
          );
        }
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        67108864)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[26]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[26],
              dirty,
              get_description_slot_changes$4
            ),
            get_description_slot_context$4
          );
        }
      }
      if (divider_slot) {
        if (divider_slot.p && (!current || dirty & /*$$scope*/
        67108864)) {
          update_slot_base(
            divider_slot,
            divider_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[26]
            ) : get_slot_changes(
              divider_slot_template,
              /*$$scope*/
              ctx2[26],
              dirty,
              get_divider_slot_changes
            ),
            get_divider_slot_context
          );
        }
      }
      if (action_slot) {
        if (action_slot.p && (!current || dirty & /*$$scope*/
        67108864)) {
          update_slot_base(
            action_slot,
            action_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[26]
            ) : get_slot_changes(
              action_slot_template,
              /*$$scope*/
              ctx2[26],
              dirty,
              get_action_slot_changes$1
            ),
            get_action_slot_context$1
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        67108864)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[26]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[26],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*name*/
      2) {
        attr(
          input_1,
          "id",
          /*name*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*name*/
      2) {
        attr(
          input_1,
          "name",
          /*name*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*multiple*/
      4) {
        input_1.multiple = /*multiple*/
        ctx2[2];
      }
      if (!current || dirty & /*accept*/
      16) {
        attr(
          input_1,
          "accept",
          /*accept*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*disabled*/
      8) {
        input_1.disabled = /*disabled*/
        ctx2[3];
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        { type: "button" },
        (!current || dirty & /*finalClass*/
        64) && { class: (
          /*finalClass*/
          ctx2[6]
        ) },
        dirty & /*$$props*/
        131072 && exclude(
          /*$$props*/
          ctx2[17],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(title_slot, local);
      transition_in(description_slot, local);
      transition_in(divider_slot, local);
      transition_in(action_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(title_slot, local);
      transition_out(description_slot, local);
      transition_out(divider_slot, local);
      transition_out(action_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (icon_slot)
        icon_slot.d(detaching);
      if (title_slot)
        title_slot.d(detaching);
      if (description_slot)
        description_slot.d(detaching);
      if (divider_slot)
        divider_slot.d(detaching);
      if (action_slot)
        action_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      ctx[28](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1i = "relative text-center rounded-lg border border-dashed border-2 px-6 pt-5 pb-7 border-border rounded-md bg-surface outline-offset-0";
const disabledClass = "border-default cursor-not-allowed bg-default bg-opacity-75";
const notDisabledClass = "active:[&:not(:focus):not(:focus-within)]:hover:animate-none active:[&:not(:focus):not(:focus-within)]:hover:scale-[97.5%] cursor-pointer block w-full px-3 outline-none focus:outline-none sm:text-sm";
function instance$1O($$self, $$props, $$invalidate) {
  let finalClass;
  let $hasFocus;
  let $hovering;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { onDrop } = $$props;
  let { onEnter = null } = $$props;
  let { onLeave = null } = $$props;
  let { name } = $$props;
  let { multiple = false } = $$props;
  let { maxFileSize = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { accept = void 0 } = $$props;
  let { allowedExtensions = void 0 } = $$props;
  let { strict = false } = $$props;
  let hovering = writable(false);
  component_subscribe($$self, hovering, (value) => $$invalidate(25, $hovering = value));
  let hasFocus = writable(false);
  component_subscribe($$self, hasFocus, (value) => $$invalidate(24, $hasFocus = value));
  let input;
  function validate(files) {
    let results = { accepted: [], rejected: [] };
    files.forEach((f) => {
      let extension = f.name.split(".").pop();
      if (allowedExtensions && extension && !allowedExtensions.includes(extension)) {
        results.rejected.push(f);
      } else if (maxFileSize && f.size > maxFileSize) {
        results.rejected.push(f);
      } else {
        results.accepted.push(f);
      }
    });
    if (!multiple && results.accepted.length > 1) {
      return {
        accepted: [results.accepted[0]],
        rejected: [...results.rejected, ...results.accepted.slice(1)]
      };
    }
    if (strict && results.rejected) {
      results = {
        accepted: [],
        rejected: [...results.rejected, ...results.accepted]
      };
    }
    return results;
  }
  function handleChange(e2) {
    if (disabled)
      return;
    e2.preventDefault();
    const fileList = e2.target.files;
    const files = Array.from(fileList);
    onDrop(validate(files));
    set_store_value(hovering, $hovering = false, $hovering);
  }
  function handleDrop(e2) {
    var _a2;
    if (disabled)
      return;
    e2.preventDefault();
    if (!((_a2 = e2 == null ? void 0 : e2.dataTransfer) == null ? void 0 : _a2.items))
      return;
    const files = Array.from(e2.dataTransfer.files);
    onDrop(validate(files));
    set_store_value(hovering, $hovering = false, $hovering);
  }
  function handleEnter() {
    if (disabled)
      return;
    set_store_value(hovering, $hovering = true, $hovering);
    if (onEnter)
      onEnter();
  }
  function handleLeave() {
    if (disabled)
      return;
    set_store_value(hovering, $hovering = false, $hovering);
    if (onLeave)
      onLeave();
  }
  function handleDragOver(e2) {
    if (disabled)
      return;
    e2.preventDefault();
    if (!$hovering)
      set_store_value(hovering, $hovering = true, $hovering);
  }
  function handleFocus(e2) {
    set_store_value(hasFocus, $hasFocus = true, $hasFocus);
  }
  function handleBlur() {
    set_store_value(hasFocus, $hasFocus = false, $hasFocus);
  }
  setContext("filepicker-disabled", disabled);
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(5, input);
    });
  }
  const click_handler = () => input.click();
  $$self.$$set = ($$new_props) => {
    $$invalidate(17, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("onDrop" in $$new_props)
      $$invalidate(18, onDrop = $$new_props.onDrop);
    if ("onEnter" in $$new_props)
      $$invalidate(19, onEnter = $$new_props.onEnter);
    if ("onLeave" in $$new_props)
      $$invalidate(20, onLeave = $$new_props.onLeave);
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("multiple" in $$new_props)
      $$invalidate(2, multiple = $$new_props.multiple);
    if ("maxFileSize" in $$new_props)
      $$invalidate(21, maxFileSize = $$new_props.maxFileSize);
    if ("disabled" in $$new_props)
      $$invalidate(3, disabled = $$new_props.disabled);
    if ("accept" in $$new_props)
      $$invalidate(4, accept = $$new_props.accept);
    if ("allowedExtensions" in $$new_props)
      $$invalidate(22, allowedExtensions = $$new_props.allowedExtensions);
    if ("strict" in $$new_props)
      $$invalidate(23, strict = $$new_props.strict);
    if ("$$scope" in $$new_props)
      $$invalidate(26, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(6, finalClass = twMerge(
      defaultClass$1i,
      $hovering ? 'after:content-[""] after:w-full after:h-full after:absolute after:inset-0 after:bg-primary after:bg-opacity-30 after:rounded-md border-primary border-solid' : false,
      $hasFocus ? "border-transparent ring-[1px] ring-primary" : false,
      disabled ? disabledClass : notDisabledClass,
      $$props.class
    ));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    name,
    multiple,
    disabled,
    accept,
    input,
    finalClass,
    forwardEvents,
    hovering,
    hasFocus,
    handleChange,
    handleDrop,
    handleEnter,
    handleLeave,
    handleDragOver,
    handleFocus,
    handleBlur,
    $$props,
    onDrop,
    onEnter,
    onLeave,
    maxFileSize,
    allowedExtensions,
    strict,
    $hasFocus,
    $hovering,
    $$scope,
    slots,
    input_1_binding,
    click_handler
  ];
}
let FilePicker$1 = class FilePicker extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1O, create_fragment$1Q, safe_not_equal, {
      use: 0,
      onDrop: 18,
      onEnter: 19,
      onLeave: 20,
      name: 1,
      multiple: 2,
      maxFileSize: 21,
      disabled: 3,
      accept: 4,
      allowedExtensions: 22,
      strict: 23
    });
  }
};
function create_fragment$1P(ctx) {
  let span;
  let svg;
  let useActions_action;
  let span_style_value;
  let mounted;
  let dispose;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: (
      /*width*/
      ctx[2]
    ) },
    { height: (
      /*height*/
      ctx[3]
    ) },
    { viewBox: (
      /*viewBox*/
      ctx[1]
    ) },
    { stroke: (
      /*stroke*/
      ctx[5]
    ) },
    { fill: (
      /*fill*/
      ctx[6]
    ) },
    { color: (
      /*color*/
      ctx[4]
    ) },
    exclude(
      /*$$props*/
      ctx[10],
      [
        "use",
        "data",
        "class",
        "style",
        "fill",
        "viewBox",
        "width",
        "height",
        "stroke"
      ]
    )
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      svg = svg_element("svg");
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, style: true });
      var span_nodes = children(span);
      svg = claim_svg_element(span_nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        stroke: true,
        fill: true,
        color: true
      });
      var svg_nodes = children(svg);
      svg_nodes.forEach(detach);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_svg_attributes(svg, svg_data);
      attr(
        span,
        "class",
        /*finalClass*/
        ctx[7]
      );
      attr(span, "style", span_style_value = /*$$props*/
      ctx[10].style);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, svg);
      svg.innerHTML = /*elements*/
      ctx[8];
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svg,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[9].call(null, svg)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*elements*/
      256)
        svg.innerHTML = /*elements*/
        ctx2[8];
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty & /*width*/
        4 && { width: (
          /*width*/
          ctx2[2]
        ) },
        dirty & /*height*/
        8 && { height: (
          /*height*/
          ctx2[3]
        ) },
        dirty & /*viewBox*/
        2 && { viewBox: (
          /*viewBox*/
          ctx2[1]
        ) },
        dirty & /*stroke*/
        32 && { stroke: (
          /*stroke*/
          ctx2[5]
        ) },
        dirty & /*fill*/
        64 && { fill: (
          /*fill*/
          ctx2[6]
        ) },
        dirty & /*color*/
        16 && { color: (
          /*color*/
          ctx2[4]
        ) },
        dirty & /*$$props*/
        1024 && exclude(
          /*$$props*/
          ctx2[10],
          [
            "use",
            "data",
            "class",
            "style",
            "fill",
            "viewBox",
            "width",
            "height",
            "stroke"
          ]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      if (dirty & /*finalClass*/
      128) {
        attr(
          span,
          "class",
          /*finalClass*/
          ctx2[7]
        );
      }
      if (dirty & /*$$props*/
      1024 && span_style_value !== (span_style_value = /*$$props*/
      ctx2[10].style)) {
        attr(span, "style", span_style_value);
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1h = " flex items-center justify-center";
function extractViewBox$5(svg) {
  const regex = /viewBox="([\d\- ]+)"/;
  const res = regex.exec(svg);
  if (!res)
    return "0 0 24 24";
  return res[1];
}
function instance$1N($$self, $$props, $$invalidate) {
  let elements2;
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { data = "" } = $$props;
  let { viewBox = extractViewBox$5(data) } = $$props;
  let { size = "48px" } = $$props;
  let { width: width2 = size } = $$props;
  let { height = size } = $$props;
  let { color: color2 = "currentColor" } = $$props;
  let { stroke = void 0 } = $$props;
  let { fill: fill2 = color2 } = $$props;
  let disabled = getContext("filepicker-disabled");
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("data" in $$new_props)
      $$invalidate(11, data = $$new_props.data);
    if ("viewBox" in $$new_props)
      $$invalidate(1, viewBox = $$new_props.viewBox);
    if ("size" in $$new_props)
      $$invalidate(12, size = $$new_props.size);
    if ("width" in $$new_props)
      $$invalidate(2, width2 = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(3, height = $$new_props.height);
    if ("color" in $$new_props)
      $$invalidate(4, color2 = $$new_props.color);
    if ("stroke" in $$new_props)
      $$invalidate(5, stroke = $$new_props.stroke);
    if ("fill" in $$new_props)
      $$invalidate(6, fill2 = $$new_props.fill);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data*/
    2048) {
      $$invalidate(8, elements2 = data.replace(/<svg ([^>]*)>/, "").replace("</svg>", ""));
    }
    $$invalidate(7, finalClass = twMerge(
      defaultClass$1h,
      disabled ? "text-secondary-content opacity-30" : "text-content",
      $$props.class
    ));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    viewBox,
    width2,
    height,
    color2,
    stroke,
    fill2,
    finalClass,
    elements2,
    forwardEvents,
    $$props,
    data,
    size
  ];
}
let Icon$3 = class Icon4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1N, create_fragment$1P, safe_not_equal, {
      use: 0,
      data: 11,
      viewBox: 1,
      size: 12,
      width: 2,
      height: 3,
      color: 4,
      stroke: 5,
      fill: 6
    });
  }
};
function create_fragment$1O(ctx) {
  let h32;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let h3_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let h3_data = {};
  for (let i2 = 0; i2 < h3_levels.length; i2 += 1) {
    h3_data = assign$1(h3_data, h3_levels[i2]);
  }
  return {
    c() {
      h32 = element("h3");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      h32 = claim_element(nodes, "H3", { class: true });
      var h3_nodes = children(h32);
      if (default_slot)
        default_slot.l(h3_nodes);
      h3_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(h32, h3_data);
    },
    m(target, anchor) {
      insert_hydration(target, h32, anchor);
      if (default_slot) {
        default_slot.m(h32, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            h32,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, h32)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h32, h3_data = get_spread_update(h3_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h32);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1g = "mt-1 font-medium text-content";
function instance$1M($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let disabled = getContext("filepicker-disabled");
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1g, disabled ? "opacity-30" : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Title$6 = class Title4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1M, create_fragment$1O, safe_not_equal, { use: 0 });
  }
};
function create_fragment$1N(ctx) {
  let p;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let p_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let p_data = {};
  for (let i2 = 0; i2 < p_levels.length; i2 += 1) {
    p_data = assign$1(p_data, p_levels[i2]);
  }
  return {
    c() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(p, p_data);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            p,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, p)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1f = "mt-1 text-xs text-secondary-content";
function instance$1L($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let disabled = getContext("filepicker-disabled");
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1f, disabled ? "opacity-30" : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Description$4 = class Description4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1L, create_fragment$1N, safe_not_equal, { use: 0 });
  }
};
function create_fragment$1M(ctx) {
  let p;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let p_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let p_data = {};
  for (let i2 = 0; i2 < p_levels.length; i2 += 1) {
    p_data = assign$1(p_data, p_levels[i2]);
  }
  return {
    c() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(p, p_data);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            p,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, p)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1e = "mt-6 text-sm";
function instance$1K($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1e, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Action$2 = class Action2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1K, create_fragment$1M, safe_not_equal, { use: 0 });
  }
};
const get_label_slot_changes$6 = (dirty) => ({});
const get_label_slot_context$6 = (ctx) => ({});
function create_if_block$E(ctx) {
  let div2;
  let t2;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[7].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_label_slot_context$6
  );
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  return {
    c() {
      div2 = element("div");
      if (label_slot)
        label_slot.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (label_slot)
        label_slot.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "relative flex");
      toggle_class(
        div2,
        "justify-start",
        /*position*/
        ctx[1] === "left"
      );
      toggle_class(
        div2,
        "justify-center",
        /*position*/
        ctx[1] === "center"
      );
      toggle_class(
        div2,
        "justify-end",
        /*position*/
        ctx[1] === "right"
      );
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (label_slot) {
        label_slot.m(div2, null);
      }
      append_hydration(div2, t2);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_label_slot_changes$6
            ),
            get_label_slot_context$6
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*position*/
      2) {
        toggle_class(
          div2,
          "justify-start",
          /*position*/
          ctx2[1] === "left"
        );
      }
      if (!current || dirty & /*position*/
      2) {
        toggle_class(
          div2,
          "justify-center",
          /*position*/
          ctx2[1] === "center"
        );
      }
      if (!current || dirty & /*position*/
      2) {
        toggle_class(
          div2,
          "justify-end",
          /*position*/
          ctx2[1] === "right"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (label_slot)
        label_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$1L(ctx) {
  let div2;
  let div1;
  let textContent = `<div class="w-full border-t border-border"></div>`;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$$slots*/
    (ctx[5].label || /*$$slots*/
    ctx[5].default) && create_if_block$E(ctx)
  );
  let div2_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let div_data_2 = {};
  for (let i2 = 0; i2 < div2_levels.length; i2 += 1) {
    div_data_2 = assign$1(div_data_2, div2_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div1.innerHTML = textContent;
      t2 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", {
        class: true,
        "aria-hidden": true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(div1) !== "svelte-qa7ndr")
        div1.innerHTML = textContent;
      t2 = claim_space(div2_nodes);
      if (if_block)
        if_block.l(div2_nodes);
      div2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div1, "class", "absolute inset-0 flex items-center");
      attr(div1, "aria-hidden", "true");
      set_attributes(div2, div_data_2);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, div1);
      append_hydration(div2, t2);
      if (if_block)
        if_block.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[5].label || /*$$slots*/
        ctx2[5].default
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$E(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1d = "relative my-4";
function instance$1J($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { position = "center" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("position" in $$new_props)
      $$invalidate(1, position = $$new_props.position);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(2, finalClass = twMerge(defaultClass$1d, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, position, finalClass, forwardEvents, $$props, $$slots, $$scope, slots];
}
class Divider2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1J, create_fragment$1L, safe_not_equal, { use: 0, position: 1 });
  }
}
function create_fragment$1K(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1c = "text-sm px-2 bg-surface text-content";
function instance$1I($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1c, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Label$5 = class Label7 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1I, create_fragment$1K, safe_not_equal, { use: 0 });
  }
};
const FilePicker2 = FilePicker$1;
FilePicker2.Icon = Icon$3;
FilePicker2.Title = Title$6;
FilePicker2.Description = Description$4;
FilePicker2.Action = Action$2;
FilePicker2.Divider = Divider2;
FilePicker2.Divider.Label = Label$5;
function create_fragment$1J(ctx) {
  let ul;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let ul_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let ul_data = {};
  for (let i2 = 0; i2 < ul_levels.length; i2 += 1) {
    ul_data = assign$1(ul_data, ul_levels[i2]);
  }
  return {
    c() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      ul = claim_element(nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(ul, ul_data);
    },
    m(target, anchor) {
      insert_hydration(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            ul,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, ul)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const dividedClass = "divide-y divide-border";
const borderedClass$1 = "border border-border";
function instance$1H($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { divided = true } = $$props;
  let { bordered = false } = $$props;
  let { edgeToEdge = false } = $$props;
  setContext("list-bordered", bordered || edgeToEdge);
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("divided" in $$new_props)
      $$invalidate(4, divided = $$new_props.divided);
    if ("bordered" in $$new_props)
      $$invalidate(5, bordered = $$new_props.bordered);
    if ("edgeToEdge" in $$new_props)
      $$invalidate(6, edgeToEdge = $$new_props.edgeToEdge);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(divided ? dividedClass : false, bordered ? borderedClass$1 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    finalClass,
    forwardEvents,
    $$props,
    divided,
    bordered,
    edgeToEdge,
    $$scope,
    slots
  ];
}
class FilePreview extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1H, create_fragment$1J, safe_not_equal, {
      use: 0,
      divided: 4,
      bordered: 5,
      edgeToEdge: 6
    });
  }
}
const get_extra_slot_changes$4 = (dirty) => ({});
const get_extra_slot_context$4 = (ctx) => ({});
const get_upload_content_slot_changes = (dirty) => ({});
const get_upload_content_slot_context = (ctx) => ({});
const get_file_content_slot_changes = (dirty) => ({});
const get_file_content_slot_context = (ctx) => ({});
const get_leading_slot_changes$3 = (dirty) => ({});
const get_leading_slot_context$3 = (ctx) => ({});
function create_fragment$1I(ctx) {
  let li;
  let t0;
  let t1;
  let t2;
  let t3;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const leading_slot_template = (
    /*#slots*/
    ctx[5].leading
  );
  const leading_slot = create_slot(
    leading_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_leading_slot_context$3
  );
  const file_content_slot_template = (
    /*#slots*/
    ctx[5]["file-content"]
  );
  const file_content_slot = create_slot(
    file_content_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_file_content_slot_context
  );
  const upload_content_slot_template = (
    /*#slots*/
    ctx[5]["upload-content"]
  );
  const upload_content_slot = create_slot(
    upload_content_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_upload_content_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const extra_slot_template = (
    /*#slots*/
    ctx[5].extra
  );
  const extra_slot = create_slot(
    extra_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_extra_slot_context$4
  );
  let li_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let li_data = {};
  for (let i2 = 0; i2 < li_levels.length; i2 += 1) {
    li_data = assign$1(li_data, li_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      if (leading_slot)
        leading_slot.c();
      t0 = space();
      if (file_content_slot)
        file_content_slot.c();
      t1 = space();
      if (upload_content_slot)
        upload_content_slot.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
      t3 = space();
      if (extra_slot)
        extra_slot.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      if (leading_slot)
        leading_slot.l(li_nodes);
      t0 = claim_space(li_nodes);
      if (file_content_slot)
        file_content_slot.l(li_nodes);
      t1 = claim_space(li_nodes);
      if (upload_content_slot)
        upload_content_slot.l(li_nodes);
      t2 = claim_space(li_nodes);
      if (default_slot)
        default_slot.l(li_nodes);
      t3 = claim_space(li_nodes);
      if (extra_slot)
        extra_slot.l(li_nodes);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(li, li_data);
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      if (leading_slot) {
        leading_slot.m(li, null);
      }
      append_hydration(li, t0);
      if (file_content_slot) {
        file_content_slot.m(li, null);
      }
      append_hydration(li, t1);
      if (upload_content_slot) {
        upload_content_slot.m(li, null);
      }
      append_hydration(li, t2);
      if (default_slot) {
        default_slot.m(li, null);
      }
      append_hydration(li, t3);
      if (extra_slot) {
        extra_slot.m(li, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            li,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, li)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (leading_slot) {
        if (leading_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            leading_slot,
            leading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              leading_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_leading_slot_changes$3
            ),
            get_leading_slot_context$3
          );
        }
      }
      if (file_content_slot) {
        if (file_content_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            file_content_slot,
            file_content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              file_content_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_file_content_slot_changes
            ),
            get_file_content_slot_context
          );
        }
      }
      if (upload_content_slot) {
        if (upload_content_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            upload_content_slot,
            upload_content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              upload_content_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_upload_content_slot_changes
            ),
            get_upload_content_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (extra_slot) {
        if (extra_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            extra_slot,
            extra_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              extra_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_extra_slot_changes$4
            ),
            get_extra_slot_context$4
          );
        }
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(leading_slot, local);
      transition_in(file_content_slot, local);
      transition_in(upload_content_slot, local);
      transition_in(default_slot, local);
      transition_in(extra_slot, local);
      current = true;
    },
    o(local) {
      transition_out(leading_slot, local);
      transition_out(file_content_slot, local);
      transition_out(upload_content_slot, local);
      transition_out(default_slot, local);
      transition_out(extra_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (leading_slot)
        leading_slot.d(detaching);
      if (file_content_slot)
        file_content_slot.d(detaching);
      if (upload_content_slot)
        upload_content_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (extra_slot)
        extra_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1b = "flex py-4";
const borderedClass = "px-3";
function instance$1G($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const bordered = getContext("list-bordered");
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1b, bordered ? borderedClass : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Item$2 = class Item3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1G, create_fragment$1I, safe_not_equal, { use: 0 });
  }
};
const get_avatar_slot_changes$2 = (dirty) => ({});
const get_avatar_slot_context$2 = (ctx) => ({});
const get_icon_slot_changes$9 = (dirty) => ({});
const get_icon_slot_context$9 = (ctx) => ({});
function create_fragment$1H(ctx) {
  let div2;
  let t0;
  let t1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = (
    /*#slots*/
    ctx[5].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_icon_slot_context$9
  );
  const avatar_slot_template = (
    /*#slots*/
    ctx[5].avatar
  );
  const avatar_slot = create_slot(
    avatar_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_avatar_slot_context$2
  );
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (icon_slot)
        icon_slot.c();
      t0 = space();
      if (avatar_slot)
        avatar_slot.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (icon_slot)
        icon_slot.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (avatar_slot)
        avatar_slot.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (icon_slot) {
        icon_slot.m(div2, null);
      }
      append_hydration(div2, t0);
      if (avatar_slot) {
        avatar_slot.m(div2, null);
      }
      append_hydration(div2, t1);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_icon_slot_changes$9
            ),
            get_icon_slot_context$9
          );
        }
      }
      if (avatar_slot) {
        if (avatar_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            avatar_slot,
            avatar_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              avatar_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_avatar_slot_changes$2
            ),
            get_avatar_slot_context$2
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(avatar_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(avatar_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (icon_slot)
        icon_slot.d(detaching);
      if (avatar_slot)
        avatar_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1a = "h-10 w-10 rounded-full bg-default text-default-content flex items-center justify-center";
function instance$1F($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1a, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Leading$1 = class Leading2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1F, create_fragment$1H, safe_not_equal, { use: 0 });
  }
};
const Placeholder_svelte_svelte_type_style_lang$2 = "";
const get_icon_slot_changes$8 = (dirty) => ({});
const get_icon_slot_context$8 = (ctx) => ({});
function create_if_block_1$r(ctx) {
  let span;
  let icon;
  let span_class_value;
  let current;
  icon = new Icon$7({
    props: { data: account, size: (
      /*iconSize*/
      ctx[2]
    ) }
  });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", span_class_value = null_to_empty(
        /*iconContainerClass*/
        ctx[3]
      ) + " svelte-13m79ia");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & /*iconSize*/
      4)
        icon_changes.size = /*iconSize*/
        ctx2[2];
      icon.$set(icon_changes);
      if (!current || dirty & /*iconContainerClass*/
      8 && span_class_value !== (span_class_value = null_to_empty(
        /*iconContainerClass*/
        ctx2[3]
      ) + " svelte-13m79ia")) {
        attr(span, "class", span_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block$D(ctx) {
  let t2;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[10].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_icon_slot_context$8
  );
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
    },
    l(nodes) {
      if (icon_slot)
        icon_slot.l(nodes);
      t2 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      insert_hydration(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_icon_slot_changes$8
            ),
            get_icon_slot_context$8
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (icon_slot)
        icon_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$1G(ctx) {
  let div2;
  let current_block_type_index;
  let if_block;
  let useActions_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$D, create_if_block_1$r];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[7].icon || /*$$slots*/
      ctx2[7].default
    )
      return 0;
    if (
      /*placeholder*/
      ctx2[5]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[6],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
      toggle_class(div2, "svelte-13m79ia", true);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[4].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div2, null);
        } else {
          if_block = null;
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        64 && exclude(
          /*$$props*/
          ctx2[6],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(div2, "svelte-13m79ia", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, fade, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, fade, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$19 = "absolute text-content inset-0 h-full w-full flex items-center justify-center overflow-hidden bg-default";
const circleClass$4 = "rounded-full";
const roundedClass$4 = "rounded-md";
const defaultIconContainerClass$1 = "absolute text-content h-full w-full";
const xsContainerClass$1 = "bottom-[-0.25rem]";
const smContainerClass$1 = "bottom-[-0.35rem]";
const mdContainerClass$1 = "bottom-[-0.5rem]";
const lgContainerClass$1 = "text-6xl bottom-[-0.6rem]";
const xlContainerClass$1 = "bottom-[-0.75rem]";
const xsIconSize$1 = "24px";
const smIconSize$1 = "32px";
const mdIconSize$1 = "40px";
const lgIconSize$1 = "48px";
const xlIconSize$1 = "64px";
function instance$1E($$self, $$props, $$invalidate) {
  let iconContainerClass2;
  let iconSize2;
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { loading = false } = $$props;
  const shape = getContext("list-avatar-shape");
  const size = getContext("list-avatar-size");
  const placeholder = getContext("list-avatar-placeholder");
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("loading" in $$new_props)
      $$invalidate(8, loading = $$new_props.loading);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$19, loading ? "loading" : false, shape === "circle" ? circleClass$4 : false, shape === "rounded" ? roundedClass$4 : false, $$props.class));
  };
  $$invalidate(3, iconContainerClass2 = twMerge(defaultIconContainerClass$1, size === "xs" ? xsContainerClass$1 : false, size === "sm" ? smContainerClass$1 : false, size === "md" ? mdContainerClass$1 : false, size === "lg" ? lgContainerClass$1 : false, size === "xl" ? xlContainerClass$1 : false));
  $$invalidate(2, iconSize2 = twMerge(size === "xs" ? xsIconSize$1 : false, size === "sm" ? smIconSize$1 : false, size === "md" ? mdIconSize$1 : false, size === "lg" ? lgIconSize$1 : false, size === "xl" ? xlIconSize$1 : false));
  $$props = exclude_internal_props($$props);
  return [
    use,
    finalClass,
    iconSize2,
    iconContainerClass2,
    forwardEvents,
    placeholder,
    $$props,
    $$slots,
    loading,
    $$scope,
    slots
  ];
}
let Placeholder$2 = class Placeholder5 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1E, create_fragment$1G, safe_not_equal, { use: 0, loading: 8 });
  }
};
const get_indicator_slot_changes$2 = (dirty) => ({});
const get_indicator_slot_context$2 = (ctx) => ({});
const get_placeholder_slot_changes$2 = (dirty) => ({});
const get_placeholder_slot_context$2 = (ctx) => ({});
function create_if_block_5$a(ctx) {
  let span1;
  let span0;
  let t2;
  let useActions_action;
  let mounted;
  let dispose;
  let span1_levels = [
    { class: (
      /*finalClass*/
      ctx[9]
    ) },
    exclude(
      /*$$props*/
      ctx[11],
      ["use", "class"]
    )
  ];
  let span_data_1 = {};
  for (let i2 = 0; i2 < span1_levels.length; i2 += 1) {
    span_data_1 = assign$1(span_data_1, span1_levels[i2]);
  }
  return {
    c() {
      span1 = element("span");
      span0 = element("span");
      t2 = text(
        /*initials*/
        ctx[4]
      );
      this.h();
    },
    l(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t2 = claim_text(
        span0_nodes,
        /*initials*/
        ctx[4]
      );
      span0_nodes.forEach(detach);
      span1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "class", "font-bold leading-none text-current");
      toggle_class(
        span0,
        "text-xs",
        /*size*/
        ctx[3] === "xs"
      );
      toggle_class(
        span0,
        "text-sm",
        /*size*/
        ctx[3] === "sm"
      );
      toggle_class(
        span0,
        "text-xl",
        /*size*/
        ctx[3] === "lg"
      );
      toggle_class(
        span0,
        "text-2xl",
        /*size*/
        ctx[3] === "xl"
      );
      set_attributes(span1, span_data_1);
    },
    m(target, anchor) {
      insert_hydration(target, span1, anchor);
      append_hydration(span1, span0);
      append_hydration(span0, t2);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span1,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[10].call(null, span1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*initials*/
      16)
        set_data(
          t2,
          /*initials*/
          ctx2[4]
        );
      if (dirty & /*size*/
      8) {
        toggle_class(
          span0,
          "text-xs",
          /*size*/
          ctx2[3] === "xs"
        );
      }
      if (dirty & /*size*/
      8) {
        toggle_class(
          span0,
          "text-sm",
          /*size*/
          ctx2[3] === "sm"
        );
      }
      if (dirty & /*size*/
      8) {
        toggle_class(
          span0,
          "text-xl",
          /*size*/
          ctx2[3] === "lg"
        );
      }
      if (dirty & /*size*/
      8) {
        toggle_class(
          span0,
          "text-2xl",
          /*size*/
          ctx2[3] === "xl"
        );
      }
      set_attributes(span1, span_data_1 = get_spread_update(span1_levels, [
        dirty & /*finalClass*/
        512 && { class: (
          /*finalClass*/
          ctx2[9]
        ) },
        dirty & /*$$props*/
        2048 && exclude(
          /*$$props*/
          ctx2[11],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$C(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$q, create_if_block_2$g, create_if_block_4$a];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*loaded*/
      ctx2[5]
    )
      return 0;
    if (
      /*failed*/
      ctx2[6]
    )
      return 1;
    if (
      /*loading*/
      ctx2[7]
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const indicator_slot_template = (
    /*#slots*/
    ctx[16].indicator
  );
  const indicator_slot = create_slot(
    indicator_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_indicator_slot_context$2
  );
  let span_levels = [
    { class: (
      /*finalContainerClass*/
      ctx[8]
    ) },
    exclude(
      /*$$props*/
      ctx[11],
      ["use", "class", "src"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (if_block)
        if_block.c();
      t2 = space();
      if (indicator_slot)
        indicator_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      t2 = claim_space(span_nodes);
      if (indicator_slot)
        indicator_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(span, null);
      }
      append_hydration(span, t2);
      if (indicator_slot) {
        indicator_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[10].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(span, t2);
        } else {
          if_block = null;
        }
      }
      if (indicator_slot) {
        if (indicator_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            indicator_slot,
            indicator_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              indicator_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_indicator_slot_changes$2
            ),
            get_indicator_slot_context$2
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalContainerClass*/
        256) && { class: (
          /*finalContainerClass*/
          ctx2[8]
        ) },
        dirty & /*$$props*/
        2048 && exclude(
          /*$$props*/
          ctx2[11],
          ["use", "class", "src"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(indicator_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(indicator_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (indicator_slot)
        indicator_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4$a(ctx) {
  let placeholder_1;
  let current;
  placeholder_1 = new Placeholder$2({ props: { loading: true } });
  return {
    c() {
      create_component(placeholder_1.$$.fragment);
    },
    l(nodes) {
      claim_component(placeholder_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(placeholder_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(placeholder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(placeholder_1, detaching);
    }
  };
}
function create_if_block_2$g(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3$f, create_else_block$d];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[12].placeholder
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_1$q(ctx) {
  let img;
  let img_style_value;
  let img_src_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", {
        class: true,
        style: true,
        src: true,
        alt: true
      });
      this.h();
    },
    h() {
      attr(
        img,
        "class",
        /*finalClass*/
        ctx[9]
      );
      attr(img, "style", img_style_value = /*$$props*/
      ctx[11].style);
      if (!src_url_equal(img.src, img_src_value = /*src*/
      ctx[1] || ""))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*alt*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*finalClass*/
      512) {
        attr(
          img,
          "class",
          /*finalClass*/
          ctx2[9]
        );
      }
      if (dirty & /*$$props*/
      2048 && img_style_value !== (img_style_value = /*$$props*/
      ctx2[11].style)) {
        attr(img, "style", img_style_value);
      }
      if (dirty & /*src*/
      2 && !src_url_equal(img.src, img_src_value = /*src*/
      ctx2[1] || "")) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*alt*/
      4) {
        attr(
          img,
          "alt",
          /*alt*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_else_block$d(ctx) {
  let placeholder_1;
  let current;
  placeholder_1 = new Placeholder$2({});
  return {
    c() {
      create_component(placeholder_1.$$.fragment);
    },
    l(nodes) {
      claim_component(placeholder_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(placeholder_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(placeholder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(placeholder_1, detaching);
    }
  };
}
function create_if_block_3$f(ctx) {
  let current;
  const placeholder_slot_template = (
    /*#slots*/
    ctx[16].placeholder
  );
  const placeholder_slot = create_slot(
    placeholder_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_placeholder_slot_context$2
  );
  return {
    c() {
      if (placeholder_slot)
        placeholder_slot.c();
    },
    l(nodes) {
      if (placeholder_slot)
        placeholder_slot.l(nodes);
    },
    m(target, anchor) {
      if (placeholder_slot) {
        placeholder_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (placeholder_slot) {
        if (placeholder_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            placeholder_slot,
            placeholder_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              placeholder_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_placeholder_slot_changes$2
            ),
            get_placeholder_slot_context$2
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(placeholder_slot, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_slot, local);
      current = false;
    },
    d(detaching) {
      if (placeholder_slot)
        placeholder_slot.d(detaching);
    }
  };
}
function create_fragment$1F(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$C, create_if_block_5$a];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*src*/
      ctx2[1]
    )
      return 0;
    if (
      /*initials*/
      ctx2[4]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
const srcClass$1 = "inline-block absolute";
const srcContainerClass$1 = "inline-block relative align-middle";
const initialClass$1 = "inline-flex items-center justify-center align-middle bg-default text-default-content";
const xsClass$1 = "h-6 w-6";
const smClass$1 = "h-8 w-8";
const mdClass$1 = "h-10 w-10";
const lgClass$1 = "h-12 w-12";
const xlClass$1 = "h-16 w-16";
const circleClass$3 = "rounded-full";
const roundedClass$3 = "rounded-md";
function instance$1D($$self, $$props, $$invalidate) {
  let finalClass;
  let finalContainerClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { src = void 0 } = $$props;
  let { alt = "avatar" } = $$props;
  let { shape = "circle" } = $$props;
  let { size = "md" } = $$props;
  let { initials = void 0 } = $$props;
  let { placeholder = true } = $$props;
  let loaded = false;
  let failed = false;
  let loading = true;
  setContext("list-avatar-shape", shape);
  setContext("list-avatar-size", size);
  setContext("list-avatar-placeholder", placeholder);
  onMount(() => {
    if (src) {
      const image = new Image();
      image.src = src;
      $$invalidate(7, loading = true);
      image.onload = () => {
        $$invalidate(7, loading = false);
        $$invalidate(5, loaded = true);
      };
      image.onerror = () => {
        $$invalidate(7, loading = false);
        $$invalidate(6, failed = true);
      };
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(11, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("src" in $$new_props)
      $$invalidate(1, src = $$new_props.src);
    if ("alt" in $$new_props)
      $$invalidate(2, alt = $$new_props.alt);
    if ("shape" in $$new_props)
      $$invalidate(13, shape = $$new_props.shape);
    if ("size" in $$new_props)
      $$invalidate(3, size = $$new_props.size);
    if ("initials" in $$new_props)
      $$invalidate(4, initials = $$new_props.initials);
    if ("placeholder" in $$new_props)
      $$invalidate(14, placeholder = $$new_props.placeholder);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(9, finalClass = twMerge(src && !initials ? srcClass$1 : false, initials && !src ? initialClass$1 : false, size === "xs" ? xsClass$1 : false, size === "sm" ? smClass$1 : false, size === "md" ? mdClass$1 : false, size === "lg" ? lgClass$1 : false, size === "xl" ? xlClass$1 : false, shape === "circle" ? circleClass$3 : false, shape === "rounded" ? roundedClass$3 : false, $$props.class));
    $$invalidate(8, finalContainerClass = twMerge(src && !initials ? srcContainerClass$1 : false, size === "xs" ? xsClass$1 : false, size === "sm" ? smClass$1 : false, size === "md" ? mdClass$1 : false, size === "lg" ? lgClass$1 : false, size === "xl" ? xlClass$1 : false, shape === "circle" ? circleClass$3 : false, shape === "rounded" ? roundedClass$3 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    src,
    alt,
    size,
    initials,
    loaded,
    failed,
    loading,
    finalContainerClass,
    finalClass,
    forwardEvents,
    $$props,
    $$slots,
    shape,
    placeholder,
    $$scope,
    slots
  ];
}
let Avatar$2 = class Avatar5 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1D, create_fragment$1F, safe_not_equal, {
      use: 0,
      src: 1,
      alt: 2,
      shape: 13,
      size: 3,
      initials: 4,
      placeholder: 14
    });
  }
};
function create_fragment$1E(ctx) {
  let p;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let p_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let p_data = {};
  for (let i2 = 0; i2 < p_levels.length; i2 += 1) {
    p_data = assign$1(p_data, p_levels[i2]);
  }
  return {
    c() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(p, p_data);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            p,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, p)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$18 = "text-xs mb-0 text-secondary-content text-ellipsis overflow-hidden whitespace-nowrap";
function instance$1C($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$18, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Description$3 = class Description5 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1C, create_fragment$1E, safe_not_equal, { use: 0 });
  }
};
const get_rejected_slot_changes = (dirty) => ({});
const get_rejected_slot_context = (ctx) => ({});
const get_failed_slot_changes = (dirty) => ({});
const get_failed_slot_context = (ctx) => ({});
const get_uploading_slot_changes = (dirty) => ({});
const get_uploading_slot_context = (ctx) => ({});
const get_complete_slot_changes = (dirty) => ({});
const get_complete_slot_context = (ctx) => ({});
const get_pending_slot_changes = (dirty) => ({});
const get_pending_slot_context = (ctx) => ({});
function create_fragment$1D(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const pending_slot_template = (
    /*#slots*/
    ctx[6].pending
  );
  const pending_slot = create_slot(
    pending_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_pending_slot_context
  );
  const complete_slot_template = (
    /*#slots*/
    ctx[6].complete
  );
  const complete_slot = create_slot(
    complete_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_complete_slot_context
  );
  const uploading_slot_template = (
    /*#slots*/
    ctx[6].uploading
  );
  const uploading_slot = create_slot(
    uploading_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_uploading_slot_context
  );
  const failed_slot_template = (
    /*#slots*/
    ctx[6].failed
  );
  const failed_slot = create_slot(
    failed_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_failed_slot_context
  );
  const rejected_slot_template = (
    /*#slots*/
    ctx[6].rejected
  );
  const rejected_slot = create_slot(
    rejected_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_rejected_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div1_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let div_data_1 = {};
  for (let i2 = 0; i2 < div1_levels.length; i2 += 1) {
    div_data_1 = assign$1(div_data_1, div1_levels[i2]);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (pending_slot)
        pending_slot.c();
      t0 = space();
      if (complete_slot)
        complete_slot.c();
      t1 = space();
      if (uploading_slot)
        uploading_slot.c();
      t2 = space();
      if (failed_slot)
        failed_slot.c();
      t3 = space();
      if (rejected_slot)
        rejected_slot.c();
      t4 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (pending_slot)
        pending_slot.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      if (complete_slot)
        complete_slot.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (uploading_slot)
        uploading_slot.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      if (failed_slot)
        failed_slot.l(div0_nodes);
      t3 = claim_space(div0_nodes);
      if (rejected_slot)
        rejected_slot.l(div0_nodes);
      t4 = claim_space(div0_nodes);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "relative rounded-full bg-default flex items-center justify-center h-8 w-8");
      set_attributes(div1, div_data_1);
      toggle_class(
        div1,
        "items-start",
        /*placement*/
        ctx[1] === "start"
      );
      toggle_class(
        div1,
        "items-center",
        /*placement*/
        ctx[1] === "center"
      );
      toggle_class(
        div1,
        "items-end",
        /*placement*/
        ctx[1] === "end"
      );
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      append_hydration(div1, div0);
      if (pending_slot) {
        pending_slot.m(div0, null);
      }
      append_hydration(div0, t0);
      if (complete_slot) {
        complete_slot.m(div0, null);
      }
      append_hydration(div0, t1);
      if (uploading_slot) {
        uploading_slot.m(div0, null);
      }
      append_hydration(div0, t2);
      if (failed_slot) {
        failed_slot.m(div0, null);
      }
      append_hydration(div0, t3);
      if (rejected_slot) {
        rejected_slot.m(div0, null);
      }
      append_hydration(div0, t4);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div1,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, div1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (pending_slot) {
        if (pending_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            pending_slot,
            pending_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              pending_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_pending_slot_changes
            ),
            get_pending_slot_context
          );
        }
      }
      if (complete_slot) {
        if (complete_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            complete_slot,
            complete_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              complete_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_complete_slot_changes
            ),
            get_complete_slot_context
          );
        }
      }
      if (uploading_slot) {
        if (uploading_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            uploading_slot,
            uploading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              uploading_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_uploading_slot_changes
            ),
            get_uploading_slot_context
          );
        }
      }
      if (failed_slot) {
        if (failed_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            failed_slot,
            failed_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              failed_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_failed_slot_changes
            ),
            get_failed_slot_context
          );
        }
      }
      if (rejected_slot) {
        if (rejected_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            rejected_slot,
            rejected_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              rejected_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_rejected_slot_changes
            ),
            get_rejected_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(
        div1,
        "items-start",
        /*placement*/
        ctx2[1] === "start"
      );
      toggle_class(
        div1,
        "items-center",
        /*placement*/
        ctx2[1] === "center"
      );
      toggle_class(
        div1,
        "items-end",
        /*placement*/
        ctx2[1] === "end"
      );
    },
    i(local) {
      if (current)
        return;
      transition_in(pending_slot, local);
      transition_in(complete_slot, local);
      transition_in(uploading_slot, local);
      transition_in(failed_slot, local);
      transition_in(rejected_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(pending_slot, local);
      transition_out(complete_slot, local);
      transition_out(uploading_slot, local);
      transition_out(failed_slot, local);
      transition_out(rejected_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (pending_slot)
        pending_slot.d(detaching);
      if (complete_slot)
        complete_slot.d(detaching);
      if (uploading_slot)
        uploading_slot.d(detaching);
      if (failed_slot)
        failed_slot.d(detaching);
      if (rejected_slot)
        rejected_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$17 = "ml-3 flex justify-end flex-shink";
function instance$1B($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { placement = "start" } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("placement" in $$new_props)
      $$invalidate(1, placement = $$new_props.placement);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(2, finalClass = twMerge(defaultClass$17, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, placement, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Extra$1 = class Extra2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1B, create_fragment$1D, safe_not_equal, { use: 0, placement: 1 });
  }
};
function create_fragment$1C(ctx) {
  let h32;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let h3_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let h3_data = {};
  for (let i2 = 0; i2 < h3_levels.length; i2 += 1) {
    h3_data = assign$1(h3_data, h3_levels[i2]);
  }
  return {
    c() {
      h32 = element("h3");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      h32 = claim_element(nodes, "H3", { class: true });
      var h3_nodes = children(h32);
      if (default_slot)
        default_slot.l(h3_nodes);
      h3_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(h32, h3_data);
    },
    m(target, anchor) {
      insert_hydration(target, h32, anchor);
      if (default_slot) {
        default_slot.m(h32, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            h32,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, h32)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h32, h3_data = get_spread_update(h3_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h32);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$16 = "text-xs font-semibold text-content text-ellipsis overflow-hidden whitespace-nowrap";
function instance$1A($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$16, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Title$5 = class Title5 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1A, create_fragment$1C, safe_not_equal, { use: 0 });
  }
};
function create_fragment$1B(ctx) {
  let p;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let p_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let p_data = {};
  for (let i2 = 0; i2 < p_levels.length; i2 += 1) {
    p_data = assign$1(p_data, p_levels[i2]);
  }
  return {
    c() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(p, p_data);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            p,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, p)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$15 = "text-xs mb-0 text-secondary-content";
function instance$1z($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$15, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Action$1 = class Action3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1z, create_fragment$1B, safe_not_equal, { use: 0 });
  }
};
const get_description_slot_changes$3 = (dirty) => ({});
const get_description_slot_context$3 = (ctx) => ({});
const get_title_slot_changes$4 = (dirty) => ({});
const get_title_slot_context$4 = (ctx) => ({});
function create_fragment$1A(ctx) {
  let div2;
  let t0;
  let t1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[5].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_title_slot_context$4
  );
  const description_slot_template = (
    /*#slots*/
    ctx[5].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_description_slot_context$3
  );
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (title_slot)
        title_slot.c();
      t0 = space();
      if (description_slot)
        description_slot.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (title_slot)
        title_slot.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (description_slot)
        description_slot.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (title_slot) {
        title_slot.m(div2, null);
      }
      append_hydration(div2, t0);
      if (description_slot) {
        description_slot.m(div2, null);
      }
      append_hydration(div2, t1);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_title_slot_changes$4
            ),
            get_title_slot_context$4
          );
        }
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_description_slot_changes$3
            ),
            get_description_slot_context$3
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(description_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      transition_out(description_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (title_slot)
        title_slot.d(detaching);
      if (description_slot)
        description_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$14 = "ml-3 flex-col flex flex-grow w-full overflow-hidden";
function instance$1y($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$14, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
class FileContent extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1y, create_fragment$1A, safe_not_equal, { use: 0 });
  }
}
function create_fragment$1z(ctx) {
  let h32;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let h3_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let h3_data = {};
  for (let i2 = 0; i2 < h3_levels.length; i2 += 1) {
    h3_data = assign$1(h3_data, h3_levels[i2]);
  }
  return {
    c() {
      h32 = element("h3");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      h32 = claim_element(nodes, "H3", { class: true });
      var h3_nodes = children(h32);
      if (default_slot)
        default_slot.l(h3_nodes);
      h3_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(h32, h3_data);
    },
    m(target, anchor) {
      insert_hydration(target, h32, anchor);
      if (default_slot) {
        default_slot.m(h32, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            h32,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, h32)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h32, h3_data = get_spread_update(h3_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h32);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$13 = "text-xs font-semibold text-content";
function instance$1x($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$13, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Status$1 = class Status extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1x, create_fragment$1z, safe_not_equal, { use: 0 });
  }
};
const get_action_slot_changes = (dirty) => ({});
const get_action_slot_context = (ctx) => ({});
const get_status_slot_changes$1 = (dirty) => ({});
const get_status_slot_context$1 = (ctx) => ({});
function create_fragment$1y(ctx) {
  let div2;
  let t0;
  let t1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const status_slot_template = (
    /*#slots*/
    ctx[5].status
  );
  const status_slot = create_slot(
    status_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_status_slot_context$1
  );
  const action_slot_template = (
    /*#slots*/
    ctx[5].action
  );
  const action_slot = create_slot(
    action_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_action_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (status_slot)
        status_slot.c();
      t0 = space();
      if (action_slot)
        action_slot.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (status_slot)
        status_slot.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (action_slot)
        action_slot.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (status_slot) {
        status_slot.m(div2, null);
      }
      append_hydration(div2, t0);
      if (action_slot) {
        action_slot.m(div2, null);
      }
      append_hydration(div2, t1);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (status_slot) {
        if (status_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            status_slot,
            status_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              status_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_status_slot_changes$1
            ),
            get_status_slot_context$1
          );
        }
      }
      if (action_slot) {
        if (action_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            action_slot,
            action_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              action_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_action_slot_changes
            ),
            get_action_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(status_slot, local);
      transition_in(action_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(status_slot, local);
      transition_out(action_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (status_slot)
        status_slot.d(detaching);
      if (action_slot)
        action_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$12 = "ml-3 flex flex-grow justify-start items-end flex-col w-full overflow-hidden";
function instance$1w($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$12, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
class UploadContent extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1w, create_fragment$1y, safe_not_equal, { use: 0 });
  }
}
function create_fragment$1x(ctx) {
  let div2;
  let svg;
  let circle0;
  let circle1;
  return {
    c() {
      div2 = element("div");
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      svg = claim_svg_element(div_nodes, "svg", { class: true });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", {
        class: true,
        "stroke-width": true,
        stroke: true,
        fill: true,
        r: true,
        cx: true,
        cy: true
      });
      children(circle0).forEach(detach);
      circle1 = claim_svg_element(svg_nodes, "circle", {
        class: true,
        "stroke-width": true,
        "stroke-dasharray": true,
        "stroke-dashoffset": true,
        "stroke-linecap": true,
        stroke: true,
        fill: true,
        r: true,
        cx: true,
        cy: true
      });
      children(circle1).forEach(detach);
      svg_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(circle0, "class", "text-default");
      attr(circle0, "stroke-width", width);
      attr(circle0, "stroke", "currentColor");
      attr(circle0, "fill", "transparent");
      attr(circle0, "r", radius);
      attr(circle0, "cx", cxCy);
      attr(circle0, "cy", cxCy);
      attr(circle1, "class", "text-info");
      attr(circle1, "stroke-width", width);
      attr(
        circle1,
        "stroke-dasharray",
        /*circumference*/
        ctx[1]
      );
      attr(
        circle1,
        "stroke-dashoffset",
        /*radialValue*/
        ctx[0]
      );
      attr(circle1, "stroke-linecap", "round");
      attr(circle1, "stroke", "currentColor");
      attr(circle1, "fill", "transparent");
      attr(circle1, "r", radius);
      attr(circle1, "cx", cxCy);
      attr(circle1, "cy", cxCy);
      attr(svg, "class", "rotate-[-90deg] origin-center h-5 w-5");
      attr(div2, "class", "h-5 w-5 inline-flex items-center justify-center overflow-hidden rounded-full bottom-5 left-5");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, svg);
      append_hydration(svg, circle0);
      append_hydration(svg, circle1);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*radialValue*/
      1) {
        attr(
          circle1,
          "stroke-dashoffset",
          /*radialValue*/
          ctx2[0]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
let radius = 7;
let cxCy = 10;
let width = 2;
function instance$1v($$self, $$props, $$invalidate) {
  let radialValue;
  let { value } = $$props;
  let circumference = radius * 2 * Math.PI;
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(2, value = $$props2.value);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    4) {
      $$invalidate(0, radialValue = circumference - value / 100 * circumference);
    }
  };
  return [radialValue, circumference, value];
}
class Progress extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1v, create_fragment$1x, safe_not_equal, { value: 2 });
  }
}
function create_if_block$B(ctx) {
  let progress_1;
  let current;
  progress_1 = new Progress({
    props: {
      value: parseFloat(
        /*progress*/
        ctx[1].toFixed(0)
      )
    }
  });
  return {
    c() {
      create_component(progress_1.$$.fragment);
    },
    l(nodes) {
      claim_component(progress_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(progress_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const progress_1_changes = {};
      if (dirty & /*progress*/
      2)
        progress_1_changes.value = parseFloat(
          /*progress*/
          ctx2[1].toFixed(0)
        );
      progress_1.$set(progress_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(progress_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(progress_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(progress_1, detaching);
    }
  };
}
function create_fragment$1w(ctx) {
  let span;
  let useActions_action;
  let span_transition;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*progress*/
    ctx[1] !== void 0 && create_if_block$B(ctx)
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*progress*/
        ctx2[1] !== void 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*progress*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$B(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!span_transition)
            span_transition = create_bidirectional_transition(span, scale, {}, true);
          span_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      if (local) {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, scale, {}, false);
        span_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (if_block)
        if_block.d();
      if (detaching && span_transition)
        span_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$11 = "absolute inset-0 flex items-center justify-center";
function instance$1u($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { progress = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("progress" in $$new_props)
      $$invalidate(1, progress = $$new_props.progress);
  };
  $$self.$$.update = () => {
    $$invalidate(2, finalClass = twMerge(defaultClass$11, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, progress, finalClass, forwardEvents, $$props];
}
class Uploading extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1u, create_fragment$1w, safe_not_equal, { use: 0, progress: 1 });
  }
}
const Loader_svelte_svelte_type_style_lang = "";
function create_fragment$1v(ctx) {
  let svg;
  let circle0;
  let circle1;
  let useActions_action;
  let mounted;
  let dispose;
  let svg_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    ),
    { viewBox: "25 25 50 50" },
    { "stroke-width": "5" }
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        class: true,
        viewBox: true,
        "stroke-width": true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { class: true, cx: true, cy: true, r: true });
      children(circle0).forEach(detach);
      circle1 = claim_svg_element(svg_nodes, "circle", { class: true, cx: true, cy: true, r: true });
      children(circle1).forEach(detach);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(circle0, "class", "background-circle svelte-gzqvii");
      attr(circle0, "cx", "50");
      attr(circle0, "cy", "50");
      attr(circle0, "r", "20");
      attr(circle1, "class", "animated svelte-gzqvii");
      attr(circle1, "cx", "50");
      attr(circle1, "cy", "50");
      attr(circle1, "r", "20");
      set_svg_attributes(svg, svg_data);
      toggle_class(svg, "svelte-gzqvii", true);
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      append_hydration(svg, circle0);
      append_hydration(svg, circle1);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svg,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, svg)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        dirty & /*finalClass*/
        2 && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        ),
        { viewBox: "25 25 50 50" },
        { "stroke-width": "5" }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(svg, "svelte-gzqvii", true);
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$10 = "button-loader";
function instance$1t($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$10, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props];
}
class Loader2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1t, create_fragment$1v, safe_not_equal, { use: 0 });
  }
}
function create_fragment$1u(ctx) {
  let span;
  let loader;
  let useActions_action;
  let span_transition;
  let current;
  let mounted;
  let dispose;
  loader = new Loader2({});
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      create_component(loader.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(loader.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(loader, span, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(loader.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!span_transition)
            span_transition = create_bidirectional_transition(span, scale, {}, true);
          span_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(loader.$$.fragment, local);
      if (local) {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, scale, {}, false);
        span_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(loader);
      if (detaching && span_transition)
        span_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$$ = "absolute inset-0 flex items-center justify-center";
function instance$1s($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$$, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props];
}
class Pending extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1s, create_fragment$1u, safe_not_equal, { use: 0 });
  }
}
function create_fragment$1t(ctx) {
  let span;
  let icon;
  let useActions_action;
  let span_transition;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$7({
    props: {
      data: close,
      class: "text-content h-5 w-5"
    }
  });
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!span_transition)
            span_transition = create_bidirectional_transition(span, scale, {}, true);
          span_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      if (local) {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, scale, {}, false);
        span_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
      if (detaching && span_transition)
        span_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$_ = "absolute inset-0 flex items-center justify-center";
function instance$1r($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$_, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props];
}
class Complete extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1r, create_fragment$1t, safe_not_equal, { use: 0 });
  }
}
function create_fragment$1s(ctx) {
  let span;
  let icon;
  let useActions_action;
  let span_transition;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$7({
    props: {
      data: upload,
      slot: "icon",
      class: "text-content h-5 w-5"
    }
  });
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!span_transition)
            span_transition = create_bidirectional_transition(span, scale, {}, true);
          span_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      if (local) {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, scale, {}, false);
        span_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
      if (detaching && span_transition)
        span_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$Z = "absolute inset-0 flex items-center justify-center";
function instance$1q($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$Z, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props];
}
class Failed extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1q, create_fragment$1s, safe_not_equal, { use: 0 });
  }
}
function create_fragment$1r(ctx) {
  let span;
  let icon;
  let useActions_action;
  let span_transition;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$7({
    props: {
      data: alert_circle,
      class: "text-danger h-5 w-5"
    }
  });
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!span_transition)
            span_transition = create_bidirectional_transition(span, scale, {}, true);
          span_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      if (local) {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, scale, {}, false);
        span_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
      if (detaching && span_transition)
        span_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$Y = "absolute inset-0 flex items-center justify-center";
function instance$1p($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$Y, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props];
}
class Rejected extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1p, create_fragment$1r, safe_not_equal, { use: 0 });
  }
}
const List = FilePreview;
List.Item = Item$2;
List.Item.Leading = Leading$1;
List.Item.Leading.Avatar = Avatar$2;
List.Item.Leading.Icon = Icon$7;
List.Item.FileContent = FileContent;
List.Item.FileContent.Title = Title$5;
List.Item.FileContent.Description = Description$3;
List.Item.UploadContent = UploadContent;
List.Item.UploadContent.Status = Status$1;
List.Item.UploadContent.Action = Action$1;
List.Item.Extra = Extra$1;
List.Item.Extra.Uploading = Uploading;
List.Item.Extra.Pending = Pending;
List.Item.Extra.Complete = Complete;
List.Item.Extra.Failed = Failed;
List.Item.Extra.Rejected = Rejected;
const InputNumber_svelte_svelte_type_style_lang = "";
const get_trailing_slot_changes_1 = (dirty) => ({});
const get_trailing_slot_context_1 = (ctx) => ({});
const get_trailing_slot_changes = (dirty) => ({});
const get_trailing_slot_context = (ctx) => ({});
const get_leading_slot_changes$2 = (dirty) => ({});
const get_leading_slot_context$2 = (ctx) => ({});
const get_label_slot_changes$5 = (dirty) => ({});
const get_label_slot_context$5 = (ctx) => ({});
function create_if_block_7$5(ctx) {
  let span;
  let current;
  const leading_slot_template = (
    /*#slots*/
    ctx[21].leading
  );
  const leading_slot = create_slot(
    leading_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_leading_slot_context$2
  );
  return {
    c() {
      span = element("span");
      if (leading_slot)
        leading_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (leading_slot)
        leading_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none text-secondary-content");
      toggle_class(
        span,
        "text-danger",
        /*error*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (leading_slot) {
        leading_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (leading_slot) {
        if (leading_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            leading_slot,
            leading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              leading_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_leading_slot_changes$2
            ),
            get_leading_slot_context$2
          );
        }
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          span,
          "text-danger",
          /*error*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leading_slot, local);
      current = true;
    },
    o(local) {
      transition_out(leading_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (leading_slot)
        leading_slot.d(detaching);
    }
  };
}
function create_if_block_6$5(ctx) {
  let button;
  let span;
  let icon;
  let span_transition;
  let current;
  let mounted;
  let dispose;
  icon = new Icon$7({ props: { data: close } });
  return {
    c() {
      button = element("button");
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { "aria-label": true, class: true });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "items-center flex text-secondary-content");
      attr(button, "aria-label", "clear");
      attr(button, "class", "disable-focus-active absolute inset-y-0 group-focus-within:flex active:flex items-center");
      toggle_class(button, "right-3", !/*$$slots*/
      ctx[18].trailing && !/*error*/
      ctx[2] && !/*showSpin*/
      ctx[10]);
      toggle_class(
        button,
        "right-12",
        /*showSpin*/
        ctx[10] || /*$$slots*/
        ctx[18].trailing || /*error*/
        ctx[2]
      );
      toggle_class(
        button,
        "right-20",
        /*showSpin*/
        ctx[10] && /*$$slots*/
        (ctx[18].trailing || /*error*/
        ctx[2])
      );
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, span);
      mount_component(icon, span, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handleClear*/
          ctx[14]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*$$slots, error, showSpin*/
      263172) {
        toggle_class(button, "right-3", !/*$$slots*/
        ctx2[18].trailing && !/*error*/
        ctx2[2] && !/*showSpin*/
        ctx2[10]);
      }
      if (!current || dirty & /*showSpin, $$slots, error*/
      263172) {
        toggle_class(
          button,
          "right-12",
          /*showSpin*/
          ctx2[10] || /*$$slots*/
          ctx2[18].trailing || /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*showSpin, $$slots, error*/
      263172) {
        toggle_class(
          button,
          "right-20",
          /*showSpin*/
          ctx2[10] && /*$$slots*/
          (ctx2[18].trailing || /*error*/
          ctx2[2])
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!span_transition)
            span_transition = create_bidirectional_transition(span, scale, {}, true);
          span_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      if (local) {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, scale, {}, false);
        span_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      destroy_component(icon);
      if (detaching && span_transition)
        span_transition.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_5$9(ctx) {
  let span;
  let icon;
  let current;
  icon = new Icon$7({ props: { data: error } });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block_4$9(ctx) {
  let span0;
  let icon;
  let t0;
  let span1;
  let button0;
  let textContent = "+";
  let t2;
  let button1;
  let textContent_1 = "-";
  let current;
  let mounted;
  let dispose;
  icon = new Icon$7({ props: { data: error } });
  return {
    c() {
      span0 = element("span");
      create_component(icon.$$.fragment);
      t0 = space();
      span1 = element("span");
      button0 = element("button");
      button0.textContent = textContent;
      t2 = space();
      button1 = element("button");
      button1.textContent = textContent_1;
      this.h();
    },
    l(nodes) {
      span0 = claim_element(nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      claim_component(icon.$$.fragment, span0_nodes);
      span0_nodes.forEach(detach);
      t0 = claim_space(nodes);
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      button0 = claim_element(span1_nodes, "BUTTON", {
        type: true,
        class: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button0) !== "svelte-1ophio5")
        button0.textContent = textContent;
      t2 = claim_space(span1_nodes);
      button1 = claim_element(span1_nodes, "BUTTON", {
        type: true,
        class: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button1) !== "svelte-1t7y36m")
        button1.textContent = textContent_1;
      span1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "class", "absolute inset-y-0 right-0 flex items-center pr-12 pointer-events-none");
      attr(button0, "type", "button");
      attr(button0, "class", "h-[19px] hover:bg-opacity-50 cursor-pointer flex items-center justify-center border-b border-border bg-background rounded-tr-md");
      attr(button1, "type", "button");
      attr(button1, "class", "h-[19px] hover:bg-opacity-50 flex items-center justify-center bg-background rounded-br-md");
      attr(span1, "class", "absolute h-[2.5rem] text-sm inset-y-0 right-0 w-10 flex text-secondary-content flex-col items-stretch justify-evenly border border-transparent py-px");
    },
    m(target, anchor) {
      insert_hydration(target, span0, anchor);
      mount_component(icon, span0, null);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, span1, anchor);
      append_hydration(span1, button0);
      append_hydration(span1, t2);
      append_hydration(span1, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*handleStepUp*/
            ctx[15]
          ),
          listen(
            button1,
            "click",
            /*handleStepDown*/
            ctx[16]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span0);
        detach(t0);
        detach(span1);
      }
      destroy_component(icon);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_3$e(ctx) {
  let span0;
  let t0;
  let span1;
  let button0;
  let textContent = "+";
  let t2;
  let button1;
  let textContent_1 = "-";
  let current;
  let mounted;
  let dispose;
  const trailing_slot_template = (
    /*#slots*/
    ctx[21].trailing
  );
  const trailing_slot = create_slot(
    trailing_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_trailing_slot_context_1
  );
  return {
    c() {
      span0 = element("span");
      if (trailing_slot)
        trailing_slot.c();
      t0 = space();
      span1 = element("span");
      button0 = element("button");
      button0.textContent = textContent;
      t2 = space();
      button1 = element("button");
      button1.textContent = textContent_1;
      this.h();
    },
    l(nodes) {
      span0 = claim_element(nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      if (trailing_slot)
        trailing_slot.l(span0_nodes);
      span0_nodes.forEach(detach);
      t0 = claim_space(nodes);
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      button0 = claim_element(span1_nodes, "BUTTON", {
        type: true,
        class: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button0) !== "svelte-1ophio5")
        button0.textContent = textContent;
      t2 = claim_space(span1_nodes);
      button1 = claim_element(span1_nodes, "BUTTON", {
        type: true,
        class: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button1) !== "svelte-1t7y36m")
        button1.textContent = textContent_1;
      span1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "class", "absolute inset-y-0 right-0 pr-12 flex items-center pointer-events-none text-secondary-content");
      attr(button0, "type", "button");
      attr(button0, "class", "h-[19px] hover:bg-opacity-50 cursor-pointer flex items-center justify-center border-b border-border bg-background rounded-tr-md");
      attr(button1, "type", "button");
      attr(button1, "class", "h-[19px] hover:bg-opacity-50 flex items-center justify-center bg-background rounded-br-md");
      attr(span1, "class", "absolute h-[2.5rem] text-sm inset-y-0 right-0 w-10 flex text-secondary-content flex-col items-stretch justify-evenly border border-transparent py-px");
    },
    m(target, anchor) {
      insert_hydration(target, span0, anchor);
      if (trailing_slot) {
        trailing_slot.m(span0, null);
      }
      insert_hydration(target, t0, anchor);
      insert_hydration(target, span1, anchor);
      append_hydration(span1, button0);
      append_hydration(span1, t2);
      append_hydration(span1, button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*handleStepUp*/
            ctx[15]
          ),
          listen(
            button1,
            "click",
            /*handleStepDown*/
            ctx[16]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (trailing_slot) {
        if (trailing_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            trailing_slot,
            trailing_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              trailing_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_trailing_slot_changes_1
            ),
            get_trailing_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(trailing_slot, local);
      current = true;
    },
    o(local) {
      transition_out(trailing_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span0);
        detach(t0);
        detach(span1);
      }
      if (trailing_slot)
        trailing_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$f(ctx) {
  let span;
  let current;
  const trailing_slot_template = (
    /*#slots*/
    ctx[21].trailing
  );
  const trailing_slot = create_slot(
    trailing_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_trailing_slot_context
  );
  return {
    c() {
      span = element("span");
      if (trailing_slot)
        trailing_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (trailing_slot)
        trailing_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none text-secondary-content");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (trailing_slot) {
        trailing_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (trailing_slot) {
        if (trailing_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            trailing_slot,
            trailing_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              trailing_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_trailing_slot_changes
            ),
            get_trailing_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(trailing_slot, local);
      current = true;
    },
    o(local) {
      transition_out(trailing_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (trailing_slot)
        trailing_slot.d(detaching);
    }
  };
}
function create_if_block_1$p(ctx) {
  let span;
  let button0;
  let textContent = "+";
  let t1;
  let button1;
  let textContent_1 = "-";
  let mounted;
  let dispose;
  return {
    c() {
      span = element("span");
      button0 = element("button");
      button0.textContent = textContent;
      t1 = space();
      button1 = element("button");
      button1.textContent = textContent_1;
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      button0 = claim_element(span_nodes, "BUTTON", {
        type: true,
        class: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button0) !== "svelte-1ophio5")
        button0.textContent = textContent;
      t1 = claim_space(span_nodes);
      button1 = claim_element(span_nodes, "BUTTON", {
        type: true,
        class: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(button1) !== "svelte-1t7y36m")
        button1.textContent = textContent_1;
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button0, "type", "button");
      attr(button0, "class", "h-[19px] hover:bg-opacity-50 cursor-pointer flex items-center justify-center border-b border-border bg-background rounded-tr-md");
      attr(button1, "type", "button");
      attr(button1, "class", "h-[19px] hover:bg-opacity-50 flex items-center justify-center bg-background rounded-br-md");
      attr(span, "class", "absolute h-[2.5rem] text-sm inset-y-0 right-0 w-10 flex text-secondary-content flex-col items-stretch justify-evenly border border-transparent py-px");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, button0);
      append_hydration(span, t1);
      append_hydration(span, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*handleStepUp*/
            ctx[15]
          ),
          listen(
            button1,
            "click",
            /*handleStepDown*/
            ctx[16]
          )
        ];
        mounted = true;
      }
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$A(ctx) {
  let p;
  let t2;
  let p_id_value;
  let p_transition;
  let current;
  return {
    c() {
      p = element("p");
      t2 = text(
        /*error*/
        ctx[2]
      );
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true, id: true });
      var p_nodes = children(p);
      t2 = claim_text(
        p_nodes,
        /*error*/
        ctx[2]
      );
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(p, "class", "mt-2 text-sm text-danger");
      attr(p, "id", p_id_value = /*name*/
      ctx[1] + "-error");
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      append_hydration(p, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*error*/
      4)
        set_data(
          t2,
          /*error*/
          ctx2[2]
        );
      if (!current || dirty & /*name*/
      2 && p_id_value !== (p_id_value = /*name*/
      ctx2[1] + "-error")) {
        attr(p, "id", p_id_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!p_transition)
            p_transition = create_bidirectional_transition(p, slide, {}, true);
          p_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!p_transition)
          p_transition = create_bidirectional_transition(p, slide, {}, false);
        p_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (detaching && p_transition)
        p_transition.end();
    }
  };
}
function create_fragment$1q(ctx) {
  let div1;
  let t0;
  let div0;
  let input_1;
  let t1;
  let t2;
  let t3;
  let current_block_type_index;
  let if_block2;
  let t4;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  const label_slot_template = (
    /*#slots*/
    ctx[21].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_label_slot_context$5
  );
  let if_block0 = (
    /*$$slots*/
    ctx[18].leading && create_if_block_7$5(ctx)
  );
  let if_block1 = (
    /*allowClear*/
    ctx[9] && /*value*/
    (ctx[0] || /*value*/
    ctx[0] === 0) && create_if_block_6$5(ctx)
  );
  const if_block_creators = [
    create_if_block_1$p,
    create_if_block_2$f,
    create_if_block_3$e,
    create_if_block_4$9,
    create_if_block_5$9
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*showSpin*/
      ctx2[10] && !/*error*/
      ctx2[2] && !/*$$slots*/
      ctx2[18].trailing
    )
      return 0;
    if (
      /*$$slots*/
      ctx2[18].trailing && !/*error*/
      ctx2[2] && !/*showSpin*/
      ctx2[10]
    )
      return 1;
    if (
      /*$$slots*/
      ctx2[18].trailing && !/*error*/
      ctx2[2] && /*showSpin*/
      ctx2[10]
    )
      return 2;
    if (
      /*error*/
      ctx2[2] && /*showSpin*/
      ctx2[10]
    )
      return 3;
    if (
      /*error*/
      ctx2[2]
    )
      return 4;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block3 = (
    /*error*/
    ctx[2] && create_if_block$A(ctx)
  );
  return {
    c() {
      div1 = element("div");
      if (label_slot)
        label_slot.c();
      t0 = space();
      div0 = element("div");
      input_1 = element("input");
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (label_slot)
        label_slot.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      input_1 = claim_element(div0_nodes, "INPUT", {
        type: true,
        inputmode: true,
        pattern: true,
        autocapitalize: true,
        autocomplete: true,
        name: true,
        id: true,
        class: true,
        placeholder: true,
        step: true,
        min: true,
        max: true
      });
      t1 = claim_space(div0_nodes);
      if (if_block0)
        if_block0.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      t3 = claim_space(div0_nodes);
      if (if_block2)
        if_block2.l(div0_nodes);
      div0_nodes.forEach(detach);
      t4 = claim_space(div1_nodes);
      if (if_block3)
        if_block3.l(div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(input_1, "type", "number");
      attr(input_1, "inputmode", "numeric");
      attr(input_1, "pattern", "\\d*");
      attr(
        input_1,
        "autocapitalize",
        /*autocapitalize*/
        ctx[5]
      );
      attr(
        input_1,
        "autocomplete",
        /*autocomplete*/
        ctx[4]
      );
      attr(
        input_1,
        "name",
        /*name*/
        ctx[1]
      );
      input_1.readOnly = /*readonly*/
      ctx[8];
      input_1.disabled = /*disabled*/
      ctx[6];
      attr(
        input_1,
        "id",
        /*name*/
        ctx[1]
      );
      attr(input_1, "class", "block w-full h-[2.5rem] px-3 border outline-none focus:outline-none sm:text-sm rounded-md bg-surface placeholder-secondary-content placeholder-opacity-80 svelte-4xx3jv");
      attr(
        input_1,
        "placeholder",
        /*placeholder*/
        ctx[3]
      );
      attr(
        input_1,
        "step",
        /*step*/
        ctx[7]
      );
      attr(
        input_1,
        "min",
        /*min*/
        ctx[11]
      );
      attr(
        input_1,
        "max",
        /*max*/
        ctx[12]
      );
      toggle_class(
        input_1,
        "border-red-400",
        /*error*/
        ctx[2]
      );
      toggle_class(
        input_1,
        "text-danger",
        /*error*/
        ctx[2]
      );
      toggle_class(
        input_1,
        "placeholder-danger",
        /*error*/
        ctx[2]
      );
      toggle_class(
        input_1,
        "focus:border-red-500",
        /*error*/
        ctx[2]
      );
      toggle_class(input_1, "focus:border-primary", !/*error*/
      ctx[2]);
      toggle_class(input_1, "border-border", !/*error*/
      ctx[2]);
      toggle_class(
        input_1,
        "pl-10",
        /*$$slots*/
        ctx[18].leading
      );
      toggle_class(
        input_1,
        "pr-10",
        /*showSpin*/
        ctx[10] || /*$$slots*/
        ctx[18].trailing || /*error*/
        ctx[2] || /*allowClear*/
        ctx[9]
      );
      toggle_class(
        input_1,
        "pr-20",
        /*showSpin*/
        ctx[10] && /*$$slots*/
        (ctx[18].trailing || /*error*/
        ctx[2]) || /*showSpin*/
        ctx[10] && /*allowClear*/
        ctx[9] || /*allowClear*/
        ctx[9] && /*$$slots*/
        (ctx[18].trailing || /*error*/
        ctx[2])
      );
      toggle_class(
        input_1,
        "bg-default",
        /*disabled*/
        ctx[6]
      );
      attr(div0, "class", "mt-1 relative rounded-md h-[2.5rem]");
      toggle_class(
        div0,
        "text-danger",
        /*error*/
        ctx[2]
      );
      toggle_class(
        div0,
        "opacity-75",
        /*disabled*/
        ctx[6]
      );
      attr(div1, "class", div1_class_value = /*$$props*/
      ctx[17].class);
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      if (label_slot) {
        label_slot.m(div1, null);
      }
      append_hydration(div1, t0);
      append_hydration(div1, div0);
      append_hydration(div0, input_1);
      ctx[23](input_1);
      set_input_value(
        input_1,
        /*value*/
        ctx[0]
      );
      append_hydration(div0, t1);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration(div0, t2);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration(div0, t3);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div0, null);
      }
      append_hydration(div1, t4);
      if (if_block3)
        if_block3.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input_1,
            "input",
            /*input_1_input_handler*/
            ctx[24]
          ),
          listen(
            input_1,
            "input",
            /*input_handler*/
            ctx[22]
          ),
          listen(input_1, "keypress", onlyNumeric)
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_label_slot_changes$5
            ),
            get_label_slot_context$5
          );
        }
      }
      if (!current || dirty & /*autocapitalize*/
      32) {
        attr(
          input_1,
          "autocapitalize",
          /*autocapitalize*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*autocomplete*/
      16) {
        attr(
          input_1,
          "autocomplete",
          /*autocomplete*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*name*/
      2) {
        attr(
          input_1,
          "name",
          /*name*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*readonly*/
      256) {
        input_1.readOnly = /*readonly*/
        ctx2[8];
      }
      if (!current || dirty & /*disabled*/
      64) {
        input_1.disabled = /*disabled*/
        ctx2[6];
      }
      if (!current || dirty & /*name*/
      2) {
        attr(
          input_1,
          "id",
          /*name*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*placeholder*/
      8) {
        attr(
          input_1,
          "placeholder",
          /*placeholder*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*step*/
      128) {
        attr(
          input_1,
          "step",
          /*step*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*min*/
      2048) {
        attr(
          input_1,
          "min",
          /*min*/
          ctx2[11]
        );
      }
      if (!current || dirty & /*max*/
      4096) {
        attr(
          input_1,
          "max",
          /*max*/
          ctx2[12]
        );
      }
      if (dirty & /*value*/
      1 && to_number(input_1.value) !== /*value*/
      ctx2[0]) {
        set_input_value(
          input_1,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          input_1,
          "border-red-400",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          input_1,
          "text-danger",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          input_1,
          "placeholder-danger",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          input_1,
          "focus:border-red-500",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(input_1, "focus:border-primary", !/*error*/
        ctx2[2]);
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(input_1, "border-border", !/*error*/
        ctx2[2]);
      }
      if (!current || dirty & /*$$slots*/
      262144) {
        toggle_class(
          input_1,
          "pl-10",
          /*$$slots*/
          ctx2[18].leading
        );
      }
      if (!current || dirty & /*showSpin, $$slots, error, allowClear*/
      263684) {
        toggle_class(
          input_1,
          "pr-10",
          /*showSpin*/
          ctx2[10] || /*$$slots*/
          ctx2[18].trailing || /*error*/
          ctx2[2] || /*allowClear*/
          ctx2[9]
        );
      }
      if (!current || dirty & /*showSpin, $$slots, error, allowClear*/
      263684) {
        toggle_class(
          input_1,
          "pr-20",
          /*showSpin*/
          ctx2[10] && /*$$slots*/
          (ctx2[18].trailing || /*error*/
          ctx2[2]) || /*showSpin*/
          ctx2[10] && /*allowClear*/
          ctx2[9] || /*allowClear*/
          ctx2[9] && /*$$slots*/
          (ctx2[18].trailing || /*error*/
          ctx2[2])
        );
      }
      if (!current || dirty & /*disabled*/
      64) {
        toggle_class(
          input_1,
          "bg-default",
          /*disabled*/
          ctx2[6]
        );
      }
      if (
        /*$$slots*/
        ctx2[18].leading
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          262144) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_7$5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*allowClear*/
        ctx2[9] && /*value*/
        (ctx2[0] || /*value*/
        ctx2[0] === 0)
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*allowClear, value*/
          513) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_6$5(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block2) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block2 = if_blocks[current_block_type_index];
          if (!if_block2) {
            if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block2.c();
          } else {
            if_block2.p(ctx2, dirty);
          }
          transition_in(if_block2, 1);
          if_block2.m(div0, null);
        } else {
          if_block2 = null;
        }
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          div0,
          "text-danger",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*disabled*/
      64) {
        toggle_class(
          div0,
          "opacity-75",
          /*disabled*/
          ctx2[6]
        );
      }
      if (
        /*error*/
        ctx2[2]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*error*/
          4) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block$A(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div1, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*$$props*/
      131072 && div1_class_value !== (div1_class_value = /*$$props*/
      ctx2[17].class)) {
        attr(div1, "class", div1_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (label_slot)
        label_slot.d(detaching);
      ctx[23](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block3)
        if_block3.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function onlyNumeric(e2) {
  if (!e2.key.match(/^[0-9]+$/))
    e2.preventDefault();
}
function instance$1o($$self, $$props, $$invalidate) {
  let minValue;
  let maxValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { name } = $$props;
  let { error: error2 = void 0 } = $$props;
  let { placeholder = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { autocomplete = void 0 } = $$props;
  let { autocapitalize = "off" } = $$props;
  let { disabled = false } = $$props;
  let { step = 1 } = $$props;
  let { readonly = false } = $$props;
  let { allowClear = false } = $$props;
  let { showSpin = false } = $$props;
  let { min: min2 = void 0 } = $$props;
  let { max: max2 = void 0 } = $$props;
  let { loop: loop2 = min2 && max2 ? true : false } = $$props;
  let input;
  let currentError = writable(error2);
  function handleClear() {
    $$invalidate(13, input.value = "", input);
    $$invalidate(0, value = void 0);
  }
  function handleStepUp() {
    const newValue = value || value === 0 ? value + step : step;
    if (maxValue || maxValue === 0) {
      if (newValue <= maxValue) {
        $$invalidate(0, value = newValue);
      } else if (loop2 && newValue > maxValue) {
        $$invalidate(0, value = minValue);
      }
    } else {
      $$invalidate(0, value = newValue);
    }
  }
  function handleStepDown() {
    const newValue = value || value === 0 ? value - step : step * -1;
    if (minValue || minValue === 0) {
      if (newValue >= minValue) {
        $$invalidate(0, value = newValue);
      } else if (loop2 && newValue < minValue) {
        $$invalidate(0, value = maxValue);
      }
    } else {
      $$invalidate(0, value = newValue);
    }
  }
  setContext("input-number-name", name);
  setContext("input-number-error", currentError);
  function input_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(13, input);
    });
  }
  function input_1_input_handler() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(17, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("error" in $$new_props)
      $$invalidate(2, error2 = $$new_props.error);
    if ("placeholder" in $$new_props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("autocomplete" in $$new_props)
      $$invalidate(4, autocomplete = $$new_props.autocomplete);
    if ("autocapitalize" in $$new_props)
      $$invalidate(5, autocapitalize = $$new_props.autocapitalize);
    if ("disabled" in $$new_props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("step" in $$new_props)
      $$invalidate(7, step = $$new_props.step);
    if ("readonly" in $$new_props)
      $$invalidate(8, readonly = $$new_props.readonly);
    if ("allowClear" in $$new_props)
      $$invalidate(9, allowClear = $$new_props.allowClear);
    if ("showSpin" in $$new_props)
      $$invalidate(10, showSpin = $$new_props.showSpin);
    if ("min" in $$new_props)
      $$invalidate(11, min2 = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(12, max2 = $$new_props.max);
    if ("loop" in $$new_props)
      $$invalidate(19, loop2 = $$new_props.loop);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*min*/
    2048) {
      minValue = min2 ? parseInt(min2) : void 0;
    }
    if ($$self.$$.dirty & /*max*/
    4096) {
      maxValue = max2 ? parseInt(max2) : void 0;
    }
    if ($$self.$$.dirty & /*error*/
    4) {
      currentError.set(error2);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    name,
    error2,
    placeholder,
    autocomplete,
    autocapitalize,
    disabled,
    step,
    readonly,
    allowClear,
    showSpin,
    min2,
    max2,
    input,
    handleClear,
    handleStepUp,
    handleStepDown,
    $$props,
    $$slots,
    loop2,
    $$scope,
    slots,
    input_handler,
    input_1_binding,
    input_1_input_handler
  ];
}
let InputNumber$1 = class InputNumber extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1o, create_fragment$1q, safe_not_equal, {
      name: 1,
      error: 2,
      placeholder: 3,
      value: 0,
      autocomplete: 4,
      autocapitalize: 5,
      disabled: 6,
      step: 7,
      readonly: 8,
      allowClear: 9,
      showSpin: 10,
      min: 11,
      max: 12,
      loop: 19
    });
  }
};
function create_fragment$1p(ctx) {
  let label;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let label_levels = [
    { for: (
      /*name*/
      ctx[3]
    ) },
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[5],
      ["use", "class"]
    )
  ];
  let label_data = {};
  for (let i2 = 0; i2 < label_levels.length; i2 += 1) {
    label_data = assign$1(label_data, label_levels[i2]);
  }
  return {
    c() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      label = claim_element(nodes, "LABEL", { for: true, class: true });
      var label_nodes = children(label);
      if (default_slot)
        default_slot.l(label_nodes);
      label_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(label, label_data);
    },
    m(target, anchor) {
      insert_hydration(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            label,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, label)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        { for: (
          /*name*/
          ctx2[3]
        ) },
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        32 && exclude(
          /*$$props*/
          ctx2[5],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$X = "block text-sm font-medium text-secondary-content";
const errorClass$2 = "text-danger";
function instance$1n($$self, $$props, $$invalidate) {
  let finalClass;
  let $error;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const name = getContext("input-number-name");
  const error2 = getContext("input-number-error");
  component_subscribe($$self, error2, (value) => $$invalidate(6, $error = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$X, $error && $error.length > 0 ? errorClass$2 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, name, error2, $$props, $error, $$scope, slots];
}
let Label$4 = class Label8 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1n, create_fragment$1p, safe_not_equal, { use: 0 });
  }
};
const InputNumber2 = InputNumber$1;
InputNumber2.Label = Label$4;
InputNumber2.Leading = Icon$7;
InputNumber2.Trailing = Icon$7;
function create_fragment$1o(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$W = "w-full h-full flex flex-col";
function instance$1m($$self, $$props, $$invalidate) {
  let finalClass;
  let $sideBarWidth;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let sideBarWidth = writable("212");
  component_subscribe($$self, sideBarWidth, (value) => $$invalidate(7, $sideBarWidth = value));
  function toggleSidebarWidth() {
    if ($sideBarWidth === "212") {
      set_store_value(sideBarWidth, $sideBarWidth = "72", $sideBarWidth);
    } else {
      set_store_value(sideBarWidth, $sideBarWidth = "212", $sideBarWidth);
    }
  }
  setContext("sideBarWidth", sideBarWidth);
  setContext("toggleSidebarWidth", toggleSidebarWidth);
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$W, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, sideBarWidth, $$props, $$scope, slots];
}
let Layout$1 = class Layout extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1m, create_fragment$1o, safe_not_equal, { use: 0 });
  }
};
const get_extra_slot_changes$3 = (dirty) => ({});
const get_extra_slot_context$3 = (ctx) => ({});
function create_fragment$1n(ctx) {
  let header;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const extra_slot_template = (
    /*#slots*/
    ctx[5].extra
  );
  const extra_slot = create_slot(
    extra_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_extra_slot_context$3
  );
  let header_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let header_data = {};
  for (let i2 = 0; i2 < header_levels.length; i2 += 1) {
    header_data = assign$1(header_data, header_levels[i2]);
  }
  return {
    c() {
      header = element("header");
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (extra_slot)
        extra_slot.c();
      this.h();
    },
    l(nodes) {
      header = claim_element(nodes, "HEADER", { class: true });
      var header_nodes = children(header);
      if (default_slot)
        default_slot.l(header_nodes);
      t2 = claim_space(header_nodes);
      if (extra_slot)
        extra_slot.l(header_nodes);
      header_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(header, header_data);
    },
    m(target, anchor) {
      insert_hydration(target, header, anchor);
      if (default_slot) {
        default_slot.m(header, null);
      }
      append_hydration(header, t2);
      if (extra_slot) {
        extra_slot.m(header, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            header,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, header)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (extra_slot) {
        if (extra_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            extra_slot,
            extra_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              extra_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_extra_slot_changes$3
            ),
            get_extra_slot_context$3
          );
        }
      }
      set_attributes(header, header_data = get_spread_update(header_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(extra_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(extra_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (extra_slot)
        extra_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$V = "flex sticky top-[var(--sat)] z-10 pt-3 pb-2 pl-[calc(var(--sal)+1rem)] pr-[calc(var(--sar)+1rem)] w-full flex-row h-16 min-h-[64px] max-h-16 flex-shrink items-center bg-surface text-content shadow-md flex-1";
function instance$1l($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$V, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Header$2 = class Header2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1l, create_fragment$1n, safe_not_equal, { use: 0 });
  }
};
function create_fragment$1m(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$U = "flex-grow flex flex-row items-center justify-end";
function instance$1k($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$U, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
class HeaderExtra extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1k, create_fragment$1m, safe_not_equal, { use: 0 });
  }
}
function create_fragment$1l(ctx) {
  let div2;
  let div1;
  let div0;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let div2_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[9],
      ["use", "class"]
    )
  ];
  let div_data_2 = {};
  for (let i2 = 0; i2 < div2_levels.length; i2 += 1) {
    div_data_2 = assign$1(div_data_2, div2_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "h-full flex-1 flex flex-col min-h-0 pt-3 pb-4 pl-2 pr-2 max-h-[calc(100vh-64px)] overflow-y-auto overflow-x-hidden");
      attr(div1, "class", "h-full flex flex-col transition-size duration-300");
      set_style(
        div1,
        "width",
        /*$collapsed*/
        ctx[2] ? (
          /*$collapsedWidth*/
          ctx[3]
        ) : (
          /*$expandedWidth*/
          ctx[4]
        )
      );
      set_attributes(div2, div_data_2);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, div1);
      append_hydration(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[5].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$collapsed, $collapsedWidth, $expandedWidth*/
      28) {
        set_style(
          div1,
          "width",
          /*$collapsed*/
          ctx2[2] ? (
            /*$collapsedWidth*/
            ctx2[3]
          ) : (
            /*$expandedWidth*/
            ctx2[4]
          )
        );
      }
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        512 && exclude(
          /*$$props*/
          ctx2[9],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$T = "hidden h-full lg:flex lg:flex-shrink-0 relative";
function instance$1j($$self, $$props, $$invalidate) {
  let finalClass;
  let $collapsed;
  let $collapsedWidth;
  let $expandedWidth;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const collapsed = getContext("layout-collapsed");
  component_subscribe($$self, collapsed, (value) => $$invalidate(2, $collapsed = value));
  const collapsedWidth = getContext("collapsedWidth");
  component_subscribe($$self, collapsedWidth, (value) => $$invalidate(3, $collapsedWidth = value));
  const expandedWidth = getContext("expandedWidth");
  component_subscribe($$self, expandedWidth, (value) => $$invalidate(4, $expandedWidth = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$T, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    finalClass,
    $collapsed,
    $collapsedWidth,
    $expandedWidth,
    forwardEvents,
    collapsed,
    collapsedWidth,
    expandedWidth,
    $$props,
    $$scope,
    slots
  ];
}
class Sidebar extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1j, create_fragment$1l, safe_not_equal, { use: 0 });
  }
}
function create_fragment$1k(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$S = "flex flex-row w-full h-full items-start justify-start";
function instance$1i($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { collapsed = false } = $$props;
  let { collapsedWidth = "4.5rem" } = $$props;
  let { expandedWidth = "12rem" } = $$props;
  let sidebarCollapsed = writable(collapsed);
  let cWidth = writable(collapsedWidth);
  let eWidth = writable(expandedWidth);
  setContext("layout-collapsed", sidebarCollapsed);
  setContext("collapsedWidth", cWidth);
  setContext("expandedWidth", eWidth);
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("collapsed" in $$new_props)
      $$invalidate(4, collapsed = $$new_props.collapsed);
    if ("collapsedWidth" in $$new_props)
      $$invalidate(5, collapsedWidth = $$new_props.collapsedWidth);
    if ("expandedWidth" in $$new_props)
      $$invalidate(6, expandedWidth = $$new_props.expandedWidth);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*collapsed*/
    16) {
      sidebarCollapsed.set(collapsed);
    }
    if ($$self.$$.dirty & /*collapsedWidth*/
    32) {
      cWidth.set(collapsedWidth);
    }
    if ($$self.$$.dirty & /*expandedWidth*/
    64) {
      eWidth.set(expandedWidth);
    }
    $$invalidate(1, finalClass = twMerge(defaultClass$S, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    finalClass,
    forwardEvents,
    $$props,
    collapsed,
    collapsedWidth,
    expandedWidth,
    $$scope,
    slots
  ];
}
let Content$2 = class Content4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1i, create_fragment$1k, safe_not_equal, {
      use: 0,
      collapsed: 4,
      collapsedWidth: 5,
      expandedWidth: 6
    });
  }
};
function create_fragment$1j(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$R = "w-full h-full";
const collapsedClass = "lg:pl-0";
function instance$1h($$self, $$props, $$invalidate) {
  let finalClass;
  let $collapsed;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const collapsed = getContext("layout-collapsed");
  component_subscribe($$self, collapsed, (value) => $$invalidate(5, $collapsed = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$R, $collapsed ? collapsedClass : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, collapsed, $$props, $collapsed, $$scope, slots];
}
let Body$1 = class Body extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1h, create_fragment$1j, safe_not_equal, { use: 0 });
  }
};
const get_extra_slot_changes$2 = (dirty) => ({});
const get_extra_slot_context$2 = (ctx) => ({});
function create_fragment$1i(ctx) {
  let footer;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const extra_slot_template = (
    /*#slots*/
    ctx[5].extra
  );
  const extra_slot = create_slot(
    extra_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_extra_slot_context$2
  );
  let footer_levels = [
    { "aria-labelledby": "footer-heading" },
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let footer_data = {};
  for (let i2 = 0; i2 < footer_levels.length; i2 += 1) {
    footer_data = assign$1(footer_data, footer_levels[i2]);
  }
  return {
    c() {
      footer = element("footer");
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (extra_slot)
        extra_slot.c();
      this.h();
    },
    l(nodes) {
      footer = claim_element(nodes, "FOOTER", { "aria-labelledby": true, class: true });
      var footer_nodes = children(footer);
      if (default_slot)
        default_slot.l(footer_nodes);
      t2 = claim_space(footer_nodes);
      if (extra_slot)
        extra_slot.l(footer_nodes);
      footer_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(footer, footer_data);
    },
    m(target, anchor) {
      insert_hydration(target, footer, anchor);
      if (default_slot) {
        default_slot.m(footer, null);
      }
      append_hydration(footer, t2);
      if (extra_slot) {
        extra_slot.m(footer, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            footer,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, footer)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (extra_slot) {
        if (extra_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            extra_slot,
            extra_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              extra_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_extra_slot_changes$2
            ),
            get_extra_slot_context$2
          );
        }
      }
      set_attributes(footer, footer_data = get_spread_update(footer_levels, [
        { "aria-labelledby": "footer-heading" },
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(extra_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(extra_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(footer);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (extra_slot)
        extra_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$Q = "flex pb-[var(--sab)] z-10 pl-[calc(var(--sal)+1rem)] pr-[calc(var(--sar)+1rem)] w-full flex-row h-16 min-h-[64px] flex-shrink items-center bg-surface text-content shadow-md flex-1";
function instance$1g($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$Q, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Footer$1 = class Footer2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1g, create_fragment$1i, safe_not_equal, { use: 0 });
  }
};
function create_fragment$1h(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$P = "flex-grow flex flex-row items-center justify-end";
function instance$1f($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$P, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
class FooterExtra extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1f, create_fragment$1h, safe_not_equal, { use: 0 });
  }
}
const Layout2 = Layout$1;
Layout2.Header = Header$2;
Layout2.Header.Extra = HeaderExtra;
Layout2.Content = Content$2;
Layout2.Content.Body = Body$1;
Layout2.Content.Sidebar = Sidebar;
Layout2.Footer = Footer$1;
Layout2.Footer.Extra = FooterExtra;
const crossfade = crossfade$1({ duration: 400 });
function create_fragment$1g(ctx) {
  let span;
  let svg;
  let useActions_action;
  let mounted;
  let dispose;
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[7]
    ) },
    exclude(
      /*$$props*/
      ctx[10],
      [
        "use",
        "class",
        "width",
        "height",
        "viewBox",
        "stroke",
        "fill",
        "data",
        "color",
        "size"
      ]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      svg = svg_element("svg");
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      svg = claim_svg_element(span_nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        stroke: true,
        fill: true,
        color: true
      });
      var svg_nodes = children(svg);
      svg_nodes.forEach(detach);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(
        svg,
        "width",
        /*width*/
        ctx[2]
      );
      attr(
        svg,
        "height",
        /*height*/
        ctx[3]
      );
      attr(
        svg,
        "viewBox",
        /*viewBox*/
        ctx[1]
      );
      attr(
        svg,
        "stroke",
        /*stroke*/
        ctx[5]
      );
      attr(
        svg,
        "fill",
        /*fill*/
        ctx[6]
      );
      attr(
        svg,
        "color",
        /*color*/
        ctx[4]
      );
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, svg);
      svg.innerHTML = /*elements*/
      ctx[8];
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[9].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*elements*/
      256)
        svg.innerHTML = /*elements*/
        ctx2[8];
      if (dirty & /*width*/
      4) {
        attr(
          svg,
          "width",
          /*width*/
          ctx2[2]
        );
      }
      if (dirty & /*height*/
      8) {
        attr(
          svg,
          "height",
          /*height*/
          ctx2[3]
        );
      }
      if (dirty & /*viewBox*/
      2) {
        attr(
          svg,
          "viewBox",
          /*viewBox*/
          ctx2[1]
        );
      }
      if (dirty & /*stroke*/
      32) {
        attr(
          svg,
          "stroke",
          /*stroke*/
          ctx2[5]
        );
      }
      if (dirty & /*fill*/
      64) {
        attr(
          svg,
          "fill",
          /*fill*/
          ctx2[6]
        );
      }
      if (dirty & /*color*/
      16) {
        attr(
          svg,
          "color",
          /*color*/
          ctx2[4]
        );
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*finalClass*/
        128 && { class: (
          /*finalClass*/
          ctx2[7]
        ) },
        dirty & /*$$props*/
        1024 && exclude(
          /*$$props*/
          ctx2[10],
          [
            "use",
            "class",
            "width",
            "height",
            "viewBox",
            "stroke",
            "fill",
            "data",
            "color",
            "size"
          ]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$O = "relative cursor-pointer flex items-center justify-center h-12 w-12 bg-white bg-opacity-10 rounded-full transition-reveal scale-90 hover:scale-100 hover:bg-opacity-20 hover:active:scale-95 pointer-events-auto text-white";
function extractViewBox$4(svg) {
  const regex = /viewBox="([\d\- ]+)"/;
  const res = regex.exec(svg);
  if (!res)
    return "0 0 24 24";
  return res[1];
}
function instance$1e($$self, $$props, $$invalidate) {
  let elements2;
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { data = "" } = $$props;
  let { viewBox = extractViewBox$4(data) } = $$props;
  let { size = "24px" } = $$props;
  let { width: width2 = size } = $$props;
  let { height = size } = $$props;
  let { color: color2 = "currentColor" } = $$props;
  let { stroke = void 0 } = $$props;
  let { fill: fill2 = color2 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("data" in $$new_props)
      $$invalidate(11, data = $$new_props.data);
    if ("viewBox" in $$new_props)
      $$invalidate(1, viewBox = $$new_props.viewBox);
    if ("size" in $$new_props)
      $$invalidate(12, size = $$new_props.size);
    if ("width" in $$new_props)
      $$invalidate(2, width2 = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(3, height = $$new_props.height);
    if ("color" in $$new_props)
      $$invalidate(4, color2 = $$new_props.color);
    if ("stroke" in $$new_props)
      $$invalidate(5, stroke = $$new_props.stroke);
    if ("fill" in $$new_props)
      $$invalidate(6, fill2 = $$new_props.fill);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data*/
    2048) {
      $$invalidate(8, elements2 = data.replace(/<svg ([^>]*)>/, "").replace("</svg>", ""));
    }
    $$invalidate(7, finalClass = twMerge(defaultClass$O, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    viewBox,
    width2,
    height,
    color2,
    stroke,
    fill2,
    finalClass,
    elements2,
    forwardEvents,
    $$props,
    data,
    size
  ];
}
class Control extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1e, create_fragment$1g, safe_not_equal, {
      use: 0,
      data: 11,
      viewBox: 1,
      size: 12,
      width: 2,
      height: 3,
      color: 4,
      stroke: 5,
      fill: 6
    });
  }
}
const LightBox_svelte_svelte_type_style_lang = "";
const { window: window_1 } = globals;
function get_each_context$a(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i2];
  child_ctx[22] = i2;
  return child_ctx;
}
function get_each_context_1$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i2];
  return child_ctx;
}
function create_if_block_1$o(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let t2;
  let t3;
  let div1_intro;
  let div1_outro;
  let current;
  let if_block0 = (
    /*showClose*/
    ctx[3] && create_if_block_5$8(ctx)
  );
  let if_block1 = (
    /*allowRotation*/
    ctx[4] && create_if_block_4$8(ctx)
  );
  let if_block2 = (
    /*allowPrint*/
    ctx[5] && create_if_block_3$d()
  );
  let if_block3 = (
    /*allowDownload*/
    ctx[6] && create_if_block_2$e(ctx)
  );
  let each_value_1 = ensure_array_like(
    /*actions*/
    ctx[7]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block2)
        if_block2.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      if (if_block3)
        if_block3.l(div0_nodes);
      t3 = claim_space(div0_nodes);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(div0_nodes);
      }
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "rounded-[1.85rem] bg-[#242526] p-2 text-sm text-white bg-opacity-70 flex flex-row gap-1 justify-center items-center");
      attr(div1, "class", "absolute z-10 right-0 left-0 top-0 flex items-center justify-center mt-3");
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      append_hydration(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration(div0, t0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration(div0, t1);
      if (if_block2)
        if_block2.m(div0, null);
      append_hydration(div0, t2);
      if (if_block3)
        if_block3.m(div0, null);
      append_hydration(div0, t3);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*showClose*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*showClose*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5$8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*allowRotation*/
        ctx2[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*allowRotation*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4$8(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*allowPrint*/
        ctx2[5]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*allowPrint*/
          32) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_3$d();
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*allowDownload*/
        ctx2[6]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*allowDownload*/
          64) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_2$e(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (dirty & /*actions*/
      128) {
        each_value_1 = ensure_array_like(
          /*actions*/
          ctx2[7]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$3(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div1_outro)
            div1_outro.end(1);
          div1_intro = create_in_transition(div1, fly, { delay: 250, y: -200 });
          div1_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      if (div1_intro)
        div1_intro.invalidate();
      if (local) {
        div1_outro = create_out_transition(div1, scale, { delay: 300 });
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      destroy_each(each_blocks, detaching);
      if (detaching && div1_outro)
        div1_outro.end();
    }
  };
}
function create_if_block_5$8(ctx) {
  let control;
  let current;
  control = new Control({ props: { data: close } });
  control.$on("click", function() {
    if (is_function(
      /*handleClose*/
      ctx[2]
    ))
      ctx[2].apply(this, arguments);
  });
  return {
    c() {
      create_component(control.$$.fragment);
    },
    l(nodes) {
      claim_component(control.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(control, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(control.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(control.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(control, detaching);
    }
  };
}
function create_if_block_4$8(ctx) {
  let control0;
  let t2;
  let control1;
  let current;
  control0 = new Control({ props: { data: undo } });
  control0.$on(
    "click",
    /*rotateLeft*/
    ctx[17]
  );
  control1 = new Control({ props: { data: redo } });
  control1.$on(
    "click",
    /*rotateRight*/
    ctx[16]
  );
  return {
    c() {
      create_component(control0.$$.fragment);
      t2 = space();
      create_component(control1.$$.fragment);
    },
    l(nodes) {
      claim_component(control0.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(control1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(control0, target, anchor);
      insert_hydration(target, t2, anchor);
      mount_component(control1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(control0.$$.fragment, local);
      transition_in(control1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(control0.$$.fragment, local);
      transition_out(control1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(control0, detaching);
      destroy_component(control1, detaching);
    }
  };
}
function create_if_block_3$d(ctx) {
  let control;
  let current;
  control = new Control({ props: { data: print } });
  control.$on("click", handlePrint);
  return {
    c() {
      create_component(control.$$.fragment);
    },
    l(nodes) {
      claim_component(control.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(control, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(control.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(control.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(control, detaching);
    }
  };
}
function create_if_block_2$e(ctx) {
  let control;
  let current;
  control = new Control({ props: { data: download } });
  control.$on(
    "click",
    /*handleDownload*/
    ctx[18]
  );
  return {
    c() {
      create_component(control.$$.fragment);
    },
    l(nodes) {
      claim_component(control.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(control, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(control.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(control.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(control, detaching);
    }
  };
}
function create_each_block_1$3(ctx) {
  let control;
  let current;
  control = new Control({ props: { data: (
    /*action*/
    ctx[23].data
  ) } });
  control.$on("click", function() {
    if (is_function(
      /*action*/
      ctx[23].action
    ))
      ctx[23].action.apply(this, arguments);
  });
  return {
    c() {
      create_component(control.$$.fragment);
    },
    l(nodes) {
      claim_component(control.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(control, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const control_changes = {};
      if (dirty & /*actions*/
      128)
        control_changes.data = /*action*/
        ctx[23].data;
      control.$set(control_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(control.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(control.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(control, detaching);
    }
  };
}
function create_each_block$a(ctx) {
  let button;
  let button_style_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[19](
        /*i*/
        ctx[22]
      )
    );
  }
  return {
    c() {
      button = element("button");
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", {
        "aria-label": true,
        class: true,
        style: true
      });
      children(button).forEach(detach);
      this.h();
    },
    h() {
      attr(button, "aria-label", "quick view slide " + /*i*/
      (ctx[22] + 1));
      attr(button, "class", "h-1.5 rounded-sm bg-surface max-w-[40px] hover:shadow-lg hover:opacity-90");
      attr(button, "style", button_style_value = `width: calc(100% / ${/*slides*/
      ctx[1].length});`);
      toggle_class(
        button,
        "opacity-50",
        /*activeSlide*/
        ctx[0] !== /*i*/
        ctx[22]
      );
      toggle_class(
        button,
        "hover:opacity-90",
        /*activeSlide*/
        ctx[0] !== /*i*/
        ctx[22]
      );
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*slides*/
      2 && button_style_value !== (button_style_value = `width: calc(100% / ${/*slides*/
      ctx[1].length});`)) {
        attr(button, "style", button_style_value);
      }
      if (dirty & /*activeSlide*/
      1) {
        toggle_class(
          button,
          "opacity-50",
          /*activeSlide*/
          ctx[0] !== /*i*/
          ctx[22]
        );
      }
      if (dirty & /*activeSlide*/
      1) {
        toggle_class(
          button,
          "hover:opacity-90",
          /*activeSlide*/
          ctx[0] !== /*i*/
          ctx[22]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_key_block$1(ctx) {
  let div2;
  let img;
  let img_src_value;
  let img_alt_value;
  let div_transition;
  let current;
  return {
    c() {
      div2 = element("div");
      img = element("img");
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      img = claim_element(div_nodes, "IMG", {
        src: true,
        style: true,
        class: true,
        alt: true
      });
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*slides*/
      ctx[1][
        /*activeSlide*/
        ctx[0]
      ].src))
        attr(img, "src", img_src_value);
      set_style(
        img,
        "--rotation",
        /*rotation*/
        ctx[8] + "deg"
      );
      attr(img, "class", "image block max-w-full shadow-lg max-h-full h-auto w-auto object-cover svelte-1hmkh6r");
      attr(img, "alt", img_alt_value = /*slides*/
      ctx[1][
        /*activeSlide*/
        ctx[0]
      ].alt);
      attr(div2, "class", "absolute inset-0 w-full h-full flex items-center justify-center p-2");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, img);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*slides, activeSlide*/
      3 && !src_url_equal(img.src, img_src_value = /*slides*/
      ctx2[1][
        /*activeSlide*/
        ctx2[0]
      ].src)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*rotation*/
      256) {
        set_style(
          img,
          "--rotation",
          /*rotation*/
          ctx2[8] + "deg"
        );
      }
      if (!current || dirty & /*slides, activeSlide*/
      3 && img_alt_value !== (img_alt_value = /*slides*/
      ctx2[1][
        /*activeSlide*/
        ctx2[0]
      ].alt)) {
        attr(img, "alt", img_alt_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, fade, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, fade, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_if_block$z(ctx) {
  let portal;
  let current;
  portal = new Portal({
    props: {
      $$slots: { default: [create_default_slot$c] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portal.$$.fragment);
    },
    l(nodes) {
      claim_component(portal.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(portal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portal_changes = {};
      if (dirty & /*$$scope, slides, activeSlide, rotation*/
      67109123) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal.$set(portal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portal, detaching);
    }
  };
}
function create_default_slot$c(ctx) {
  let img;
  let img_src_value;
  let img_alt_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", {
        src: true,
        style: true,
        class: true,
        alt: true
      });
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*slides*/
      ctx[1][
        /*activeSlide*/
        ctx[0]
      ].src))
        attr(img, "src", img_src_value);
      set_style(
        img,
        "--rotation",
        /*rotation*/
        ctx[8] + "deg"
      );
      attr(img, "class", "print:block image max-w-full max-h-full h-auto w-auto hidden svelte-1hmkh6r");
      attr(img, "alt", img_alt_value = /*slides*/
      ctx[1][
        /*activeSlide*/
        ctx[0]
      ].alt);
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*slides, activeSlide*/
      3 && !src_url_equal(img.src, img_src_value = /*slides*/
      ctx2[1][
        /*activeSlide*/
        ctx2[0]
      ].src)) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*rotation*/
      256) {
        set_style(
          img,
          "--rotation",
          /*rotation*/
          ctx2[8] + "deg"
        );
      }
      if (dirty & /*slides, activeSlide*/
      3 && img_alt_value !== (img_alt_value = /*slides*/
      ctx2[1][
        /*activeSlide*/
        ctx2[0]
      ].alt)) {
        attr(img, "alt", img_alt_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_fragment$1f(ctx) {
  let div9;
  let div8;
  let div7;
  let div6;
  let t0;
  let div1;
  let div0;
  let t1_value = (
    /*activeSlide*/
    ctx[0] + 1 + ""
  );
  let t1;
  let t2;
  let t3_value = (
    /*slides*/
    ctx[1].length + ""
  );
  let t3;
  let div1_intro;
  let div1_outro;
  let t4;
  let div2;
  let div2_intro;
  let div2_outro;
  let t5;
  let div3;
  let previous_key = (
    /*activeSlide*/
    ctx[0]
  );
  let t6;
  let button0;
  let div4;
  let icon0;
  let t7;
  let span0;
  let textContent = "Previous";
  let div4_intro;
  let button0_intro;
  let button0_outro;
  let t9;
  let button1;
  let div5;
  let icon1;
  let t10;
  let span1;
  let textContent_1 = "Next";
  let div5_intro;
  let button1_intro;
  let button1_outro;
  let div9_intro;
  let div9_outro;
  let t12;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*actions*/
    ctx[7] && create_if_block_1$o(ctx)
  );
  let each_value = ensure_array_like(
    /*slides*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$a(get_each_context$a(ctx, each_value, i2));
  }
  let key_block = create_key_block$1(ctx);
  icon0 = new Icon$7({ props: { data: arrow_back } });
  icon1 = new Icon$7({ props: { data: arrow_forward } });
  let if_block1 = (
    /*allowPrint*/
    ctx[5] && create_if_block$z(ctx)
  );
  return {
    c() {
      div9 = element("div");
      div8 = element("div");
      div7 = element("div");
      div6 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      t1 = text(t1_value);
      t2 = text(" / ");
      t3 = text(t3_value);
      t4 = space();
      div2 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t5 = space();
      div3 = element("div");
      key_block.c();
      t6 = space();
      button0 = element("button");
      div4 = element("div");
      create_component(icon0.$$.fragment);
      t7 = space();
      span0 = element("span");
      span0.textContent = textContent;
      t9 = space();
      button1 = element("button");
      div5 = element("div");
      create_component(icon1.$$.fragment);
      t10 = space();
      span1 = element("span");
      span1.textContent = textContent_1;
      t12 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      this.h();
    },
    l(nodes) {
      div9 = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-modal": true
      });
      var div9_nodes = children(div9);
      div8 = claim_element(div9_nodes, "DIV", { class: true });
      var div8_nodes = children(div8);
      div7 = claim_element(div8_nodes, "DIV", { class: true });
      var div7_nodes = children(div7);
      div6 = claim_element(div7_nodes, "DIV", { class: true });
      var div6_nodes = children(div6);
      if (if_block0)
        if_block0.l(div6_nodes);
      t0 = claim_space(div6_nodes);
      div1 = claim_element(div6_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, t1_value);
      t2 = claim_text(div0_nodes, " / ");
      t3 = claim_text(div0_nodes, t3_value);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      t4 = claim_space(div6_nodes);
      div2 = claim_element(div6_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(div2_nodes);
      }
      div2_nodes.forEach(detach);
      t5 = claim_space(div6_nodes);
      div3 = claim_element(div6_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      key_block.l(div3_nodes);
      div3_nodes.forEach(detach);
      t6 = claim_space(div6_nodes);
      button0 = claim_element(div6_nodes, "BUTTON", {
        "aria-label": true,
        class: true,
        type: true
      });
      var button0_nodes = children(button0);
      div4 = claim_element(button0_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      claim_component(icon0.$$.fragment, div4_nodes);
      t7 = claim_space(div4_nodes);
      span0 = claim_element(div4_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span0) !== "svelte-z31jm6")
        span0.textContent = textContent;
      div4_nodes.forEach(detach);
      button0_nodes.forEach(detach);
      t9 = claim_space(div6_nodes);
      button1 = claim_element(div6_nodes, "BUTTON", {
        "aria-label": true,
        class: true,
        type: true
      });
      var button1_nodes = children(button1);
      div5 = claim_element(button1_nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      claim_component(icon1.$$.fragment, div5_nodes);
      t10 = claim_space(div5_nodes);
      span1 = claim_element(div5_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span1) !== "svelte-xiiv6y")
        span1.textContent = textContent_1;
      div5_nodes.forEach(detach);
      button1_nodes.forEach(detach);
      div6_nodes.forEach(detach);
      div7_nodes.forEach(detach);
      div8_nodes.forEach(detach);
      div9_nodes.forEach(detach);
      t12 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
      this.h();
    },
    h() {
      attr(div0, "class", "rounded-xl bg-[#242526] px-2 py-1 text-sm text-white bg-opacity-70");
      attr(div1, "class", "absolute z-10 right-0 left-0 bottom-7 flex items-center justify-center");
      attr(div2, "class", "absolute z-10 right-0 bottom-0 left-0 flex gap-2 justify-center p-0 mb-3");
      attr(div3, "class", "relative w-full h-full overflow-hidden");
      attr(span0, "class", "sr-only");
      attr(div4, "class", "flex items-center justify-center h-12 w-12 text-white bg-white bg-opacity-30 rounded-full transition-reveal scale-90 group-hover:scale-100 group-hover:bg-opacity-20 group-hover:active:scale-95");
      attr(button0, "aria-label", "previous slide");
      attr(button0, "class", "group absolute z-10 bg-black bg-opacity-5 top-0 bottom-0 flex items-center justify-center px-4 text-center border-0 outline-none hover:outline-none hover:no-underline duration-150 focus:outline-none focus:no-underline shadow-md left-0");
      attr(button0, "type", "button");
      attr(span1, "class", "sr-only");
      attr(div5, "class", "flex items-center justify-center h-12 w-12 text-white bg-white bg-opacity-30 rounded-full transition-reveal scale-90 group-hover:scale-100 group-hover:bg-opacity-20 group-hover:active:scale-95");
      attr(button1, "aria-label", "next slide");
      attr(button1, "class", "group absolute z-10 bg-black bg-opacity-5 top-0 bottom-0 flex items-center justify-center px-4 text-center border-0 outline-none hover:outline-none hover:no-underline duration-150 focus:outline-none focus:no-underline shadow-md right-0");
      attr(button1, "type", "button");
      attr(div6, "class", "relative h-full");
      attr(div7, "class", "content mx-auto h-full w-full transform overflow-hidden pointer-events-auto m-0");
      attr(div8, "class", "modal fixed inset-0 overflow-y-auto p-0 overflow-hidden");
      attr(div9, "class", "fixed inset-0 w-full z-50 pointer-events-none h-full bg-[#18191A]");
      attr(div9, "role", "dialog");
      attr(div9, "aria-modal", "true");
    },
    m(target, anchor) {
      insert_hydration(target, div9, anchor);
      append_hydration(div9, div8);
      append_hydration(div8, div7);
      append_hydration(div7, div6);
      if (if_block0)
        if_block0.m(div6, null);
      append_hydration(div6, t0);
      append_hydration(div6, div1);
      append_hydration(div1, div0);
      append_hydration(div0, t1);
      append_hydration(div0, t2);
      append_hydration(div0, t3);
      append_hydration(div6, t4);
      append_hydration(div6, div2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div2, null);
        }
      }
      append_hydration(div6, t5);
      append_hydration(div6, div3);
      key_block.m(div3, null);
      append_hydration(div6, t6);
      append_hydration(div6, button0);
      append_hydration(button0, div4);
      mount_component(icon0, div4, null);
      append_hydration(div4, t7);
      append_hydration(div4, span0);
      append_hydration(div6, t9);
      append_hydration(div6, button1);
      append_hydration(button1, div5);
      mount_component(icon1, div5, null);
      append_hydration(div5, t10);
      append_hydration(div5, span1);
      insert_hydration(target, t12, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            window_1,
            "keydown",
            /*captureEscapeEvent*/
            ctx[12]
          ),
          listen(
            button0,
            "click",
            /*handlePrevious*/
            ctx[14]
          ),
          listen(
            button1,
            "click",
            /*handleNext*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (
        /*actions*/
        ctx[7]
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & /*actions*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$o(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div6, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if ((!current || dirty & /*activeSlide*/
      1) && t1_value !== (t1_value = /*activeSlide*/
      ctx[0] + 1 + ""))
        set_data(t1, t1_value);
      if ((!current || dirty & /*slides*/
      2) && t3_value !== (t3_value = /*slides*/
      ctx[1].length + ""))
        set_data(t3, t3_value);
      if (dirty & /*slides, activeSlide, handleGoTo*/
      32771) {
        each_value = ensure_array_like(
          /*slides*/
          ctx[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$a(ctx, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block$a(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div2, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*activeSlide*/
      1 && safe_not_equal(previous_key, previous_key = /*activeSlide*/
      ctx[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block$1(ctx);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(div3, null);
      } else {
        key_block.p(ctx, dirty);
      }
      if (
        /*allowPrint*/
        ctx[5]
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & /*allowPrint*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$z(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div1_outro)
            div1_outro.end(1);
          div1_intro = create_in_transition(div1, scale, { delay: 300 });
          div1_intro.start();
        });
      }
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div2_outro)
            div2_outro.end(1);
          div2_intro = create_in_transition(div2, scale, { delay: 300 });
          div2_intro.start();
        });
      }
      transition_in(key_block);
      transition_in(icon0.$$.fragment, local);
      if (local) {
        if (!div4_intro) {
          add_render_callback(() => {
            div4_intro = create_in_transition(div4, scale, { delay: 350 });
            div4_intro.start();
          });
        }
      }
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (button0_outro)
            button0_outro.end(1);
          button0_intro = create_in_transition(button0, fly, { delay: 250, x: -200 });
          button0_intro.start();
        });
      }
      transition_in(icon1.$$.fragment, local);
      if (local) {
        if (!div5_intro) {
          add_render_callback(() => {
            div5_intro = create_in_transition(div5, scale, { delay: 350 });
            div5_intro.start();
          });
        }
      }
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (button1_outro)
            button1_outro.end(1);
          button1_intro = create_in_transition(button1, fly, { delay: 250, x: 200 });
          button1_intro.start();
        });
      }
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div9_outro)
            div9_outro.end(1);
          div9_intro = create_in_transition(
            div9,
            /*receive*/
            ctx[11],
            { key: (
              /*key*/
              ctx[9]
            ) }
          );
          div9_intro.start();
        });
      }
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      if (div1_intro)
        div1_intro.invalidate();
      if (local) {
        div1_outro = create_out_transition(div1, fade, {});
      }
      if (div2_intro)
        div2_intro.invalidate();
      if (local) {
        div2_outro = create_out_transition(div2, fade, {});
      }
      transition_out(key_block);
      transition_out(icon0.$$.fragment, local);
      if (button0_intro)
        button0_intro.invalidate();
      if (local) {
        button0_outro = create_out_transition(button0, fade, {});
      }
      transition_out(icon1.$$.fragment, local);
      if (button1_intro)
        button1_intro.invalidate();
      if (local) {
        button1_outro = create_out_transition(button1, fade, {});
      }
      if (div9_intro)
        div9_intro.invalidate();
      if (local) {
        div9_outro = create_out_transition(
          div9,
          /*send*/
          ctx[10],
          { key: (
            /*key*/
            ctx[9]
          ) }
        );
      }
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div9);
        detach(t12);
        detach(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d();
      if (detaching && div1_outro)
        div1_outro.end();
      destroy_each(each_blocks, detaching);
      if (detaching && div2_outro)
        div2_outro.end();
      key_block.d(detaching);
      destroy_component(icon0);
      if (detaching && button0_outro)
        button0_outro.end();
      destroy_component(icon1);
      if (detaching && button1_outro)
        button1_outro.end();
      if (detaching && div9_outro)
        div9_outro.end();
      if (if_block1)
        if_block1.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function handlePrint() {
  window.print();
}
function instance$1d($$self, $$props, $$invalidate) {
  let key;
  let { slides = [] } = $$props;
  let { activeSlide = 0 } = $$props;
  let { handleClose } = $$props;
  let { showClose = true } = $$props;
  let { allowRotation = true } = $$props;
  let { allowPrint = true } = $$props;
  let { allowDownload = true } = $$props;
  let { actions = [] } = $$props;
  const [send, receive] = crossfade;
  let rotation = 0;
  function captureEscapeEvent(e2) {
    if (e2.key === "Escape" && e2.code === "Escape" && !e2.shiftKey) {
      handleClose();
      e2.preventDefault();
      e2.stopPropagation();
    } else if (e2.key === "ArrowRight" && e2.code === "ArrowRight" && !e2.shiftKey) {
      handleNext();
      e2.preventDefault();
      e2.stopPropagation();
    } else if (e2.key === "ArrowLeft" && e2.code === "ArrowLeft" && !e2.shiftKey) {
      handlePrevious();
      e2.preventDefault();
      e2.stopPropagation();
    }
  }
  function handleNext() {
    if (activeSlide === slides.length - 1) {
      $$invalidate(0, activeSlide = 0);
    } else {
      $$invalidate(0, activeSlide++, activeSlide);
    }
    $$invalidate(8, rotation = 0);
  }
  function handlePrevious() {
    if (activeSlide === 0) {
      $$invalidate(0, activeSlide = slides.length - 1);
    } else {
      $$invalidate(0, activeSlide--, activeSlide);
    }
    $$invalidate(8, rotation = 0);
  }
  function handleGoTo(index2) {
    $$invalidate(0, activeSlide = index2);
  }
  function rotateRight() {
    $$invalidate(8, rotation += 90);
  }
  function rotateLeft() {
    $$invalidate(8, rotation -= 90);
  }
  async function handleDownload() {
    const response = await fetch(slides[activeSlide].src);
    const blob = await response.blob();
    const url = window.URL.createObjectURL(blob);
    const a3 = document.createElement("a");
    a3.style.display = "none";
    a3.href = url;
    a3.download = slides[activeSlide].id;
    document.body.appendChild(a3);
    a3.click();
    window.URL.revokeObjectURL(url);
    a3.remove();
  }
  const click_handler = (i2) => handleGoTo(i2);
  $$self.$$set = ($$props2) => {
    if ("slides" in $$props2)
      $$invalidate(1, slides = $$props2.slides);
    if ("activeSlide" in $$props2)
      $$invalidate(0, activeSlide = $$props2.activeSlide);
    if ("handleClose" in $$props2)
      $$invalidate(2, handleClose = $$props2.handleClose);
    if ("showClose" in $$props2)
      $$invalidate(3, showClose = $$props2.showClose);
    if ("allowRotation" in $$props2)
      $$invalidate(4, allowRotation = $$props2.allowRotation);
    if ("allowPrint" in $$props2)
      $$invalidate(5, allowPrint = $$props2.allowPrint);
    if ("allowDownload" in $$props2)
      $$invalidate(6, allowDownload = $$props2.allowDownload);
    if ("actions" in $$props2)
      $$invalidate(7, actions = $$props2.actions);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*activeSlide, slides*/
    3) {
      $$invalidate(9, key = activeSlide > 3 ? slides[3].id : slides[activeSlide].id);
    }
  };
  return [
    activeSlide,
    slides,
    handleClose,
    showClose,
    allowRotation,
    allowPrint,
    allowDownload,
    actions,
    rotation,
    key,
    send,
    receive,
    captureEscapeEvent,
    handleNext,
    handlePrevious,
    handleGoTo,
    rotateRight,
    rotateLeft,
    handleDownload,
    click_handler
  ];
}
class LightBox extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1d, create_fragment$1f, safe_not_equal, {
      slides: 1,
      activeSlide: 0,
      handleClose: 2,
      showClose: 3,
      allowRotation: 4,
      allowPrint: 5,
      allowDownload: 6,
      actions: 7
    });
  }
}
function create_fragment$1e(ctx) {
  let nav;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let nav_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let nav_data = {};
  for (let i2 = 0; i2 < nav_levels.length; i2 += 1) {
    nav_data = assign$1(nav_data, nav_levels[i2]);
  }
  return {
    c() {
      nav = element("nav");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      nav = claim_element(nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      if (default_slot)
        default_slot.l(nav_nodes);
      nav_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(nav, nav_data);
    },
    m(target, anchor) {
      insert_hydration(target, nav, anchor);
      if (default_slot) {
        default_slot.m(nav, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            nav,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, nav)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(nav, nav_data = get_spread_update(nav_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(nav);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$N = "space-y-1 transition-all duration-300";
function instance$1c($$self, $$props, $$invalidate) {
  let finalClass;
  let $menuCollapse;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { collapsed = false } = $$props;
  let { collapsedWidth = "w-12" } = $$props;
  let { active = "" } = $$props;
  let menuCollapse = writable(collapsed);
  component_subscribe($$self, menuCollapse, (value) => $$invalidate(8, $menuCollapse = value));
  let activeItem = writable(active);
  setContext("menu-collapse", menuCollapse);
  setContext("menu-active-item", activeItem);
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("collapsed" in $$new_props)
      $$invalidate(5, collapsed = $$new_props.collapsed);
    if ("collapsedWidth" in $$new_props)
      $$invalidate(6, collapsedWidth = $$new_props.collapsedWidth);
    if ("active" in $$new_props)
      $$invalidate(7, active = $$new_props.active);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*collapsed*/
    32) {
      menuCollapse.set(collapsed);
    }
    if ($$self.$$.dirty & /*active*/
    128) {
      activeItem.set(active);
    }
    $$invalidate(1, finalClass = twMerge(defaultClass$N, $menuCollapse ? collapsedWidth : "w-full", $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    finalClass,
    forwardEvents,
    menuCollapse,
    $$props,
    collapsed,
    collapsedWidth,
    active,
    $menuCollapse,
    $$scope,
    slots
  ];
}
let Menu$1 = class Menu extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1c, create_fragment$1e, safe_not_equal, {
      use: 0,
      collapsed: 5,
      collapsedWidth: 6,
      active: 7
    });
  }
};
const get_extra_slot_changes$1 = (dirty) => ({});
const get_extra_slot_context$1 = (ctx) => ({});
const get_icon_slot_changes$7 = (dirty) => ({});
const get_icon_slot_context$7 = (ctx) => ({});
function create_fragment$1d(ctx) {
  let div2;
  let a3;
  let span1;
  let t0;
  let span0;
  let t1;
  let t2;
  let t3;
  let hoverbackground;
  let tooltip_action;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = (
    /*#slots*/
    ctx[13].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_icon_slot_context$7
  );
  const extra_slot_template = (
    /*#slots*/
    ctx[13].extra
  );
  const extra_slot = create_slot(
    extra_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    get_extra_slot_context$1
  );
  hoverbackground = new HoverBackground({ props: { class: "rounded-md" } });
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[3]
    ) },
    exclude(
      /*$$props*/
      ctx[9],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      a3 = element("a");
      span1 = element("span");
      if (icon_slot)
        icon_slot.c();
      t0 = space();
      span0 = element("span");
      t1 = text(
        /*label*/
        ctx[1]
      );
      t2 = space();
      if (extra_slot)
        extra_slot.c();
      t3 = space();
      create_component(hoverbackground.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      a3 = claim_element(div_nodes, "A", { href: true, class: true });
      var a_nodes = children(a3);
      span1 = claim_element(a_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      if (icon_slot)
        icon_slot.l(span1_nodes);
      t0 = claim_space(span1_nodes);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t1 = claim_text(
        span0_nodes,
        /*label*/
        ctx[1]
      );
      span0_nodes.forEach(detach);
      span1_nodes.forEach(detach);
      t2 = claim_space(a_nodes);
      if (extra_slot)
        extra_slot.l(a_nodes);
      t3 = claim_space(a_nodes);
      claim_component(hoverbackground.$$.fragment, a_nodes);
      a_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "class", "truncate");
      attr(span1, "class", "flex items-center justify-start flex-grow");
      attr(
        a3,
        "href",
        /*href*/
        ctx[2]
      );
      attr(a3, "class", "group no-underline relative w-full h-10 overflow-hidden flex items-center justify-start px-3 py-2 text-sm font-medium rounded-md");
      toggle_class(
        a3,
        "text-primary-content",
        /*active*/
        ctx[4]
      );
      toggle_class(a3, "text-secondary-content", !/*active*/
      ctx[4]);
      toggle_class(a3, "hover:text-content", !/*active*/
      ctx[4]);
      toggle_class(
        a3,
        "bg-primary",
        /*active*/
        ctx[4]
      );
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, a3);
      append_hydration(a3, span1);
      if (icon_slot) {
        icon_slot.m(span1, null);
      }
      append_hydration(span1, t0);
      append_hydration(span1, span0);
      append_hydration(span0, t1);
      append_hydration(a3, t2);
      if (extra_slot) {
        extra_slot.m(a3, null);
      }
      append_hydration(a3, t3);
      mount_component(hoverbackground, a3, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(tooltip_action = tooltip.call(null, a3, {
            placement: "right",
            content: (
              /*label*/
              ctx[1]
            ),
            arrow: false,
            animation: "scale",
            disabled: !/*$menuCollapse*/
            ctx[5]
          })),
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[6].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_icon_slot_changes$7
            ),
            get_icon_slot_context$7
          );
        }
      }
      if (!current || dirty & /*label*/
      2)
        set_data(
          t1,
          /*label*/
          ctx2[1]
        );
      if (extra_slot) {
        if (extra_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            extra_slot,
            extra_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              extra_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              get_extra_slot_changes$1
            ),
            get_extra_slot_context$1
          );
        }
      }
      if (!current || dirty & /*href*/
      4) {
        attr(
          a3,
          "href",
          /*href*/
          ctx2[2]
        );
      }
      if (tooltip_action && is_function(tooltip_action.update) && dirty & /*label, $menuCollapse*/
      34)
        tooltip_action.update.call(null, {
          placement: "right",
          content: (
            /*label*/
            ctx2[1]
          ),
          arrow: false,
          animation: "scale",
          disabled: !/*$menuCollapse*/
          ctx2[5]
        });
      if (!current || dirty & /*active*/
      16) {
        toggle_class(
          a3,
          "text-primary-content",
          /*active*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*active*/
      16) {
        toggle_class(a3, "text-secondary-content", !/*active*/
        ctx2[4]);
      }
      if (!current || dirty & /*active*/
      16) {
        toggle_class(a3, "hover:text-content", !/*active*/
        ctx2[4]);
      }
      if (!current || dirty & /*active*/
      16) {
        toggle_class(
          a3,
          "bg-primary",
          /*active*/
          ctx2[4]
        );
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        8) && { class: (
          /*finalClass*/
          ctx2[3]
        ) },
        dirty & /*$$props*/
        512 && exclude(
          /*$$props*/
          ctx2[9],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(extra_slot, local);
      transition_in(hoverbackground.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(extra_slot, local);
      transition_out(hoverbackground.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (icon_slot)
        icon_slot.d(detaching);
      if (extra_slot)
        extra_slot.d(detaching);
      destroy_component(hoverbackground);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$M = "transition-all duration-300";
function instance$1b($$self, $$props, $$invalidate) {
  let active;
  let finalClass;
  let $activeItem;
  let $menuCollapse;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { label } = $$props;
  let { href } = $$props;
  let { key } = $$props;
  const menuCollapse = getContext("menu-collapse");
  component_subscribe($$self, menuCollapse, (value) => $$invalidate(5, $menuCollapse = value));
  const activeItem = getContext("menu-active-item");
  component_subscribe($$self, activeItem, (value) => $$invalidate(11, $activeItem = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("href" in $$new_props)
      $$invalidate(2, href = $$new_props.href);
    if ("key" in $$new_props)
      $$invalidate(10, key = $$new_props.key);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$activeItem, key*/
    3072) {
      $$invalidate(4, active = $activeItem === key);
    }
    $$invalidate(3, finalClass = twMerge(defaultClass$M, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    label,
    href,
    finalClass,
    active,
    $menuCollapse,
    forwardEvents,
    menuCollapse,
    activeItem,
    $$props,
    key,
    $activeItem,
    $$scope,
    slots
  ];
}
let Item$1 = class Item4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1b, create_fragment$1d, safe_not_equal, { use: 0, label: 1, href: 2, key: 10 });
  }
};
const get_icon_slot_changes$6 = (dirty) => ({});
const get_icon_slot_context$6 = (ctx) => ({});
function create_if_block$y(ctx) {
  let div1;
  let div0;
  let div1_intro;
  let div1_outro;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[16].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    null
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", {});
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "space-y-1 pt-1");
      toggle_class(
        div0,
        "p-1",
        /*$menuCollapse*/
        ctx[2]
      );
      toggle_class(
        div0,
        "border",
        /*$menuCollapse*/
        ctx[2]
      );
      toggle_class(
        div0,
        "border-border",
        /*$menuCollapse*/
        ctx[2]
      );
      toggle_class(
        div0,
        "shadow-md",
        /*$menuCollapse*/
        ctx[2]
      );
      toggle_class(
        div0,
        "bg-surface",
        /*$menuCollapse*/
        ctx[2]
      );
      toggle_class(
        div0,
        "overflow-hidden",
        /*$menuCollapse*/
        ctx[2]
      );
      toggle_class(
        div0,
        "rounded-md",
        /*$menuCollapse*/
        ctx[2]
      );
      toggle_class(div1, "w-full", !/*$menuCollapse*/
      ctx[2]);
      toggle_class(
        div1,
        "w-56",
        /*$menuCollapse*/
        ctx[2]
      );
      toggle_class(
        div1,
        "absolute",
        /*$menuCollapse*/
        ctx[2]
      );
      toggle_class(
        div1,
        "top-0",
        /*$menuCollapse*/
        ctx[2]
      );
      toggle_class(
        div1,
        "left-12",
        /*$menuCollapse*/
        ctx[2]
      );
      toggle_class(
        div1,
        "pl-2",
        /*$menuCollapse*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      append_hydration(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$menuCollapse*/
      4) {
        toggle_class(
          div0,
          "p-1",
          /*$menuCollapse*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$menuCollapse*/
      4) {
        toggle_class(
          div0,
          "border",
          /*$menuCollapse*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$menuCollapse*/
      4) {
        toggle_class(
          div0,
          "border-border",
          /*$menuCollapse*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$menuCollapse*/
      4) {
        toggle_class(
          div0,
          "shadow-md",
          /*$menuCollapse*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$menuCollapse*/
      4) {
        toggle_class(
          div0,
          "bg-surface",
          /*$menuCollapse*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$menuCollapse*/
      4) {
        toggle_class(
          div0,
          "overflow-hidden",
          /*$menuCollapse*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$menuCollapse*/
      4) {
        toggle_class(
          div0,
          "rounded-md",
          /*$menuCollapse*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$menuCollapse*/
      4) {
        toggle_class(div1, "w-full", !/*$menuCollapse*/
        ctx2[2]);
      }
      if (!current || dirty & /*$menuCollapse*/
      4) {
        toggle_class(
          div1,
          "w-56",
          /*$menuCollapse*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$menuCollapse*/
      4) {
        toggle_class(
          div1,
          "absolute",
          /*$menuCollapse*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$menuCollapse*/
      4) {
        toggle_class(
          div1,
          "top-0",
          /*$menuCollapse*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$menuCollapse*/
      4) {
        toggle_class(
          div1,
          "left-12",
          /*$menuCollapse*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*$menuCollapse*/
      4) {
        toggle_class(
          div1,
          "pl-2",
          /*$menuCollapse*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (div1_outro)
            div1_outro.end(1);
          div1_intro = create_in_transition(
            div1,
            /*transition*/
            ctx[11],
            {}
          );
          div1_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      if (div1_intro)
        div1_intro.invalidate();
      if (local) {
        div1_outro = create_out_transition(
          div1,
          /*transition*/
          ctx[11],
          {}
        );
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div1_outro)
        div1_outro.end();
    }
  };
}
function create_fragment$1c(ctx) {
  let button1;
  let div2;
  let h22;
  let button0;
  let span1;
  let t0;
  let span0;
  let t1;
  let t2;
  let span2;
  let icon;
  let t3;
  let hoverbackground;
  let useActions_action;
  let t4;
  let current;
  let mounted;
  let dispose;
  const icon_slot_template = (
    /*#slots*/
    ctx[16].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_icon_slot_context$6
  );
  icon = new Icon$7({ props: { data: chevron_down } });
  hoverbackground = new HoverBackground({
    props: { class: "rounded-md pointer-events-none " }
  });
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[5]
    ) },
    exclude(
      /*$$props*/
      ctx[12],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  let if_block = (
    /*active*/
    ctx[3] && create_if_block$y(ctx)
  );
  return {
    c() {
      button1 = element("button");
      div2 = element("div");
      h22 = element("h2");
      button0 = element("button");
      span1 = element("span");
      if (icon_slot)
        icon_slot.c();
      t0 = space();
      span0 = element("span");
      t1 = text(
        /*label*/
        ctx[1]
      );
      t2 = space();
      span2 = element("span");
      create_component(icon.$$.fragment);
      t3 = space();
      create_component(hoverbackground.$$.fragment);
      t4 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      button1 = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button1_nodes = children(button1);
      div2 = claim_element(button1_nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      h22 = claim_element(div_nodes, "H2", { class: true });
      var h2_nodes = children(h22);
      button0 = claim_element(h2_nodes, "BUTTON", {
        "aria-label": true,
        class: true,
        type: true
      });
      var button0_nodes = children(button0);
      span1 = claim_element(button0_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      if (icon_slot)
        icon_slot.l(span1_nodes);
      t0 = claim_space(span1_nodes);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t1 = claim_text(
        span0_nodes,
        /*label*/
        ctx[1]
      );
      span0_nodes.forEach(detach);
      span1_nodes.forEach(detach);
      t2 = claim_space(button0_nodes);
      span2 = claim_element(button0_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      claim_component(icon.$$.fragment, span2_nodes);
      span2_nodes.forEach(detach);
      button0_nodes.forEach(detach);
      t3 = claim_space(h2_nodes);
      claim_component(hoverbackground.$$.fragment, h2_nodes);
      h2_nodes.forEach(detach);
      div_nodes.forEach(detach);
      t4 = claim_space(button1_nodes);
      if (if_block)
        if_block.l(button1_nodes);
      button1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "class", "truncate");
      attr(span1, "class", "flex items-center justify-start pointer-events-none");
      attr(span2, "class", "pointer-events-none transition-transform");
      toggle_class(
        span2,
        "-rotate-180",
        /*active*/
        ctx[3]
      );
      attr(button0, "aria-label", "toggle collapse menu");
      attr(button0, "class", "px-3 py-2 relative flex items-center w-full text-sm font-medium justify-between outline-none focus:outline-none");
      attr(button0, "type", "button");
      attr(h22, "class", "group relative m-0 w-full outline-none rounded-md focus:outline-none overflow-hidden");
      toggle_class(
        h22,
        "text-primary-content",
        /*menuActive*/
        ctx[6] && !/*active*/
        ctx[3]
      );
      toggle_class(h22, "text-secondary-content", !/*menuActive*/
      ctx[6] || /*active*/
      ctx[3]);
      toggle_class(
        h22,
        "bg-opacity-10",
        /*active*/
        ctx[3]
      );
      toggle_class(
        h22,
        "bg-content",
        /*active*/
        ctx[3]
      );
      toggle_class(
        h22,
        "bg-primary",
        /*$menuCollapse*/
        ctx[2] && /*menuActive*/
        ctx[6] || !/*$menuCollapse*/
        ctx[2] && !/*active*/
        ctx[3] && /*menuActive*/
        ctx[6]
      );
      set_attributes(div2, div_data);
      attr(button1, "type", "button");
      attr(button1, "class", "relative w-full");
    },
    m(target, anchor) {
      insert_hydration(target, button1, anchor);
      append_hydration(button1, div2);
      append_hydration(div2, h22);
      append_hydration(h22, button0);
      append_hydration(button0, span1);
      if (icon_slot) {
        icon_slot.m(span1, null);
      }
      append_hydration(span1, t0);
      append_hydration(span1, span0);
      append_hydration(span0, t1);
      append_hydration(button0, t2);
      append_hydration(button0, span2);
      mount_component(icon, span2, null);
      append_hydration(h22, t3);
      mount_component(hoverbackground, h22, null);
      append_hydration(button1, t4);
      if (if_block)
        if_block.m(button1, null);
      ctx[17](button1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(!/*$menuCollapse*/
            ctx[2] ? (
              /*toggleOpen*/
              ctx[10]
            ) : void 0))
              (!/*$menuCollapse*/
              ctx[2] ? (
                /*toggleOpen*/
                ctx[10]
              ) : void 0).apply(this, arguments);
          }),
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[7].call(null, div2)
          ),
          listen(button1, "mouseover", function() {
            if (is_function(
              /*$menuCollapse*/
              ctx[2] ? (
                /*toggleOpen*/
                ctx[10]
              ) : void 0
            ))
              /*$menuCollapse*/
              (ctx[2] ? (
                /*toggleOpen*/
                ctx[10]
              ) : void 0).apply(this, arguments);
          }),
          listen(button1, "focus", function() {
            if (is_function(
              /*$menuCollapse*/
              ctx[2] ? (
                /*toggleOpen*/
                ctx[10]
              ) : void 0
            ))
              /*$menuCollapse*/
              (ctx[2] ? (
                /*toggleOpen*/
                ctx[10]
              ) : void 0).apply(this, arguments);
          }),
          listen(button1, "mouseleave", function() {
            if (is_function(
              /*$menuCollapse*/
              ctx[2] ? (
                /*toggleOpen*/
                ctx[10]
              ) : void 0
            ))
              /*$menuCollapse*/
              (ctx[2] ? (
                /*toggleOpen*/
                ctx[10]
              ) : void 0).apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx,
            /*$$scope*/
            ctx[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[15]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx[15],
              dirty,
              get_icon_slot_changes$6
            ),
            get_icon_slot_context$6
          );
        }
      }
      if (!current || dirty & /*label*/
      2)
        set_data(
          t1,
          /*label*/
          ctx[1]
        );
      if (!current || dirty & /*active*/
      8) {
        toggle_class(
          span2,
          "-rotate-180",
          /*active*/
          ctx[3]
        );
      }
      if (!current || dirty & /*menuActive, active*/
      72) {
        toggle_class(
          h22,
          "text-primary-content",
          /*menuActive*/
          ctx[6] && !/*active*/
          ctx[3]
        );
      }
      if (!current || dirty & /*menuActive, active*/
      72) {
        toggle_class(h22, "text-secondary-content", !/*menuActive*/
        ctx[6] || /*active*/
        ctx[3]);
      }
      if (!current || dirty & /*active*/
      8) {
        toggle_class(
          h22,
          "bg-opacity-10",
          /*active*/
          ctx[3]
        );
      }
      if (!current || dirty & /*active*/
      8) {
        toggle_class(
          h22,
          "bg-content",
          /*active*/
          ctx[3]
        );
      }
      if (!current || dirty & /*$menuCollapse, menuActive, active*/
      76) {
        toggle_class(
          h22,
          "bg-primary",
          /*$menuCollapse*/
          ctx[2] && /*menuActive*/
          ctx[6] || !/*$menuCollapse*/
          ctx[2] && !/*active*/
          ctx[3] && /*menuActive*/
          ctx[6]
        );
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        32) && { class: (
          /*finalClass*/
          ctx[5]
        ) },
        dirty & /*$$props*/
        4096 && exclude(
          /*$$props*/
          ctx[12],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx[0]
        );
      if (
        /*active*/
        ctx[3]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*active*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$y(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(button1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(icon.$$.fragment, local);
      transition_in(hoverbackground.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(icon.$$.fragment, local);
      transition_out(hoverbackground.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button1);
      }
      if (icon_slot)
        icon_slot.d(detaching);
      destroy_component(icon);
      destroy_component(hoverbackground);
      if (if_block)
        if_block.d();
      ctx[17](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$L = "transition-all duration-300";
function instance$1a($$self, $$props, $$invalidate) {
  let menuActive;
  let finalClass;
  let $menuCollapse;
  let $activeItem;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { label } = $$props;
  let { key } = $$props;
  let active = false;
  let collapsable;
  const menuCollapse = getContext("menu-collapse");
  component_subscribe($$self, menuCollapse, (value) => $$invalidate(2, $menuCollapse = value));
  const activeItem = getContext("menu-active-item");
  component_subscribe($$self, activeItem, (value) => $$invalidate(14, $activeItem = value));
  let forceCollapse = $menuCollapse ? true : false;
  function toggleOpen(e2) {
    if ($menuCollapse) {
      if (collapsable === e2.target) {
        $$invalidate(3, active = false);
      } else {
        $$invalidate(3, active = true);
      }
    } else {
      if (active) {
        $$invalidate(3, active = false);
      } else {
        $$invalidate(3, active = true);
      }
    }
  }
  function transition(node, config) {
    if ($menuCollapse && !forceCollapse) {
      return scale(node, { start: 0.95 });
    } else if (collapsable && forceCollapse) {
      forceCollapse = false;
      return scale(node, { duration: 0 });
    } else {
      return slide(node);
    }
  }
  setContext("menu-group-key", key);
  function button1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      collapsable = $$value;
      $$invalidate(4, collapsable);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(12, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("label" in $$new_props)
      $$invalidate(1, label = $$new_props.label);
    if ("key" in $$new_props)
      $$invalidate(13, key = $$new_props.key);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$activeItem, key*/
    24576) {
      $$invalidate(6, menuActive = $activeItem.includes(key));
    }
    if ($$self.$$.dirty & /*$menuCollapse*/
    4) {
      if ($menuCollapse) {
        forceCollapse = true;
        $$invalidate(3, active = false);
      }
    }
    $$invalidate(5, finalClass = twMerge(defaultClass$L, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    label,
    $menuCollapse,
    active,
    collapsable,
    finalClass,
    menuActive,
    forwardEvents,
    menuCollapse,
    activeItem,
    toggleOpen,
    transition,
    $$props,
    key,
    $activeItem,
    $$scope,
    slots,
    button1_binding
  ];
}
class Group extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1a, create_fragment$1c, safe_not_equal, { use: 0, label: 1, key: 13 });
  }
}
function create_fragment$1b(ctx) {
  let span;
  let svg;
  let useActions_action;
  let mounted;
  let dispose;
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[7]
    ) },
    exclude(
      /*$$props*/
      ctx[10],
      [
        "use",
        "class",
        "width",
        "data",
        "height",
        "viewBox",
        "stroke",
        "fill",
        "size",
        "color",
        "data"
      ]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      svg = svg_element("svg");
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      svg = claim_svg_element(span_nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        stroke: true,
        fill: true,
        color: true
      });
      var svg_nodes = children(svg);
      svg_nodes.forEach(detach);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(
        svg,
        "width",
        /*width*/
        ctx[2]
      );
      attr(
        svg,
        "height",
        /*height*/
        ctx[3]
      );
      attr(
        svg,
        "viewBox",
        /*viewBox*/
        ctx[1]
      );
      attr(
        svg,
        "stroke",
        /*stroke*/
        ctx[5]
      );
      attr(
        svg,
        "fill",
        /*fill*/
        ctx[6]
      );
      attr(
        svg,
        "color",
        /*color*/
        ctx[4]
      );
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      append_hydration(span, svg);
      svg.innerHTML = /*elements*/
      ctx[8];
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[9].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*elements*/
      256)
        svg.innerHTML = /*elements*/
        ctx2[8];
      if (dirty & /*width*/
      4) {
        attr(
          svg,
          "width",
          /*width*/
          ctx2[2]
        );
      }
      if (dirty & /*height*/
      8) {
        attr(
          svg,
          "height",
          /*height*/
          ctx2[3]
        );
      }
      if (dirty & /*viewBox*/
      2) {
        attr(
          svg,
          "viewBox",
          /*viewBox*/
          ctx2[1]
        );
      }
      if (dirty & /*stroke*/
      32) {
        attr(
          svg,
          "stroke",
          /*stroke*/
          ctx2[5]
        );
      }
      if (dirty & /*fill*/
      64) {
        attr(
          svg,
          "fill",
          /*fill*/
          ctx2[6]
        );
      }
      if (dirty & /*color*/
      16) {
        attr(
          svg,
          "color",
          /*color*/
          ctx2[4]
        );
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        dirty & /*finalClass*/
        128 && { class: (
          /*finalClass*/
          ctx2[7]
        ) },
        dirty & /*$$props*/
        1024 && exclude(
          /*$$props*/
          ctx2[10],
          [
            "use",
            "class",
            "width",
            "data",
            "height",
            "viewBox",
            "stroke",
            "fill",
            "size",
            "color",
            "data"
          ]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$K = "h-6 w-6 min-h-6 min-w-6 mr-3";
function extractViewBox$3(svg) {
  const regex = /viewBox="([\d\- ]+)"/;
  const res = regex.exec(svg);
  if (!res)
    return "0 0 24 24";
  return res[1];
}
function instance$19($$self, $$props, $$invalidate) {
  let elements2;
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { data = "" } = $$props;
  let { viewBox = extractViewBox$3(data) } = $$props;
  let { size = "24px" } = $$props;
  let { width: width2 = size } = $$props;
  let { height = size } = $$props;
  let { color: color2 = "currentColor" } = $$props;
  let { stroke = void 0 } = $$props;
  let { fill: fill2 = color2 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("data" in $$new_props)
      $$invalidate(11, data = $$new_props.data);
    if ("viewBox" in $$new_props)
      $$invalidate(1, viewBox = $$new_props.viewBox);
    if ("size" in $$new_props)
      $$invalidate(12, size = $$new_props.size);
    if ("width" in $$new_props)
      $$invalidate(2, width2 = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(3, height = $$new_props.height);
    if ("color" in $$new_props)
      $$invalidate(4, color2 = $$new_props.color);
    if ("stroke" in $$new_props)
      $$invalidate(5, stroke = $$new_props.stroke);
    if ("fill" in $$new_props)
      $$invalidate(6, fill2 = $$new_props.fill);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data*/
    2048) {
      $$invalidate(8, elements2 = data.replace(/<svg ([^>]*)>/, "").replace("</svg>", ""));
    }
    $$invalidate(7, finalClass = twMerge(defaultClass$K, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    viewBox,
    width2,
    height,
    color2,
    stroke,
    fill2,
    finalClass,
    elements2,
    forwardEvents,
    $$props,
    data,
    size
  ];
}
let Icon$2 = class Icon5 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$19, create_fragment$1b, safe_not_equal, {
      use: 0,
      data: 11,
      viewBox: 1,
      size: 12,
      width: 2,
      height: 3,
      color: 4,
      stroke: 5,
      fill: 6
    });
  }
};
function create_if_block$x(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      children(span).forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "w-6 mr-2");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$1a(ctx) {
  let a3;
  let t0;
  let span;
  let t1;
  let t2;
  let hoverbackground;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  let if_block = !/*$menuCollapse*/
  ctx[5] && create_if_block$x();
  hoverbackground = new HoverBackground({ props: { class: "rounded-md" } });
  let a_levels = [
    { href: (
      /*href*/
      ctx[1]
    ) },
    { class: (
      /*finalClass*/
      ctx[3]
    ) },
    exclude(
      /*$$props*/
      ctx[9],
      ["use", "class", "href"]
    )
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      a3 = element("a");
      if (if_block)
        if_block.c();
      t0 = space();
      span = element("span");
      t1 = text(
        /*label*/
        ctx[2]
      );
      t2 = space();
      create_component(hoverbackground.$$.fragment);
      this.h();
    },
    l(nodes) {
      a3 = claim_element(nodes, "A", { href: true, class: true });
      var a_nodes = children(a3);
      if (if_block)
        if_block.l(a_nodes);
      t0 = claim_space(a_nodes);
      span = claim_element(a_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t1 = claim_text(
        span_nodes,
        /*label*/
        ctx[2]
      );
      span_nodes.forEach(detach);
      t2 = claim_space(a_nodes);
      claim_component(hoverbackground.$$.fragment, a_nodes);
      a_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "truncate");
      set_attributes(a3, a_data);
      toggle_class(
        a3,
        "text-primary-content",
        /*active*/
        ctx[4]
      );
      toggle_class(a3, "text-secondary-content", !/*active*/
      ctx[4]);
      toggle_class(a3, "hover:text-content", !/*active*/
      ctx[4]);
      toggle_class(
        a3,
        "bg-primary",
        /*active*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert_hydration(target, a3, anchor);
      if (if_block)
        if_block.m(a3, null);
      append_hydration(a3, t0);
      append_hydration(a3, span);
      append_hydration(span, t1);
      append_hydration(a3, t2);
      mount_component(hoverbackground, a3, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            a3,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[6].call(null, a3)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!/*$menuCollapse*/
      ctx2[5]) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$x();
          if_block.c();
          if_block.m(a3, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*label*/
      4)
        set_data(
          t1,
          /*label*/
          ctx2[2]
        );
      set_attributes(a3, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        (!current || dirty & /*finalClass*/
        8) && { class: (
          /*finalClass*/
          ctx2[3]
        ) },
        dirty & /*$$props*/
        512 && exclude(
          /*$$props*/
          ctx2[9],
          ["use", "class", "href"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(
        a3,
        "text-primary-content",
        /*active*/
        ctx2[4]
      );
      toggle_class(a3, "text-secondary-content", !/*active*/
      ctx2[4]);
      toggle_class(a3, "hover:text-content", !/*active*/
      ctx2[4]);
      toggle_class(
        a3,
        "bg-primary",
        /*active*/
        ctx2[4]
      );
    },
    i(local) {
      if (current)
        return;
      transition_in(hoverbackground.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(hoverbackground.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(a3);
      }
      if (if_block)
        if_block.d();
      destroy_component(hoverbackground);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$J = "group relative flex items-center min-w-full h-10 px-3 py-2 text-sm font-medium rounded-md";
function instance$18($$self, $$props, $$invalidate) {
  let active;
  let finalClass;
  let $activeItem;
  let $menuCollapse;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { href } = $$props;
  let { label } = $$props;
  let { key } = $$props;
  const menuCollapse = getContext("menu-collapse");
  component_subscribe($$self, menuCollapse, (value) => $$invalidate(5, $menuCollapse = value));
  const activeItem = getContext("menu-active-item");
  component_subscribe($$self, activeItem, (value) => $$invalidate(11, $activeItem = value));
  const groupKey = getContext("menu-group-key");
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("href" in $$new_props)
      $$invalidate(1, href = $$new_props.href);
    if ("label" in $$new_props)
      $$invalidate(2, label = $$new_props.label);
    if ("key" in $$new_props)
      $$invalidate(10, key = $$new_props.key);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$activeItem, key*/
    3072) {
      $$invalidate(4, active = $activeItem === `${groupKey}-${key}`);
    }
    $$invalidate(3, finalClass = twMerge(defaultClass$J, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    href,
    label,
    finalClass,
    active,
    $menuCollapse,
    forwardEvents,
    menuCollapse,
    activeItem,
    $$props,
    key,
    $activeItem
  ];
}
class GroupItem extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$18, create_fragment$1a, safe_not_equal, { use: 0, href: 1, label: 2, key: 10 });
  }
}
const Menu2 = Menu$1;
Menu2.Item = Item$1;
Menu2.Item.Icon = Icon$2;
Menu2.Group = Group;
Menu2.Group.Item = GroupItem;
const get_extra_slot_changes = (dirty) => ({});
const get_extra_slot_context = (ctx) => ({});
const get_content_slot_changes$1 = (dirty) => ({});
const get_content_slot_context$1 = (ctx) => ({});
const get_leading_slot_changes$1 = (dirty) => ({});
const get_leading_slot_context$1 = (ctx) => ({});
function create_if_block_1$n(ctx) {
  let div2;
  let icon;
  let current;
  icon = new Icon$7({ props: { data: (
    /*typeIcon*/
    ctx[2]
  ) } });
  return {
    c() {
      div2 = element("div");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      claim_component(icon.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "flex-shrink-0 text-content");
      toggle_class(
        div2,
        "text-info-icon",
        /*type*/
        ctx[1] === "info"
      );
      toggle_class(
        div2,
        "text-warn-icon",
        /*type*/
        ctx[1] === "warn"
      );
      toggle_class(
        div2,
        "text-success-icon",
        /*type*/
        ctx[1] === "success"
      );
      toggle_class(
        div2,
        "text-error-icon",
        /*type*/
        ctx[1] === "error"
      );
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(icon, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & /*typeIcon*/
      4)
        icon_changes.data = /*typeIcon*/
        ctx2[2];
      icon.$set(icon_changes);
      if (!current || dirty & /*type*/
      2) {
        toggle_class(
          div2,
          "text-info-icon",
          /*type*/
          ctx2[1] === "info"
        );
      }
      if (!current || dirty & /*type*/
      2) {
        toggle_class(
          div2,
          "text-warn-icon",
          /*type*/
          ctx2[1] === "warn"
        );
      }
      if (!current || dirty & /*type*/
      2) {
        toggle_class(
          div2,
          "text-success-icon",
          /*type*/
          ctx2[1] === "success"
        );
      }
      if (!current || dirty & /*type*/
      2) {
        toggle_class(
          div2,
          "text-error-icon",
          /*type*/
          ctx2[1] === "error"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block$w(ctx) {
  let current;
  const leading_slot_template = (
    /*#slots*/
    ctx[8].leading
  );
  const leading_slot = create_slot(
    leading_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_leading_slot_context$1
  );
  return {
    c() {
      if (leading_slot)
        leading_slot.c();
    },
    l(nodes) {
      if (leading_slot)
        leading_slot.l(nodes);
    },
    m(target, anchor) {
      if (leading_slot) {
        leading_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (leading_slot) {
        if (leading_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            leading_slot,
            leading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              leading_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_leading_slot_changes$1
            ),
            get_leading_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leading_slot, local);
      current = true;
    },
    o(local) {
      transition_out(leading_slot, local);
      current = false;
    },
    d(detaching) {
      if (leading_slot)
        leading_slot.d(detaching);
    }
  };
}
function create_fragment$19(ctx) {
  let div2;
  let current_block_type_index;
  let if_block;
  let t0;
  let t1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$w, create_if_block_1$n];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[6].leading
    )
      return 0;
    if (
      /*type*/
      ctx2[1]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const content_slot_template = (
    /*#slots*/
    ctx[8].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_content_slot_context$1
  );
  const extra_slot_template = (
    /*#slots*/
    ctx[8].extra
  );
  const extra_slot = create_slot(
    extra_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_extra_slot_context
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[3]
    ) },
    exclude(
      /*$$props*/
      ctx[5],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      if (content_slot)
        content_slot.c();
      t1 = space();
      if (extra_slot)
        extra_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (if_block)
        if_block.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (content_slot)
        content_slot.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (extra_slot)
        extra_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      append_hydration(div2, t0);
      if (content_slot) {
        content_slot.m(div2, null);
      }
      append_hydration(div2, t1);
      if (extra_slot) {
        extra_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[4].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div2, t0);
        } else {
          if_block = null;
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_content_slot_changes$1
            ),
            get_content_slot_context$1
          );
        }
      }
      if (extra_slot) {
        if (extra_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            extra_slot,
            extra_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              extra_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_extra_slot_changes
            ),
            get_extra_slot_context
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        8) && { class: (
          /*finalClass*/
          ctx2[3]
        ) },
        dirty & /*$$props*/
        32 && exclude(
          /*$$props*/
          ctx2[5],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(content_slot, local);
      transition_in(extra_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(content_slot, local);
      transition_out(extra_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (content_slot)
        content_slot.d(detaching);
      if (extra_slot)
        extra_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$I = "relative cursor-pointer flex items-start pointer-events-auto p-4 w-full max-w-sm overflow-hidden rounded-lg bg-surface shadow-lg border border-border";
function instance$17($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { type = void 0 } = $$props;
  let typeIcon = info;
  if (type === "warn") {
    typeIcon = warn;
  } else if (type === "success") {
    typeIcon = check_circle;
  } else if (type === "error") {
    typeIcon = error;
  }
  let leading = writable(false);
  let extra = writable(false);
  setContext("notification-leading", leading);
  setContext("notification-extra", extra);
  setContext("notification-type", type);
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("type" in $$new_props)
      $$invalidate(1, type = $$new_props.type);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(3, finalClass = twMerge(defaultClass$I, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    type,
    typeIcon,
    finalClass,
    forwardEvents,
    $$props,
    $$slots,
    $$scope,
    slots
  ];
}
let Notification$1 = class Notification extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$17, create_fragment$19, safe_not_equal, { use: 0, type: 1 });
  }
};
const get_description_slot_changes$2 = (dirty) => ({});
const get_description_slot_context$2 = (ctx) => ({});
const get_title_slot_changes$3 = (dirty) => ({});
const get_title_slot_context$3 = (ctx) => ({});
function create_fragment$18(ctx) {
  let div2;
  let t0;
  let t1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[7].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_title_slot_context$3
  );
  const description_slot_template = (
    /*#slots*/
    ctx[7].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_description_slot_context$2
  );
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (title_slot)
        title_slot.c();
      t0 = space();
      if (description_slot)
        description_slot.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (title_slot)
        title_slot.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (description_slot)
        description_slot.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (title_slot) {
        title_slot.m(div2, null);
      }
      append_hydration(div2, t0);
      if (description_slot) {
        description_slot.m(div2, null);
      }
      append_hydration(div2, t1);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_title_slot_changes$3
            ),
            get_title_slot_context$3
          );
        }
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_description_slot_changes$2
            ),
            get_description_slot_context$2
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(description_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      transition_out(description_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (title_slot)
        title_slot.d(detaching);
      if (description_slot)
        description_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$H = "w-0 flex-1 pt-0.5";
const leadingTypeClass = "ml-3 w-0 flex-1 pt-0.5";
function instance$16($$self, $$props, $$invalidate) {
  let finalClass;
  let $leading;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let title = writable(false);
  const leading = getContext("notification-leading");
  component_subscribe($$self, leading, (value) => $$invalidate(5, $leading = value));
  const type = getContext("notification-type");
  setContext("notification-title", title);
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$H, $leading || type ? leadingTypeClass : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, leading, $$props, $leading, $$scope, slots];
}
let Content$1 = class Content5 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$16, create_fragment$18, safe_not_equal, { use: 0 });
  }
};
const get_icon_slot_changes$5 = (dirty) => ({});
const get_icon_slot_context$5 = (ctx) => ({});
const get_avatar_slot_changes$1 = (dirty) => ({});
const get_avatar_slot_context$1 = (ctx) => ({});
function create_fragment$17(ctx) {
  let div2;
  let t0;
  let t1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const avatar_slot_template = (
    /*#slots*/
    ctx[6].avatar
  );
  const avatar_slot = create_slot(
    avatar_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_avatar_slot_context$1
  );
  const icon_slot_template = (
    /*#slots*/
    ctx[6].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_icon_slot_context$5
  );
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (avatar_slot)
        avatar_slot.c();
      t0 = space();
      if (icon_slot)
        icon_slot.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (avatar_slot)
        avatar_slot.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (icon_slot)
        icon_slot.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (avatar_slot) {
        avatar_slot.m(div2, null);
      }
      append_hydration(div2, t0);
      if (icon_slot) {
        icon_slot.m(div2, null);
      }
      append_hydration(div2, t1);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (avatar_slot) {
        if (avatar_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            avatar_slot,
            avatar_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              avatar_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_avatar_slot_changes$1
            ),
            get_avatar_slot_context$1
          );
        }
      }
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_icon_slot_changes$5
            ),
            get_icon_slot_context$5
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(avatar_slot, local);
      transition_in(icon_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(avatar_slot, local);
      transition_out(icon_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (avatar_slot)
        avatar_slot.d(detaching);
      if (icon_slot)
        icon_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$G = "flex-shrink-0 text-content";
function instance$15($$self, $$props, $$invalidate) {
  let finalClass;
  let $leading;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const leading = getContext("notification-leading");
  component_subscribe($$self, leading, (value) => $$invalidate(7, $leading = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$G, $$props.class));
  };
  set_store_value(leading, $leading = true, $leading);
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, leading, $$props, $$scope, slots];
}
class Leading3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$15, create_fragment$17, safe_not_equal, { use: 0 });
  }
}
const Placeholder_svelte_svelte_type_style_lang$1 = "";
const get_icon_slot_changes$4 = (dirty) => ({});
const get_icon_slot_context$4 = (ctx) => ({});
function create_if_block_1$m(ctx) {
  let span;
  let icon;
  let span_class_value;
  let current;
  icon = new Icon$7({
    props: { data: account, size: (
      /*iconSize*/
      ctx[2]
    ) }
  });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", span_class_value = null_to_empty(
        /*iconContainerClass*/
        ctx[3]
      ) + " svelte-13m79ia");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const icon_changes = {};
      if (dirty & /*iconSize*/
      4)
        icon_changes.size = /*iconSize*/
        ctx2[2];
      icon.$set(icon_changes);
      if (!current || dirty & /*iconContainerClass*/
      8 && span_class_value !== (span_class_value = null_to_empty(
        /*iconContainerClass*/
        ctx2[3]
      ) + " svelte-13m79ia")) {
        attr(span, "class", span_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block$v(ctx) {
  let t2;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[10].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_icon_slot_context$4
  );
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
    },
    l(nodes) {
      if (icon_slot)
        icon_slot.l(nodes);
      t2 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      insert_hydration(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_icon_slot_changes$4
            ),
            get_icon_slot_context$4
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (icon_slot)
        icon_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$16(ctx) {
  let div2;
  let current_block_type_index;
  let if_block;
  let useActions_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$v, create_if_block_1$m];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[7].icon || /*$$slots*/
      ctx2[7].default
    )
      return 0;
    if (
      /*placeholder*/
      ctx2[5]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[6],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
      toggle_class(div2, "svelte-13m79ia", true);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[4].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div2, null);
        } else {
          if_block = null;
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        64 && exclude(
          /*$$props*/
          ctx2[6],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(div2, "svelte-13m79ia", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, fade, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, fade, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$F = "absolute text-content inset-0 h-full w-full flex items-center justify-center overflow-hidden bg-default";
const circleClass$2 = "rounded-full";
const roundedClass$2 = "rounded-md";
const defaultIconContainerClass = "absolute text-content h-full w-full";
const xsContainerClass = "bottom-[-0.25rem]";
const smContainerClass = "bottom-[-0.35rem]";
const mdContainerClass = "bottom-[-0.5rem]";
const lgContainerClass = "text-6xl bottom-[-0.6rem]";
const xlContainerClass = "bottom-[-0.75rem]";
const xsIconSize = "24px";
const smIconSize = "32px";
const mdIconSize = "40px";
const lgIconSize = "48px";
const xlIconSize = "64px";
function instance$14($$self, $$props, $$invalidate) {
  let iconContainerClass2;
  let iconSize2;
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { loading = false } = $$props;
  const shape = getContext("notification-avatar-shape");
  const size = getContext("notification-avatar-size");
  const placeholder = getContext("notification-avatar-placeholder");
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("loading" in $$new_props)
      $$invalidate(8, loading = $$new_props.loading);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$F, loading ? "loading" : false, shape === "circle" ? circleClass$2 : false, shape === "rounded" ? roundedClass$2 : false, $$props.class));
  };
  $$invalidate(3, iconContainerClass2 = twMerge(defaultIconContainerClass, size === "xs" ? xsContainerClass : false, size === "sm" ? smContainerClass : false, size === "md" ? mdContainerClass : false, size === "lg" ? lgContainerClass : false, size === "xl" ? xlContainerClass : false));
  $$invalidate(2, iconSize2 = twMerge(size === "xs" ? xsIconSize : false, size === "sm" ? smIconSize : false, size === "md" ? mdIconSize : false, size === "lg" ? lgIconSize : false, size === "xl" ? xlIconSize : false));
  $$props = exclude_internal_props($$props);
  return [
    use,
    finalClass,
    iconSize2,
    iconContainerClass2,
    forwardEvents,
    placeholder,
    $$props,
    $$slots,
    loading,
    $$scope,
    slots
  ];
}
let Placeholder$1 = class Placeholder6 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$14, create_fragment$16, safe_not_equal, { use: 0, loading: 8 });
  }
};
const get_indicator_slot_changes$1 = (dirty) => ({});
const get_indicator_slot_context$1 = (ctx) => ({});
const get_placeholder_slot_changes$1 = (dirty) => ({});
const get_placeholder_slot_context$1 = (ctx) => ({});
function create_if_block_5$7(ctx) {
  let span1;
  let span0;
  let t2;
  let useActions_action;
  let mounted;
  let dispose;
  let span1_levels = [
    { class: (
      /*finalClass*/
      ctx[9]
    ) },
    exclude(
      /*$$props*/
      ctx[11],
      ["use", "class"]
    )
  ];
  let span_data_1 = {};
  for (let i2 = 0; i2 < span1_levels.length; i2 += 1) {
    span_data_1 = assign$1(span_data_1, span1_levels[i2]);
  }
  return {
    c() {
      span1 = element("span");
      span0 = element("span");
      t2 = text(
        /*initials*/
        ctx[4]
      );
      this.h();
    },
    l(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t2 = claim_text(
        span0_nodes,
        /*initials*/
        ctx[4]
      );
      span0_nodes.forEach(detach);
      span1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "class", "font-bold leading-none text-current");
      toggle_class(
        span0,
        "text-xs",
        /*size*/
        ctx[3] === "xs"
      );
      toggle_class(
        span0,
        "text-sm",
        /*size*/
        ctx[3] === "sm"
      );
      toggle_class(
        span0,
        "text-xl",
        /*size*/
        ctx[3] === "lg"
      );
      toggle_class(
        span0,
        "text-2xl",
        /*size*/
        ctx[3] === "xl"
      );
      set_attributes(span1, span_data_1);
    },
    m(target, anchor) {
      insert_hydration(target, span1, anchor);
      append_hydration(span1, span0);
      append_hydration(span0, t2);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span1,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[10].call(null, span1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*initials*/
      16)
        set_data(
          t2,
          /*initials*/
          ctx2[4]
        );
      if (dirty & /*size*/
      8) {
        toggle_class(
          span0,
          "text-xs",
          /*size*/
          ctx2[3] === "xs"
        );
      }
      if (dirty & /*size*/
      8) {
        toggle_class(
          span0,
          "text-sm",
          /*size*/
          ctx2[3] === "sm"
        );
      }
      if (dirty & /*size*/
      8) {
        toggle_class(
          span0,
          "text-xl",
          /*size*/
          ctx2[3] === "lg"
        );
      }
      if (dirty & /*size*/
      8) {
        toggle_class(
          span0,
          "text-2xl",
          /*size*/
          ctx2[3] === "xl"
        );
      }
      set_attributes(span1, span_data_1 = get_spread_update(span1_levels, [
        dirty & /*finalClass*/
        512 && { class: (
          /*finalClass*/
          ctx2[9]
        ) },
        dirty & /*$$props*/
        2048 && exclude(
          /*$$props*/
          ctx2[11],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$u(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$l, create_if_block_2$d, create_if_block_4$7];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*loaded*/
      ctx2[5]
    )
      return 0;
    if (
      /*failed*/
      ctx2[6]
    )
      return 1;
    if (
      /*loading*/
      ctx2[7]
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const indicator_slot_template = (
    /*#slots*/
    ctx[16].indicator
  );
  const indicator_slot = create_slot(
    indicator_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_indicator_slot_context$1
  );
  let span_levels = [
    { class: (
      /*finalContainerClass*/
      ctx[8]
    ) },
    exclude(
      /*$$props*/
      ctx[11],
      ["use", "class", "src"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (if_block)
        if_block.c();
      t2 = space();
      if (indicator_slot)
        indicator_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      t2 = claim_space(span_nodes);
      if (indicator_slot)
        indicator_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(span, null);
      }
      append_hydration(span, t2);
      if (indicator_slot) {
        indicator_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[10].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(span, t2);
        } else {
          if_block = null;
        }
      }
      if (indicator_slot) {
        if (indicator_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            indicator_slot,
            indicator_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              indicator_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_indicator_slot_changes$1
            ),
            get_indicator_slot_context$1
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalContainerClass*/
        256) && { class: (
          /*finalContainerClass*/
          ctx2[8]
        ) },
        dirty & /*$$props*/
        2048 && exclude(
          /*$$props*/
          ctx2[11],
          ["use", "class", "src"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(indicator_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(indicator_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (indicator_slot)
        indicator_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4$7(ctx) {
  let placeholder_1;
  let current;
  placeholder_1 = new Placeholder$1({ props: { loading: true } });
  return {
    c() {
      create_component(placeholder_1.$$.fragment);
    },
    l(nodes) {
      claim_component(placeholder_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(placeholder_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(placeholder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(placeholder_1, detaching);
    }
  };
}
function create_if_block_2$d(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3$c, create_else_block$c];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[12].placeholder
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_1$l(ctx) {
  let img;
  let img_style_value;
  let img_src_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", {
        class: true,
        style: true,
        src: true,
        alt: true
      });
      this.h();
    },
    h() {
      attr(
        img,
        "class",
        /*finalClass*/
        ctx[9]
      );
      attr(img, "style", img_style_value = /*$$props*/
      ctx[11].style);
      if (!src_url_equal(img.src, img_src_value = /*src*/
      ctx[1] || ""))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*alt*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*finalClass*/
      512) {
        attr(
          img,
          "class",
          /*finalClass*/
          ctx2[9]
        );
      }
      if (dirty & /*$$props*/
      2048 && img_style_value !== (img_style_value = /*$$props*/
      ctx2[11].style)) {
        attr(img, "style", img_style_value);
      }
      if (dirty & /*src*/
      2 && !src_url_equal(img.src, img_src_value = /*src*/
      ctx2[1] || "")) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*alt*/
      4) {
        attr(
          img,
          "alt",
          /*alt*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_else_block$c(ctx) {
  let placeholder_1;
  let current;
  placeholder_1 = new Placeholder$1({});
  return {
    c() {
      create_component(placeholder_1.$$.fragment);
    },
    l(nodes) {
      claim_component(placeholder_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(placeholder_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(placeholder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(placeholder_1, detaching);
    }
  };
}
function create_if_block_3$c(ctx) {
  let current;
  const placeholder_slot_template = (
    /*#slots*/
    ctx[16].placeholder
  );
  const placeholder_slot = create_slot(
    placeholder_slot_template,
    ctx,
    /*$$scope*/
    ctx[15],
    get_placeholder_slot_context$1
  );
  return {
    c() {
      if (placeholder_slot)
        placeholder_slot.c();
    },
    l(nodes) {
      if (placeholder_slot)
        placeholder_slot.l(nodes);
    },
    m(target, anchor) {
      if (placeholder_slot) {
        placeholder_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (placeholder_slot) {
        if (placeholder_slot.p && (!current || dirty & /*$$scope*/
        32768)) {
          update_slot_base(
            placeholder_slot,
            placeholder_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[15],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[15]
            ) : get_slot_changes(
              placeholder_slot_template,
              /*$$scope*/
              ctx2[15],
              dirty,
              get_placeholder_slot_changes$1
            ),
            get_placeholder_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(placeholder_slot, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_slot, local);
      current = false;
    },
    d(detaching) {
      if (placeholder_slot)
        placeholder_slot.d(detaching);
    }
  };
}
function create_fragment$15(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$u, create_if_block_5$7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*src*/
      ctx2[1]
    )
      return 0;
    if (
      /*initials*/
      ctx2[4]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
const srcClass = "inline-block absolute";
const srcContainerClass = "inline-block relative align-middle";
const initialClass = "inline-flex items-center justify-center align-middle bg-default text-default-content";
const xsClass = "h-6 w-6";
const smClass = "h-8 w-8";
const mdClass = "h-10 w-10";
const lgClass = "h-12 w-12";
const xlClass = "h-16 w-16";
const circleClass$1 = "rounded-full";
const roundedClass$1 = "rounded-md";
function instance$13($$self, $$props, $$invalidate) {
  let finalClass;
  let finalContainerClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { src = void 0 } = $$props;
  let { alt = "avatar" } = $$props;
  let { shape = "circle" } = $$props;
  let { size = "md" } = $$props;
  let { initials = void 0 } = $$props;
  let { placeholder = true } = $$props;
  let loaded = false;
  let failed = false;
  let loading = true;
  setContext("notification-avatar-shape", shape);
  setContext("notification-avatar-size", size);
  setContext("notification-avatar-placeholder", placeholder);
  onMount(() => {
    if (src) {
      const image = new Image();
      image.src = src;
      $$invalidate(7, loading = true);
      image.onload = () => {
        $$invalidate(7, loading = false);
        $$invalidate(5, loaded = true);
      };
      image.onerror = () => {
        $$invalidate(7, loading = false);
        $$invalidate(6, failed = true);
      };
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(11, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("src" in $$new_props)
      $$invalidate(1, src = $$new_props.src);
    if ("alt" in $$new_props)
      $$invalidate(2, alt = $$new_props.alt);
    if ("shape" in $$new_props)
      $$invalidate(13, shape = $$new_props.shape);
    if ("size" in $$new_props)
      $$invalidate(3, size = $$new_props.size);
    if ("initials" in $$new_props)
      $$invalidate(4, initials = $$new_props.initials);
    if ("placeholder" in $$new_props)
      $$invalidate(14, placeholder = $$new_props.placeholder);
    if ("$$scope" in $$new_props)
      $$invalidate(15, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(9, finalClass = twMerge(src && !initials ? srcClass : false, initials && !src ? initialClass : false, size === "xs" ? xsClass : false, size === "sm" ? smClass : false, size === "md" ? mdClass : false, size === "lg" ? lgClass : false, size === "xl" ? xlClass : false, shape === "circle" ? circleClass$1 : false, shape === "rounded" ? roundedClass$1 : false, $$props.class));
    $$invalidate(8, finalContainerClass = twMerge(src && !initials ? srcContainerClass : false, size === "xs" ? xsClass : false, size === "sm" ? smClass : false, size === "md" ? mdClass : false, size === "lg" ? lgClass : false, size === "xl" ? xlClass : false, shape === "circle" ? circleClass$1 : false, shape === "rounded" ? roundedClass$1 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    src,
    alt,
    size,
    initials,
    loaded,
    failed,
    loading,
    finalContainerClass,
    finalClass,
    forwardEvents,
    $$props,
    $$slots,
    shape,
    placeholder,
    $$scope,
    slots
  ];
}
let Avatar$1 = class Avatar6 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$13, create_fragment$15, safe_not_equal, {
      use: 0,
      src: 1,
      alt: 2,
      shape: 13,
      size: 3,
      initials: 4,
      placeholder: 14
    });
  }
};
function create_fragment$14(ctx) {
  let p;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let p_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let p_data = {};
  for (let i2 = 0; i2 < p_levels.length; i2 += 1) {
    p_data = assign$1(p_data, p_levels[i2]);
  }
  return {
    c() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(p, p_data);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            p,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, p)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$E = "text-sm text-secondary-content";
const titleClass = "mt-1";
function instance$12($$self, $$props, $$invalidate) {
  let finalClass;
  let $title;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const title = getContext("notification-title");
  component_subscribe($$self, title, (value) => $$invalidate(5, $title = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$E, $title ? titleClass : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, title, $$props, $title, $$scope, slots];
}
let Description$2 = class Description6 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$12, create_fragment$14, safe_not_equal, { use: 0 });
  }
};
function create_fragment$13(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$D = "ml-4 flex flex-shrink-0 relative top-0 right-0";
function instance$11($$self, $$props, $$invalidate) {
  let finalClass;
  let $extra;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const extra = getContext("notification-extra");
  component_subscribe($$self, extra, (value) => $$invalidate(7, $extra = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$D, $$props.class));
  };
  set_store_value(extra, $extra = true, $extra);
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, extra, $$props, $$scope, slots];
}
class Extra3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$11, create_fragment$13, safe_not_equal, { use: 0 });
  }
}
function create_fragment$12(ctx) {
  let p;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let p_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let p_data = {};
  for (let i2 = 0; i2 < p_levels.length; i2 += 1) {
    p_data = assign$1(p_data, p_levels[i2]);
  }
  return {
    c() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(p, p_data);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            p,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, p)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$C = "text-sm font-medium text-content";
function instance$10($$self, $$props, $$invalidate) {
  let finalClass;
  let $title;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const title = getContext("notification-title");
  component_subscribe($$self, title, (value) => $$invalidate(7, $title = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$C, $$props.class));
  };
  set_store_value(title, $title = true, $title);
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, title, $$props, $$scope, slots];
}
let Title$4 = class Title6 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$10, create_fragment$12, safe_not_equal, { use: 0 });
  }
};
const Notification2 = Notification$1;
Notification2.Leading = Leading3;
Notification2.Leading.Avatar = Avatar$1;
Notification2.Leading.Icon = Icon$7;
Notification2.Content = Content$1;
Notification2.Content.Title = Title$4;
Notification2.Content.Description = Description$2;
Notification2.Extra = Extra3;
const get_actions_slot_changes$1 = (dirty) => ({});
const get_actions_slot_context$1 = (ctx) => ({});
const get_status_slot_changes = (dirty) => ({});
const get_status_slot_context = (ctx) => ({});
const get_images_slot_changes = (dirty) => ({});
const get_images_slot_context = (ctx) => ({});
const get_content_slot_changes = (dirty) => ({});
const get_content_slot_context = (ctx) => ({});
const get_header_slot_changes$1 = (dirty) => ({});
const get_header_slot_context$1 = (ctx) => ({});
function create_fragment$11(ctx) {
  let div2;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const header_slot_template = (
    /*#slots*/
    ctx[6].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_header_slot_context$1
  );
  const content_slot_template = (
    /*#slots*/
    ctx[6].content
  );
  const content_slot = create_slot(
    content_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_content_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const images_slot_template = (
    /*#slots*/
    ctx[6].images
  );
  const images_slot = create_slot(
    images_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_images_slot_context
  );
  const status_slot_template = (
    /*#slots*/
    ctx[6].status
  );
  const status_slot = create_slot(
    status_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_status_slot_context
  );
  const actions_slot_template = (
    /*#slots*/
    ctx[6].actions
  );
  const actions_slot = create_slot(
    actions_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_actions_slot_context$1
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (header_slot)
        header_slot.c();
      t0 = space();
      if (content_slot)
        content_slot.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (images_slot)
        images_slot.c();
      t3 = space();
      if (status_slot)
        status_slot.c();
      t4 = space();
      if (actions_slot)
        actions_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (header_slot)
        header_slot.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (content_slot)
        content_slot.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (images_slot)
        images_slot.l(div_nodes);
      t3 = claim_space(div_nodes);
      if (status_slot)
        status_slot.l(div_nodes);
      t4 = claim_space(div_nodes);
      if (actions_slot)
        actions_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (header_slot) {
        header_slot.m(div2, null);
      }
      append_hydration(div2, t0);
      if (content_slot) {
        content_slot.m(div2, null);
      }
      append_hydration(div2, t1);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      append_hydration(div2, t2);
      if (images_slot) {
        images_slot.m(div2, null);
      }
      append_hydration(div2, t3);
      if (status_slot) {
        status_slot.m(div2, null);
      }
      append_hydration(div2, t4);
      if (actions_slot) {
        actions_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_header_slot_changes$1
            ),
            get_header_slot_context$1
          );
        }
      }
      if (content_slot) {
        if (content_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            content_slot,
            content_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              content_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_content_slot_changes
            ),
            get_content_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (images_slot) {
        if (images_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            images_slot,
            images_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              images_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_images_slot_changes
            ),
            get_images_slot_context
          );
        }
      }
      if (status_slot) {
        if (status_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            status_slot,
            status_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              status_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_status_slot_changes
            ),
            get_status_slot_context
          );
        }
      }
      if (actions_slot) {
        if (actions_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            actions_slot,
            actions_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              actions_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_actions_slot_changes$1
            ),
            get_actions_slot_context$1
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      transition_in(content_slot, local);
      transition_in(default_slot, local);
      transition_in(images_slot, local);
      transition_in(status_slot, local);
      transition_in(actions_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      transition_out(content_slot, local);
      transition_out(default_slot, local);
      transition_out(images_slot, local);
      transition_out(status_slot, local);
      transition_out(actions_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (header_slot)
        header_slot.d(detaching);
      if (content_slot)
        content_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (images_slot)
        images_slot.d(detaching);
      if (status_slot)
        status_slot.d(detaching);
      if (actions_slot)
        actions_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$B = "bg-surface text-content rounded-md shadow-md";
const borderClass = "border border-border";
function instance$$($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { bordered = false } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("bordered" in $$new_props)
      $$invalidate(4, bordered = $$new_props.bordered);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$B, bordered ? borderClass : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, bordered, $$scope, slots];
}
let Post$1 = class Post extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$$, create_fragment$11, safe_not_equal, { use: 0, bordered: 4 });
  }
};
const get_extras_slot_changes = (dirty) => ({});
const get_extras_slot_context = (ctx) => ({});
const get_created_slot_changes = (dirty) => ({});
const get_created_slot_context = (ctx) => ({});
const get_creator_slot_changes = (dirty) => ({});
const get_creator_slot_context = (ctx) => ({});
const get_avatar_slot_changes = (dirty) => ({});
const get_avatar_slot_context = (ctx) => ({});
function create_fragment$10(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let t1;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const avatar_slot_template = (
    /*#slots*/
    ctx[5].avatar
  );
  const avatar_slot = create_slot(
    avatar_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_avatar_slot_context
  );
  const creator_slot_template = (
    /*#slots*/
    ctx[5].creator
  );
  const creator_slot = create_slot(
    creator_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_creator_slot_context
  );
  const created_slot_template = (
    /*#slots*/
    ctx[5].created
  );
  const created_slot = create_slot(
    created_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_created_slot_context
  );
  const extras_slot_template = (
    /*#slots*/
    ctx[5].extras
  );
  const extras_slot = create_slot(
    extras_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_extras_slot_context
  );
  let div2_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data_2 = {};
  for (let i2 = 0; i2 < div2_levels.length; i2 += 1) {
    div_data_2 = assign$1(div_data_2, div2_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      if (avatar_slot)
        avatar_slot.c();
      t0 = space();
      div1 = element("div");
      if (creator_slot)
        creator_slot.c();
      t1 = space();
      if (created_slot)
        created_slot.c();
      t2 = space();
      if (extras_slot)
        extras_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (avatar_slot)
        avatar_slot.l(div0_nodes);
      div0_nodes.forEach(detach);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (creator_slot)
        creator_slot.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      if (created_slot)
        created_slot.l(div1_nodes);
      div1_nodes.forEach(detach);
      t2 = claim_space(div2_nodes);
      if (extras_slot)
        extras_slot.l(div2_nodes);
      div2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "flex-shrink");
      attr(div1, "class", "flex flex-col flex-grow h-full ml-3");
      set_attributes(div2, div_data_2);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, div0);
      if (avatar_slot) {
        avatar_slot.m(div0, null);
      }
      append_hydration(div2, t0);
      append_hydration(div2, div1);
      if (creator_slot) {
        creator_slot.m(div1, null);
      }
      append_hydration(div1, t1);
      if (created_slot) {
        created_slot.m(div1, null);
      }
      append_hydration(div2, t2);
      if (extras_slot) {
        extras_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (avatar_slot) {
        if (avatar_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            avatar_slot,
            avatar_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              avatar_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_avatar_slot_changes
            ),
            get_avatar_slot_context
          );
        }
      }
      if (creator_slot) {
        if (creator_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            creator_slot,
            creator_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              creator_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_creator_slot_changes
            ),
            get_creator_slot_context
          );
        }
      }
      if (created_slot) {
        if (created_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            created_slot,
            created_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              created_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_created_slot_changes
            ),
            get_created_slot_context
          );
        }
      }
      if (extras_slot) {
        if (extras_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            extras_slot,
            extras_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              extras_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_extras_slot_changes
            ),
            get_extras_slot_context
          );
        }
      }
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(avatar_slot, local);
      transition_in(creator_slot, local);
      transition_in(created_slot, local);
      transition_in(extras_slot, local);
      current = true;
    },
    o(local) {
      transition_out(avatar_slot, local);
      transition_out(creator_slot, local);
      transition_out(created_slot, local);
      transition_out(extras_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (avatar_slot)
        avatar_slot.d(detaching);
      if (creator_slot)
        creator_slot.d(detaching);
      if (created_slot)
        created_slot.d(detaching);
      if (extras_slot)
        extras_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$A = "first:rounded-t-md last:rounded-b-md py-1.5 px-1.5 sm:px-3 h-14 flex flex-row border-b border-border";
function instance$_($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$A, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Header$1 = class Header3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$_, create_fragment$10, safe_not_equal, { use: 0 });
  }
};
function create_fragment$$(ctx) {
  let h4;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let h4_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let h4_data = {};
  for (let i2 = 0; i2 < h4_levels.length; i2 += 1) {
    h4_data = assign$1(h4_data, h4_levels[i2]);
  }
  return {
    c() {
      h4 = element("h4");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      h4 = claim_element(nodes, "H4", { class: true });
      var h4_nodes = children(h4);
      if (default_slot)
        default_slot.l(h4_nodes);
      h4_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(h4, h4_data);
    },
    m(target, anchor) {
      insert_hydration(target, h4, anchor);
      if (default_slot) {
        default_slot.m(h4, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            h4,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, h4)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(h4, h4_data = get_spread_update(h4_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h4);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$z = "text-md font-semibold text-content";
function instance$Z($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$z, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
class Creator extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Z, create_fragment$$, safe_not_equal, { use: 0 });
  }
}
function create_fragment$_(ctx) {
  let p;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let p_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let p_data = {};
  for (let i2 = 0; i2 < p_levels.length; i2 += 1) {
    p_data = assign$1(p_data, p_levels[i2]);
  }
  return {
    c() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(p, p_data);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            p,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, p)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$y = "text-xs text-secondary-content";
function instance$Y($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$y, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
class Created extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Y, create_fragment$_, safe_not_equal, { use: 0 });
  }
}
function create_fragment$Z(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$x = "text-content first:rounded-t-md last:rounded-b-md px-2 py-3 sm:px-6";
function instance$X($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$x, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
class Content6 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$X, create_fragment$Z, safe_not_equal, { use: 0 });
  }
}
function create_if_block_10$3(ctx) {
  let div1;
  let t0;
  let div0;
  let t1;
  let t2;
  let if_block0 = !/*lightBox1Open*/
  ctx[8] && create_if_block_15(ctx);
  let if_block1 = !/*lightBox2Open*/
  ctx[9] && create_if_block_14(ctx);
  let if_block2 = !/*lightBox3Open*/
  ctx[10] && create_if_block_13(ctx);
  let if_block3 = !/*lightBox4Open*/
  ctx[11] && create_if_block_11$2(ctx);
  return {
    c() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block1)
        if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block2)
        if_block2.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      if (if_block3)
        if_block3.l(div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "w-full max-w-full max-h-full grid grid-rows-3 grid-flow-row gap-1 aspect-[1/2]");
      attr(div1, "class", "w-full h-full max-w-full max-h-full grid grid-cols-2 grid-flow-col aspect-[1/1]");
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration(div1, t0);
      append_hydration(div1, div0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration(div0, t1);
      if (if_block2)
        if_block2.m(div0, null);
      append_hydration(div0, t2);
      if (if_block3)
        if_block3.m(div0, null);
    },
    p(ctx2, dirty) {
      if (!/*lightBox1Open*/
      ctx2[8]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*lightBox1Open*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_15(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*lightBox2Open*/
      ctx2[9]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*lightBox2Open*/
          512) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_14(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!/*lightBox3Open*/
      ctx2[10]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*lightBox3Open*/
          1024) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_13(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!/*lightBox4Open*/
      ctx2[11]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*lightBox4Open*/
          2048) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_11$2(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
    }
  };
}
function create_if_block_6$4(ctx) {
  let div1;
  let t0;
  let div0;
  let t1;
  let if_block0 = !/*lightBox1Open*/
  ctx[8] && create_if_block_9$3(ctx);
  let if_block1 = !/*lightBox2Open*/
  ctx[9] && create_if_block_8$4(ctx);
  let if_block2 = !/*lightBox3Open*/
  ctx[10] && create_if_block_7$4(ctx);
  return {
    c() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block1)
        if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block2)
        if_block2.l(div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "w-full max-w-full max-h-full grid grid-rows-2 grid-flow-row gap-1 aspect-[1/2]");
      attr(div1, "class", "w-full h-full max-w-full max-h-full grid grid-cols-2 grid-flow-col aspect-[1/1]");
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration(div1, t0);
      append_hydration(div1, div0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration(div0, t1);
      if (if_block2)
        if_block2.m(div0, null);
    },
    p(ctx2, dirty) {
      if (!/*lightBox1Open*/
      ctx2[8]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*lightBox1Open*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_9$3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*lightBox2Open*/
      ctx2[9]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*lightBox2Open*/
          512) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_8$4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!/*lightBox3Open*/
      ctx2[10]) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*lightBox3Open*/
          1024) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_7$4(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function create_if_block_3$b(ctx) {
  let div2;
  let t2;
  let if_block0 = !/*lightBox1Open*/
  ctx[8] && create_if_block_5$6(ctx);
  let if_block1 = !/*lightBox2Open*/
  ctx[9] && create_if_block_4$6(ctx);
  return {
    c() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (if_block0)
        if_block0.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "w-full max-w-full max-h-full grid grid-rows-2 grid-flow-row gap-1");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append_hydration(div2, t2);
      if (if_block1)
        if_block1.m(div2, null);
    },
    p(ctx2, dirty) {
      if (!/*lightBox1Open*/
      ctx2[8]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*lightBox1Open*/
          256) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5$6(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!/*lightBox2Open*/
      ctx2[9]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*lightBox2Open*/
          512) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4$6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_1$k(ctx) {
  let if_block_anchor;
  let if_block = !/*lightBox1Open*/
  ctx[8] && create_if_block_2$c(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (!/*lightBox1Open*/
      ctx2[8]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*lightBox1Open*/
          256) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2$c(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_15(ctx) {
  let button;
  let img;
  let img_src_value;
  let button_intro;
  let button_outro;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      img = claim_element(button_nodes, "IMG", { src: true, alt: true, class: true });
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][0].src))
        attr(img, "src", img_src_value);
      attr(img, "alt", "post-1");
      attr(img, "class", "w-full h-full object-center object-cover");
      attr(button, "type", "button");
      attr(button, "class", "w-full h-full max-w-full max-h-full relative pr-1");
      toggle_class(
        button,
        "cursor-pointer",
        /*handleClick*/
        ctx[3] || /*includeLightBox*/
        ctx[4]
      );
      toggle_class(button, "cursor-default", !/*handleClick*/
      ctx[3] && !/*includeLightBox*/
      ctx[4]);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, img);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_6*/
          ctx[25]
        );
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*images*/
      4 && !src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][0].src)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(
          button,
          "cursor-pointer",
          /*handleClick*/
          ctx[3] || /*includeLightBox*/
          ctx[4]
        );
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(button, "cursor-default", !/*handleClick*/
        ctx[3] && !/*includeLightBox*/
        ctx[4]);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (button_outro)
            button_outro.end(1);
          button_intro = create_in_transition(
            button,
            /*receive*/
            ctx[15],
            { key: (
              /*images*/
              ctx[2][0].id
            ) }
          );
          button_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      if (button_intro)
        button_intro.invalidate();
      if (local) {
        button_outro = create_out_transition(
          button,
          /*send*/
          ctx[14],
          { key: (
            /*images*/
            ctx[2][0].id
          ) }
        );
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (detaching && button_outro)
        button_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_14(ctx) {
  let button;
  let img;
  let img_src_value;
  let button_intro;
  let button_outro;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      img = claim_element(button_nodes, "IMG", { src: true, alt: true, class: true });
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][1].src))
        attr(img, "src", img_src_value);
      attr(img, "alt", "post-2");
      attr(img, "class", "w-full h-full max-w-full max-h-full object-center object-cover");
      attr(button, "type", "button");
      attr(button, "class", "w-full h-full max-w-full max-h-full relative");
      toggle_class(
        button,
        "cursor-pointer",
        /*handleClick*/
        ctx[3] || /*includeLightBox*/
        ctx[4]
      );
      toggle_class(button, "cursor-default", !/*handleClick*/
      ctx[3] && !/*includeLightBox*/
      ctx[4]);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, img);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_7*/
          ctx[26]
        );
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*images*/
      4 && !src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][1].src)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(
          button,
          "cursor-pointer",
          /*handleClick*/
          ctx[3] || /*includeLightBox*/
          ctx[4]
        );
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(button, "cursor-default", !/*handleClick*/
        ctx[3] && !/*includeLightBox*/
        ctx[4]);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (button_outro)
            button_outro.end(1);
          button_intro = create_in_transition(
            button,
            /*receive*/
            ctx[15],
            { key: (
              /*images*/
              ctx[2][1].id
            ) }
          );
          button_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      if (button_intro)
        button_intro.invalidate();
      if (local) {
        button_outro = create_out_transition(
          button,
          /*send*/
          ctx[14],
          { key: (
            /*images*/
            ctx[2][1].id
          ) }
        );
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (detaching && button_outro)
        button_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_13(ctx) {
  let button;
  let img;
  let img_src_value;
  let button_intro;
  let button_outro;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      img = claim_element(button_nodes, "IMG", { src: true, alt: true, class: true });
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][2].src))
        attr(img, "src", img_src_value);
      attr(img, "alt", "post-3");
      attr(img, "class", "w-full h-full max-w-full max-h-full object-center object-cover");
      attr(button, "type", "button");
      attr(button, "class", "w-full h-full max-w-full max-h-full relative");
      toggle_class(
        button,
        "cursor-pointer",
        /*handleClick*/
        ctx[3] || /*includeLightBox*/
        ctx[4]
      );
      toggle_class(button, "cursor-default", !/*handleClick*/
      ctx[3] && !/*includeLightBox*/
      ctx[4]);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, img);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_8*/
          ctx[27]
        );
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*images*/
      4 && !src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][2].src)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(
          button,
          "cursor-pointer",
          /*handleClick*/
          ctx[3] || /*includeLightBox*/
          ctx[4]
        );
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(button, "cursor-default", !/*handleClick*/
        ctx[3] && !/*includeLightBox*/
        ctx[4]);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (button_outro)
            button_outro.end(1);
          button_intro = create_in_transition(
            button,
            /*receive*/
            ctx[15],
            { key: (
              /*images*/
              ctx[2][2].id
            ) }
          );
          button_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      if (button_intro)
        button_intro.invalidate();
      if (local) {
        button_outro = create_out_transition(
          button,
          /*send*/
          ctx[14],
          { key: (
            /*images*/
            ctx[2][2].id
          ) }
        );
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (detaching && button_outro)
        button_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_11$2(ctx) {
  let button;
  let t2;
  let img;
  let img_src_value;
  let button_intro;
  let button_outro;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*images*/
    ctx[2].length > 4 && create_if_block_12(ctx)
  );
  return {
    c() {
      button = element("button");
      if (if_block)
        if_block.c();
      t2 = space();
      img = element("img");
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      if (if_block)
        if_block.l(button_nodes);
      t2 = claim_space(button_nodes);
      img = claim_element(button_nodes, "IMG", { src: true, alt: true, class: true });
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][3].src))
        attr(img, "src", img_src_value);
      attr(img, "alt", "post-4");
      attr(img, "class", "w-full h-full max-w-full max-h-full object-center object-cover");
      attr(button, "type", "button");
      attr(button, "class", "w-full h-full max-w-full max-h-full relative");
      toggle_class(
        button,
        "cursor-pointer",
        /*handleClick*/
        ctx[3] || /*includeLightBox*/
        ctx[4]
      );
      toggle_class(button, "cursor-default", !/*handleClick*/
      ctx[3] && !/*includeLightBox*/
      ctx[4]);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      if (if_block)
        if_block.m(button, null);
      append_hydration(button, t2);
      append_hydration(button, img);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_9*/
          ctx[28]
        );
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*images*/
        ctx[2].length > 4
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_12(ctx);
          if_block.c();
          if_block.m(button, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (!current || dirty & /*images*/
      4 && !src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][3].src)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(
          button,
          "cursor-pointer",
          /*handleClick*/
          ctx[3] || /*includeLightBox*/
          ctx[4]
        );
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(button, "cursor-default", !/*handleClick*/
        ctx[3] && !/*includeLightBox*/
        ctx[4]);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (button_outro)
            button_outro.end(1);
          button_intro = create_in_transition(
            button,
            /*receive*/
            ctx[15],
            { key: (
              /*images*/
              ctx[2][3].id
            ) }
          );
          button_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      if (button_intro)
        button_intro.invalidate();
      if (local) {
        button_outro = create_out_transition(
          button,
          /*send*/
          ctx[14],
          { key: (
            /*images*/
            ctx[2][3].id
          ) }
        );
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (if_block)
        if_block.d();
      if (detaching && button_outro)
        button_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_12(ctx) {
  let div2;
  let t0_value = (
    /*images*/
    ctx[2].length - 4 + ""
  );
  let t0;
  let t1;
  return {
    c() {
      div2 = element("div");
      t0 = text(t0_value);
      t1 = text("+");
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      t0 = claim_text(div_nodes, t0_value);
      t1 = claim_text(div_nodes, "+");
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "w-full h-full absolute inset-0 pointer-events-none bg-surface backdrop-blur-sm bg-opacity-40 text-content font-semibold text-3xl flex items-center justify-center");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, t0);
      append_hydration(div2, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*images*/
      4 && t0_value !== (t0_value = /*images*/
      ctx2[2].length - 4 + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_if_block_9$3(ctx) {
  let button;
  let img;
  let img_src_value;
  let button_intro;
  let button_outro;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      img = claim_element(button_nodes, "IMG", { src: true, alt: true, class: true });
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][0].src))
        attr(img, "src", img_src_value);
      attr(img, "alt", "post-1");
      attr(img, "class", "w-full h-full object-center object-cover");
      attr(button, "type", "button");
      attr(button, "class", "w-full h-full max-w-full max-h-full relative pr-1");
      toggle_class(
        button,
        "cursor-pointer",
        /*handleClick*/
        ctx[3] || /*includeLightBox*/
        ctx[4]
      );
      toggle_class(button, "cursor-default", !/*handleClick*/
      ctx[3] && !/*includeLightBox*/
      ctx[4]);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, img);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_3*/
          ctx[22]
        );
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*images*/
      4 && !src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][0].src)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(
          button,
          "cursor-pointer",
          /*handleClick*/
          ctx[3] || /*includeLightBox*/
          ctx[4]
        );
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(button, "cursor-default", !/*handleClick*/
        ctx[3] && !/*includeLightBox*/
        ctx[4]);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (button_outro)
            button_outro.end(1);
          button_intro = create_in_transition(
            button,
            /*receive*/
            ctx[15],
            { key: (
              /*images*/
              ctx[2][0].id
            ) }
          );
          button_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      if (button_intro)
        button_intro.invalidate();
      if (local) {
        button_outro = create_out_transition(
          button,
          /*send*/
          ctx[14],
          { key: (
            /*images*/
            ctx[2][0].id
          ) }
        );
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (detaching && button_outro)
        button_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_8$4(ctx) {
  let button;
  let img;
  let img_src_value;
  let button_intro;
  let button_outro;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      img = claim_element(button_nodes, "IMG", { src: true, alt: true, class: true });
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][1].src))
        attr(img, "src", img_src_value);
      attr(img, "alt", "post-2");
      attr(img, "class", "w-full h-full max-w-full max-h-full object-center object-cover");
      attr(button, "type", "button");
      attr(button, "class", "w-full h-full max-w-full max-h-full relative");
      toggle_class(
        button,
        "cursor-pointer",
        /*handleClick*/
        ctx[3] || /*includeLightBox*/
        ctx[4]
      );
      toggle_class(button, "cursor-default", !/*handleClick*/
      ctx[3] && !/*includeLightBox*/
      ctx[4]);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, img);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_4*/
          ctx[23]
        );
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*images*/
      4 && !src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][1].src)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(
          button,
          "cursor-pointer",
          /*handleClick*/
          ctx[3] || /*includeLightBox*/
          ctx[4]
        );
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(button, "cursor-default", !/*handleClick*/
        ctx[3] && !/*includeLightBox*/
        ctx[4]);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (button_outro)
            button_outro.end(1);
          button_intro = create_in_transition(
            button,
            /*receive*/
            ctx[15],
            { key: (
              /*images*/
              ctx[2][1].id
            ) }
          );
          button_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      if (button_intro)
        button_intro.invalidate();
      if (local) {
        button_outro = create_out_transition(
          button,
          /*send*/
          ctx[14],
          { key: (
            /*images*/
            ctx[2][1].id
          ) }
        );
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (detaching && button_outro)
        button_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_7$4(ctx) {
  let button;
  let img;
  let img_src_value;
  let button_intro;
  let button_outro;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      img = claim_element(button_nodes, "IMG", { src: true, alt: true, class: true });
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][2].src))
        attr(img, "src", img_src_value);
      attr(img, "alt", "post-3");
      attr(img, "class", "w-full h-full max-w-full max-h-full object-center object-cover");
      attr(button, "type", "button");
      attr(button, "class", "w-full h-full max-w-full max-h-full relative");
      toggle_class(
        button,
        "cursor-pointer",
        /*handleClick*/
        ctx[3] || /*includeLightBox*/
        ctx[4]
      );
      toggle_class(button, "cursor-default", !/*handleClick*/
      ctx[3] && !/*includeLightBox*/
      ctx[4]);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, img);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_5*/
          ctx[24]
        );
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*images*/
      4 && !src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][2].src)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(
          button,
          "cursor-pointer",
          /*handleClick*/
          ctx[3] || /*includeLightBox*/
          ctx[4]
        );
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(button, "cursor-default", !/*handleClick*/
        ctx[3] && !/*includeLightBox*/
        ctx[4]);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (button_outro)
            button_outro.end(1);
          button_intro = create_in_transition(
            button,
            /*receive*/
            ctx[15],
            { key: (
              /*images*/
              ctx[2][2].id
            ) }
          );
          button_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      if (button_intro)
        button_intro.invalidate();
      if (local) {
        button_outro = create_out_transition(
          button,
          /*send*/
          ctx[14],
          { key: (
            /*images*/
            ctx[2][2].id
          ) }
        );
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (detaching && button_outro)
        button_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_5$6(ctx) {
  let button;
  let img;
  let img_src_value;
  let button_intro;
  let button_outro;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      img = claim_element(button_nodes, "IMG", { src: true, alt: true, class: true });
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][0].src))
        attr(img, "src", img_src_value);
      attr(img, "alt", "post-1");
      attr(img, "class", "w-full h-full max-w-full max-h-full object-center object-cover");
      attr(button, "type", "button");
      attr(button, "class", "w-full h-full max-w-full max-h-full relative");
      toggle_class(
        button,
        "cursor-pointer",
        /*handleClick*/
        ctx[3] || /*includeLightBox*/
        ctx[4]
      );
      toggle_class(button, "cursor-default", !/*handleClick*/
      ctx[3] && !/*includeLightBox*/
      ctx[4]);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, img);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_1*/
          ctx[20]
        );
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*images*/
      4 && !src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][0].src)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(
          button,
          "cursor-pointer",
          /*handleClick*/
          ctx[3] || /*includeLightBox*/
          ctx[4]
        );
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(button, "cursor-default", !/*handleClick*/
        ctx[3] && !/*includeLightBox*/
        ctx[4]);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (button_outro)
            button_outro.end(1);
          button_intro = create_in_transition(
            button,
            /*receive*/
            ctx[15],
            { key: (
              /*images*/
              ctx[2][0].id
            ) }
          );
          button_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      if (button_intro)
        button_intro.invalidate();
      if (local) {
        button_outro = create_out_transition(
          button,
          /*send*/
          ctx[14],
          { key: (
            /*images*/
            ctx[2][0].id
          ) }
        );
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (detaching && button_outro)
        button_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_4$6(ctx) {
  let button;
  let img;
  let img_src_value;
  let button_intro;
  let button_outro;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      img = claim_element(button_nodes, "IMG", { src: true, alt: true, class: true });
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][1].src))
        attr(img, "src", img_src_value);
      attr(img, "alt", "post-1");
      attr(img, "class", "w-full h-full max-w-full max-h-full object-center object-cover");
      attr(button, "type", "button");
      attr(button, "class", "w-full h-full max-w-full max-h-full relative");
      toggle_class(
        button,
        "cursor-pointer",
        /*handleClick*/
        ctx[3] || /*includeLightBox*/
        ctx[4]
      );
      toggle_class(button, "cursor-default", !/*handleClick*/
      ctx[3] && !/*includeLightBox*/
      ctx[4]);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, img);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler_2*/
          ctx[21]
        );
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*images*/
      4 && !src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][1].src)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(
          button,
          "cursor-pointer",
          /*handleClick*/
          ctx[3] || /*includeLightBox*/
          ctx[4]
        );
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(button, "cursor-default", !/*handleClick*/
        ctx[3] && !/*includeLightBox*/
        ctx[4]);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (button_outro)
            button_outro.end(1);
          button_intro = create_in_transition(
            button,
            /*receive*/
            ctx[15],
            { key: (
              /*images*/
              ctx[2][1].id
            ) }
          );
          button_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      if (button_intro)
        button_intro.invalidate();
      if (local) {
        button_outro = create_out_transition(
          button,
          /*send*/
          ctx[14],
          { key: (
            /*images*/
            ctx[2][1].id
          ) }
        );
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (detaching && button_outro)
        button_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$c(ctx) {
  let button;
  let img;
  let img_src_value;
  let button_intro;
  let button_outro;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      img = element("img");
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      img = claim_element(button_nodes, "IMG", { src: true, alt: true, class: true });
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      if (!src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][0].src))
        attr(img, "src", img_src_value);
      attr(img, "alt", "post-1");
      attr(img, "class", "w-full h-full max-w-full max-h-full object-center object-cover");
      attr(button, "type", "button");
      attr(button, "class", "w-full h-full max-h-full max-w-full relative");
      toggle_class(
        button,
        "cursor-pointer",
        /*handleClick*/
        ctx[3] || /*includeLightBox*/
        ctx[4]
      );
      toggle_class(button, "cursor-default", !/*handleClick*/
      ctx[3] && !/*includeLightBox*/
      ctx[4]);
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      append_hydration(button, img);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[19]
        );
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty & /*images*/
      4 && !src_url_equal(img.src, img_src_value = /*images*/
      ctx[2][0].src)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(
          button,
          "cursor-pointer",
          /*handleClick*/
          ctx[3] || /*includeLightBox*/
          ctx[4]
        );
      }
      if (!current || dirty & /*handleClick, includeLightBox*/
      24) {
        toggle_class(button, "cursor-default", !/*handleClick*/
        ctx[3] && !/*includeLightBox*/
        ctx[4]);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (button_outro)
            button_outro.end(1);
          button_intro = create_in_transition(
            button,
            /*receive*/
            ctx[15],
            { key: (
              /*images*/
              ctx[2][0].id
            ) }
          );
          button_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      if (button_intro)
        button_intro.invalidate();
      if (local) {
        button_outro = create_out_transition(
          button,
          /*send*/
          ctx[14],
          { key: (
            /*images*/
            ctx[2][0].id
          ) }
        );
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (detaching && button_outro)
        button_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$t(ctx) {
  let lightbox;
  let updating_activeSlide;
  let current;
  function lightbox_activeSlide_binding(value) {
    ctx[29](value);
  }
  let lightbox_props = {
    handleClose: (
      /*closeLightBox*/
      ctx[16]
    ),
    slides: (
      /*images*/
      ctx[2]
    ),
    showClose: (
      /*showClose*/
      ctx[5]
    ),
    actions: (
      /*lightboxActions*/
      ctx[6]
    )
  };
  if (
    /*activeSlide*/
    ctx[0] !== void 0
  ) {
    lightbox_props.activeSlide = /*activeSlide*/
    ctx[0];
  }
  lightbox = new LightBox({ props: lightbox_props });
  binding_callbacks.push(() => bind(lightbox, "activeSlide", lightbox_activeSlide_binding));
  return {
    c() {
      create_component(lightbox.$$.fragment);
    },
    l(nodes) {
      claim_component(lightbox.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(lightbox, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const lightbox_changes = {};
      if (dirty & /*images*/
      4)
        lightbox_changes.slides = /*images*/
        ctx2[2];
      if (dirty & /*showClose*/
      32)
        lightbox_changes.showClose = /*showClose*/
        ctx2[5];
      if (dirty & /*lightboxActions*/
      64)
        lightbox_changes.actions = /*lightboxActions*/
        ctx2[6];
      if (!updating_activeSlide && dirty & /*activeSlide*/
      1) {
        updating_activeSlide = true;
        lightbox_changes.activeSlide = /*activeSlide*/
        ctx2[0];
        add_flush_callback(() => updating_activeSlide = false);
      }
      lightbox.$set(lightbox_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(lightbox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(lightbox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(lightbox, detaching);
    }
  };
}
function create_fragment$Y(ctx) {
  let div1;
  let div0;
  let useActions_action;
  let t2;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*images*/
      ctx2[2].length === 1
    )
      return create_if_block_1$k;
    if (
      /*images*/
      ctx2[2].length === 2
    )
      return create_if_block_3$b;
    if (
      /*images*/
      ctx2[2].length === 3
    )
      return create_if_block_6$4;
    if (
      /*images*/
      ctx2[2].length > 3
    )
      return create_if_block_10$3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block0 = current_block_type && current_block_type(ctx);
  let div1_levels = [
    { class: (
      /*finalClass*/
      ctx[12]
    ) },
    exclude(
      /*$$props*/
      ctx[18],
      ["use", "class"]
    )
  ];
  let div_data_1 = {};
  for (let i2 = 0; i2 < div1_levels.length; i2 += 1) {
    div_data_1 = assign$1(div_data_1, div1_levels[i2]);
  }
  let if_block1 = (
    /*lightBoxOpen*/
    ctx[7] && /*lightBox1Open*/
    (ctx[8] || /*lightBox2Open*/
    ctx[9] || /*lightBox3Open*/
    ctx[10] || /*lightBox4Open*/
    ctx[11]) && create_if_block$t(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      t2 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
      this.h();
    },
    h() {
      attr(div0, "class", "w-full h-full aspect-[1/1]");
      set_attributes(div1, div_data_1);
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      append_hydration(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      insert_hydration(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div1,
            /*use*/
            ctx[1]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[13].call(null, div1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if (if_block0)
          if_block0.d(1);
        if_block0 = current_block_type && current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        (!current || dirty & /*finalClass*/
        4096) && { class: (
          /*finalClass*/
          ctx2[12]
        ) },
        dirty & /*$$props*/
        262144 && exclude(
          /*$$props*/
          ctx2[18],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[1]
        );
      if (
        /*lightBoxOpen*/
        ctx2[7] && /*lightBox1Open*/
        (ctx2[8] || /*lightBox2Open*/
        ctx2[9] || /*lightBox3Open*/
        ctx2[10] || /*lightBox4Open*/
        ctx2[11])
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*lightBoxOpen, lightBox1Open, lightBox2Open, lightBox3Open, lightBox4Open*/
          3968) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$t(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t2);
        detach(if_block1_anchor);
      }
      if (if_block0) {
        if_block0.d();
      }
      if (if_block1)
        if_block1.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$w = "mt-[-1px] mr-[-1px] ml-[-1px] last:h-[calc(100%+2px)] first:rounded-t-md last:rounded-b-md overflow-hidden";
function instance$W($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { images = [] } = $$props;
  let { handleClick = void 0 } = $$props;
  let { includeLightBox = true } = $$props;
  let { activeSlide = 0 } = $$props;
  let { showClose = true } = $$props;
  let { lightboxActions = [] } = $$props;
  let lightBoxOpen = false;
  let lightBox1Open = false;
  let lightBox2Open = false;
  let lightBox3Open = false;
  let lightBox4Open = false;
  const [send, receive] = crossfade;
  function openLightBox(index2) {
    setTimeout(
      () => {
        if (index2 === 0) {
          $$invalidate(8, lightBox1Open = true);
        } else if (index2 === 1) {
          $$invalidate(9, lightBox2Open = true);
        } else if (index2 === 2) {
          $$invalidate(10, lightBox3Open = true);
        } else if (index2 === 3) {
          $$invalidate(11, lightBox4Open = true);
        }
        $$invalidate(0, activeSlide = index2);
        $$invalidate(7, lightBoxOpen = true);
      },
      100
    );
  }
  function closeLightBox() {
    $$invalidate(7, lightBoxOpen = false);
    $$invalidate(8, lightBox1Open = false);
    $$invalidate(9, lightBox2Open = false);
    $$invalidate(10, lightBox3Open = false);
    $$invalidate(11, lightBox4Open = false);
  }
  function onClick(index2) {
    if (handleClick) {
      handleClick(index2);
    } else if (includeLightBox) {
      openLightBox(index2);
    }
  }
  const click_handler = () => onClick(0);
  const click_handler_1 = () => onClick(0);
  const click_handler_2 = () => onClick(1);
  const click_handler_3 = () => onClick(0);
  const click_handler_4 = () => onClick(1);
  const click_handler_5 = () => onClick(2);
  const click_handler_6 = () => onClick(0);
  const click_handler_7 = () => onClick(1);
  const click_handler_8 = () => onClick(2);
  const click_handler_9 = () => onClick(3);
  function lightbox_activeSlide_binding(value) {
    activeSlide = value;
    $$invalidate(0, activeSlide);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("images" in $$new_props)
      $$invalidate(2, images = $$new_props.images);
    if ("handleClick" in $$new_props)
      $$invalidate(3, handleClick = $$new_props.handleClick);
    if ("includeLightBox" in $$new_props)
      $$invalidate(4, includeLightBox = $$new_props.includeLightBox);
    if ("activeSlide" in $$new_props)
      $$invalidate(0, activeSlide = $$new_props.activeSlide);
    if ("showClose" in $$new_props)
      $$invalidate(5, showClose = $$new_props.showClose);
    if ("lightboxActions" in $$new_props)
      $$invalidate(6, lightboxActions = $$new_props.lightboxActions);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*lightBoxOpen, activeSlide*/
    129) {
      if (lightBoxOpen && activeSlide === 0) {
        $$invalidate(8, lightBox1Open = true);
        $$invalidate(9, lightBox2Open = false);
        $$invalidate(10, lightBox3Open = false);
        $$invalidate(11, lightBox4Open = false);
      } else if (lightBoxOpen && activeSlide === 1) {
        $$invalidate(9, lightBox2Open = true);
        $$invalidate(8, lightBox1Open = false);
        $$invalidate(10, lightBox3Open = false);
        $$invalidate(11, lightBox4Open = false);
      } else if (lightBoxOpen && activeSlide === 2) {
        $$invalidate(10, lightBox3Open = true);
        $$invalidate(8, lightBox1Open = false);
        $$invalidate(9, lightBox2Open = false);
        $$invalidate(11, lightBox4Open = false);
      } else if (lightBoxOpen && activeSlide > 2) {
        $$invalidate(11, lightBox4Open = true);
        $$invalidate(8, lightBox1Open = false);
        $$invalidate(9, lightBox2Open = false);
        $$invalidate(10, lightBox3Open = false);
      }
    }
    $$invalidate(12, finalClass = twMerge(defaultClass$w, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    activeSlide,
    use,
    images,
    handleClick,
    includeLightBox,
    showClose,
    lightboxActions,
    lightBoxOpen,
    lightBox1Open,
    lightBox2Open,
    lightBox3Open,
    lightBox4Open,
    finalClass,
    forwardEvents,
    send,
    receive,
    closeLightBox,
    onClick,
    $$props,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5,
    click_handler_6,
    click_handler_7,
    click_handler_8,
    click_handler_9,
    lightbox_activeSlide_binding
  ];
}
class Images extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$W, create_fragment$Y, safe_not_equal, {
      use: 1,
      images: 2,
      handleClick: 3,
      includeLightBox: 4,
      activeSlide: 0,
      showClose: 5,
      lightboxActions: 6
    });
  }
}
function create_if_block_1$j(ctx) {
  let div2;
  let icon;
  let t0;
  let t1_value = (
    /*likes*/
    ctx[1].length + ""
  );
  let t1;
  let current;
  icon = new Icon$7({ props: { data: thumb_up, size: "14px" } });
  return {
    c() {
      div2 = element("div");
      create_component(icon.$$.fragment);
      t0 = space();
      t1 = text(t1_value);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      claim_component(icon.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      t0 = claim_space(nodes);
      t1 = claim_text(nodes, t1_value);
      this.h();
    },
    h() {
      attr(div2, "class", "mr-1 h-5 w-5 rounded-full bg-primary text-primary-content shadow-md flex items-center justify-center");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(icon, div2, null);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*likes*/
      2) && t1_value !== (t1_value = /*likes*/
      ctx2[1].length + ""))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t0);
        detach(t1);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block$s(ctx) {
  let t0_value = (
    /*comments*/
    ctx[2].length + ""
  );
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" Comments");
    },
    l(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_text(nodes, " Comments");
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*comments*/
      4 && t0_value !== (t0_value = /*comments*/
      ctx2[2].length + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_fragment$X(ctx) {
  let div2;
  let div0;
  let t2;
  let div1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*likes*/
    ctx[1].length > 0 && create_if_block_1$j(ctx)
  );
  let if_block1 = (
    /*comments*/
    ctx[2].length > 0 && create_if_block$s(ctx)
  );
  let div2_levels = [
    { class: (
      /*finalClass*/
      ctx[3]
    ) },
    exclude(
      /*$$props*/
      ctx[5],
      ["use", "class"]
    )
  ];
  let div_data_2 = {};
  for (let i2 = 0; i2 < div2_levels.length; i2 += 1) {
    div_data_2 = assign$1(div_data_2, div2_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      div1 = element("div");
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      div0_nodes.forEach(detach);
      t2 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "h-full w-full flex justify-start items-center text-sm");
      attr(div1, "class", "h-full w-full flex justify-end items-center text-sm");
      set_attributes(div2, div_data_2);
      toggle_class(
        div2,
        "hidden",
        /*likes*/
        ctx[1].length === 0 && /*comments*/
        ctx[2].length === 0
      );
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration(div2, t2);
      append_hydration(div2, div1);
      if (if_block1)
        if_block1.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[4].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*likes*/
        ctx2[1].length > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*likes*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$j(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*comments*/
        ctx2[2].length > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$s(ctx2);
          if_block1.c();
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
        (!current || dirty & /*finalClass*/
        8) && { class: (
          /*finalClass*/
          ctx2[3]
        ) },
        dirty & /*$$props*/
        32 && exclude(
          /*$$props*/
          ctx2[5],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(
        div2,
        "hidden",
        /*likes*/
        ctx2[1].length === 0 && /*comments*/
        ctx2[2].length === 0
      );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$v = "flex flex-row justify-evenly items-center py-1 px-2 border-t border-border";
function instance$V($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { likes = [] } = $$props;
  let { comments = [] } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("likes" in $$new_props)
      $$invalidate(1, likes = $$new_props.likes);
    if ("comments" in $$new_props)
      $$invalidate(2, comments = $$new_props.comments);
  };
  $$self.$$.update = () => {
    $$invalidate(3, finalClass = twMerge(defaultClass$v, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, likes, comments, finalClass, forwardEvents, $$props];
}
class Status2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$V, create_fragment$X, safe_not_equal, { use: 0, likes: 1, comments: 2 });
  }
}
function create_fragment$W(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$u = "flex flex-row h-14 justify-evenly divide-x divide-border  border-t border-border first:rounded-t-md last:rounded-b-md";
function instance$U($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$u, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Actions$1 = class Actions extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$U, create_fragment$W, safe_not_equal, { use: 0 });
  }
};
const get_label_slot_changes$4 = (dirty) => ({});
const get_label_slot_context$4 = (ctx) => ({});
const get_icon_slot_changes$3 = (dirty) => ({});
const get_icon_slot_context$3 = (ctx) => ({});
function create_if_block_1$i(ctx) {
  let span;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[6].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_icon_slot_context$3
  );
  return {
    c() {
      span = element("span");
      if (icon_slot)
        icon_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (icon_slot)
        icon_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "h-4 w-4");
      toggle_class(
        span,
        "mb-1.5",
        /*$$slots*/
        ctx[4].label
      );
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (icon_slot) {
        icon_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_icon_slot_changes$3
            ),
            get_icon_slot_context$3
          );
        }
      }
      if (!current || dirty & /*$$slots*/
      16) {
        toggle_class(
          span,
          "mb-1.5",
          /*$$slots*/
          ctx2[4].label
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_if_block$r(ctx) {
  let span;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[6].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_label_slot_context$4
  );
  return {
    c() {
      span = element("span");
      if (label_slot)
        label_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (label_slot)
        label_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "text-xs");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (label_slot) {
        label_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_label_slot_changes$4
            ),
            get_label_slot_context$4
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (label_slot)
        label_slot.d(detaching);
    }
  };
}
function create_fragment$V(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let t2;
  let hoverbackground;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[4].icon && create_if_block_1$i(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    ctx[4].label && create_if_block$r(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  hoverbackground = new HoverBackground({});
  let div1_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data_1 = {};
  for (let i2 = 0; i2 < div1_levels.length; i2 += 1) {
    div_data_1 = assign$1(div_data_1, div1_levels[i2]);
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      create_component(hoverbackground.$$.fragment);
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      if (if_block1)
        if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach);
      t2 = claim_space(div1_nodes);
      claim_component(hoverbackground.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div0, "class", "group text-sm text-content group-hover:text-primary relative flex flex-col items-center justify-center h-full w-full active:hover:animate-none active:hover:scale-90");
      set_attributes(div1, div_data_1);
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      append_hydration(div1, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration(div0, t0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration(div0, t1);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      append_hydration(div1, t2);
      mount_component(hoverbackground, div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div1,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div1)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[4].icon
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$i(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[4].label
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$r(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      transition_in(hoverbackground.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      transition_out(hoverbackground.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(hoverbackground);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$t = "group relative w-full h-full cursor-pointer first:rounded-bl-md last:rounded-br-md overflow-hidden";
function instance$T($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$t, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$slots, $$scope, slots];
}
class Action4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$T, create_fragment$V, safe_not_equal, { use: 0 });
  }
}
const Placeholder_svelte_svelte_type_style_lang = "";
const get_icon_slot_changes$2 = (dirty) => ({});
const get_icon_slot_context$2 = (ctx) => ({});
function create_if_block_1$h(ctx) {
  let span;
  let icon;
  let current;
  icon = new Icon$7({ props: { data: account, size: "40px" } });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", null_to_empty(iconContainerClass) + " svelte-13m79ia");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block$q(ctx) {
  let t2;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[8].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    get_icon_slot_context$2
  );
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  return {
    c() {
      if (icon_slot)
        icon_slot.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
    },
    l(nodes) {
      if (icon_slot)
        icon_slot.l(nodes);
      t2 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m(target, anchor) {
      if (icon_slot) {
        icon_slot.m(target, anchor);
      }
      insert_hydration(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              get_icon_slot_changes$2
            ),
            get_icon_slot_context$2
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (icon_slot)
        icon_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$U(ctx) {
  let div2;
  let current_block_type_index;
  let if_block;
  let useActions_action;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$q, create_if_block_1$h];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[5].icon || /*$$slots*/
      ctx2[5].default
    )
      return 0;
    if (
      /*placeholder*/
      ctx2[3]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
      toggle_class(div2, "svelte-13m79ia", true);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div2, null);
        } else {
          if_block = null;
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(div2, "svelte-13m79ia", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, fade, {}, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, fade, {}, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
const iconContainerClass = "absolute text-content h-full w-full bottom-[-0.5rem]";
const defaultClass$s = "absolute inset-0 h-full w-full flex items-center justify-center overflow-hidden bg-default";
const circleClass = "rounded-full";
const roundedClass = "rounded-md";
function instance$S($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { loading = false } = $$props;
  const shape = getContext("post-avatar-shape");
  const placeholder = getContext("post-avatar-placeholder");
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("loading" in $$new_props)
      $$invalidate(6, loading = $$new_props.loading);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$s, shape === "circle" ? circleClass : false, shape === "rounded" ? roundedClass : false, loading ? "loading" : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    finalClass,
    forwardEvents,
    placeholder,
    $$props,
    $$slots,
    loading,
    $$scope,
    slots
  ];
}
class Placeholder7 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$S, create_fragment$U, safe_not_equal, { use: 0, loading: 6 });
  }
}
const get_indicator_slot_changes = (dirty) => ({});
const get_indicator_slot_context = (ctx) => ({});
const get_placeholder_slot_changes = (dirty) => ({});
const get_placeholder_slot_context = (ctx) => ({});
function create_if_block_3$a(ctx) {
  let placeholder_1;
  let current;
  placeholder_1 = new Placeholder7({ props: { loading: true } });
  return {
    c() {
      create_component(placeholder_1.$$.fragment);
    },
    l(nodes) {
      claim_component(placeholder_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(placeholder_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(placeholder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(placeholder_1, detaching);
    }
  };
}
function create_if_block_1$g(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2$b, create_else_block$b];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[10].placeholder
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block$p(ctx) {
  let img;
  let img_style_value;
  let img_src_value;
  return {
    c() {
      img = element("img");
      this.h();
    },
    l(nodes) {
      img = claim_element(nodes, "IMG", {
        class: true,
        style: true,
        src: true,
        alt: true
      });
      this.h();
    },
    h() {
      attr(
        img,
        "class",
        /*finalClass*/
        ctx[7]
      );
      attr(img, "style", img_style_value = /*$$props*/
      ctx[9].style);
      if (!src_url_equal(img.src, img_src_value = /*src*/
      ctx[1] || ""))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*alt*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*finalClass*/
      128) {
        attr(
          img,
          "class",
          /*finalClass*/
          ctx2[7]
        );
      }
      if (dirty & /*$$props*/
      512 && img_style_value !== (img_style_value = /*$$props*/
      ctx2[9].style)) {
        attr(img, "style", img_style_value);
      }
      if (dirty & /*src*/
      2 && !src_url_equal(img.src, img_src_value = /*src*/
      ctx2[1] || "")) {
        attr(img, "src", img_src_value);
      }
      if (dirty & /*alt*/
      4) {
        attr(
          img,
          "alt",
          /*alt*/
          ctx2[2]
        );
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_else_block$b(ctx) {
  let placeholder_1;
  let current;
  placeholder_1 = new Placeholder7({});
  return {
    c() {
      create_component(placeholder_1.$$.fragment);
    },
    l(nodes) {
      claim_component(placeholder_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(placeholder_1, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(placeholder_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(placeholder_1, detaching);
    }
  };
}
function create_if_block_2$b(ctx) {
  let current;
  const placeholder_slot_template = (
    /*#slots*/
    ctx[14].placeholder
  );
  const placeholder_slot = create_slot(
    placeholder_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_placeholder_slot_context
  );
  return {
    c() {
      if (placeholder_slot)
        placeholder_slot.c();
    },
    l(nodes) {
      if (placeholder_slot)
        placeholder_slot.l(nodes);
    },
    m(target, anchor) {
      if (placeholder_slot) {
        placeholder_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (placeholder_slot) {
        if (placeholder_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            placeholder_slot,
            placeholder_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              placeholder_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_placeholder_slot_changes
            ),
            get_placeholder_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(placeholder_slot, local);
      current = true;
    },
    o(local) {
      transition_out(placeholder_slot, local);
      current = false;
    },
    d(detaching) {
      if (placeholder_slot)
        placeholder_slot.d(detaching);
    }
  };
}
function create_fragment$T(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$p, create_if_block_1$g, create_if_block_3$a];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*loaded*/
      ctx2[3]
    )
      return 0;
    if (
      /*failed*/
      ctx2[4]
    )
      return 1;
    if (
      /*loading*/
      ctx2[5]
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const indicator_slot_template = (
    /*#slots*/
    ctx[14].indicator
  );
  const indicator_slot = create_slot(
    indicator_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    get_indicator_slot_context
  );
  let span_levels = [
    { class: (
      /*finalContainerClass*/
      ctx[6]
    ) },
    exclude(
      /*$$props*/
      ctx[9],
      ["use", "class", "src"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (if_block)
        if_block.c();
      t2 = space();
      if (indicator_slot)
        indicator_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (if_block)
        if_block.l(span_nodes);
      t2 = claim_space(span_nodes);
      if (indicator_slot)
        indicator_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(span, null);
      }
      append_hydration(span, t2);
      if (indicator_slot) {
        indicator_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[8].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(span, t2);
        } else {
          if_block = null;
        }
      }
      if (indicator_slot) {
        if (indicator_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            indicator_slot,
            indicator_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              indicator_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              get_indicator_slot_changes
            ),
            get_indicator_slot_context
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalContainerClass*/
        64) && { class: (
          /*finalContainerClass*/
          ctx2[6]
        ) },
        dirty & /*$$props*/
        512 && exclude(
          /*$$props*/
          ctx2[9],
          ["use", "class", "src"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(indicator_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(indicator_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (indicator_slot)
        indicator_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$r = "inline-block absolute h-10 w-10";
const containerDefaultClass = "inline-block relative align-middle h-10 w-10";
function instance$R($$self, $$props, $$invalidate) {
  let finalClass;
  let finalContainerClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { src = void 0 } = $$props;
  let { alt = "avatar" } = $$props;
  let { shape = "circle" } = $$props;
  let { placeholder = true } = $$props;
  let loaded = false;
  let failed = false;
  let loading = true;
  setContext("post-avatar-shape", shape);
  setContext("post-avatar-placeholder", placeholder);
  onMount(() => {
    if (src) {
      const image = new Image();
      image.src = src;
      $$invalidate(5, loading = true);
      image.onload = () => {
        $$invalidate(5, loading = false);
        $$invalidate(3, loaded = true);
      };
      image.onerror = () => {
        $$invalidate(5, loading = false);
        $$invalidate(4, failed = true);
      };
    }
  });
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("src" in $$new_props)
      $$invalidate(1, src = $$new_props.src);
    if ("alt" in $$new_props)
      $$invalidate(2, alt = $$new_props.alt);
    if ("shape" in $$new_props)
      $$invalidate(11, shape = $$new_props.shape);
    if ("placeholder" in $$new_props)
      $$invalidate(12, placeholder = $$new_props.placeholder);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(7, finalClass = twMerge(src ? defaultClass$r : false, shape === "circle" ? "rounded-full" : false, shape === "rounded" ? "rounded-md" : false, $$props.class));
    $$invalidate(6, finalContainerClass = twMerge(src ? containerDefaultClass : false, shape === "circle" ? "rounded-full" : false, shape === "rounded" ? "rounded-md" : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    src,
    alt,
    loaded,
    failed,
    loading,
    finalContainerClass,
    finalClass,
    forwardEvents,
    $$props,
    $$slots,
    shape,
    placeholder,
    $$scope,
    slots
  ];
}
class Avatar7 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$R, create_fragment$T, safe_not_equal, {
      use: 0,
      src: 1,
      alt: 2,
      shape: 11,
      placeholder: 12
    });
  }
}
function create_fragment$S(ctx) {
  let svg;
  let useActions_action;
  let mounted;
  let dispose;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: (
      /*width*/
      ctx[2]
    ) },
    { height: (
      /*height*/
      ctx[3]
    ) },
    { viewBox: (
      /*viewBox*/
      ctx[1]
    ) },
    { stroke: (
      /*stroke*/
      ctx[5]
    ) },
    { fill: (
      /*fill*/
      ctx[6]
    ) },
    { color: (
      /*color*/
      ctx[4]
    ) },
    exclude(
      /*$$props*/
      ctx[9],
      [
        "use",
        "fill",
        "viewBox",
        "width",
        "height",
        "stroke",
        "size",
        "color",
        "data"
      ]
    )
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        stroke: true,
        fill: true,
        color: true
      });
      var svg_nodes = children(svg);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      svg.innerHTML = /*elements*/
      ctx[7];
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svg,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[8].call(null, svg)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*elements*/
      128)
        svg.innerHTML = /*elements*/
        ctx2[7];
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty & /*width*/
        4 && { width: (
          /*width*/
          ctx2[2]
        ) },
        dirty & /*height*/
        8 && { height: (
          /*height*/
          ctx2[3]
        ) },
        dirty & /*viewBox*/
        2 && { viewBox: (
          /*viewBox*/
          ctx2[1]
        ) },
        dirty & /*stroke*/
        32 && { stroke: (
          /*stroke*/
          ctx2[5]
        ) },
        dirty & /*fill*/
        64 && { fill: (
          /*fill*/
          ctx2[6]
        ) },
        dirty & /*color*/
        16 && { color: (
          /*color*/
          ctx2[4]
        ) },
        dirty & /*$$props*/
        512 && exclude(
          /*$$props*/
          ctx2[9],
          [
            "use",
            "fill",
            "viewBox",
            "width",
            "height",
            "stroke",
            "size",
            "color",
            "data"
          ]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function extractViewBox$2(svg) {
  const regex = /viewBox="([\d\- ]+)"/;
  const res = regex.exec(svg);
  if (!res)
    return "0 0 24 24";
  return res[1];
}
function instance$Q($$self, $$props, $$invalidate) {
  let elements2;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { data = "" } = $$props;
  let { viewBox = extractViewBox$2(data) } = $$props;
  let { size = "20px" } = $$props;
  let { width: width2 = size } = $$props;
  let { height = size } = $$props;
  let { color: color2 = "currentColor" } = $$props;
  let { stroke = void 0 } = $$props;
  let { fill: fill2 = color2 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("data" in $$new_props)
      $$invalidate(10, data = $$new_props.data);
    if ("viewBox" in $$new_props)
      $$invalidate(1, viewBox = $$new_props.viewBox);
    if ("size" in $$new_props)
      $$invalidate(11, size = $$new_props.size);
    if ("width" in $$new_props)
      $$invalidate(2, width2 = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(3, height = $$new_props.height);
    if ("color" in $$new_props)
      $$invalidate(4, color2 = $$new_props.color);
    if ("stroke" in $$new_props)
      $$invalidate(5, stroke = $$new_props.stroke);
    if ("fill" in $$new_props)
      $$invalidate(6, fill2 = $$new_props.fill);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data*/
    1024) {
      $$invalidate(7, elements2 = data.replace(/<svg ([^>]*)>/, "").replace("</svg>", ""));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    viewBox,
    width2,
    height,
    color2,
    stroke,
    fill2,
    elements2,
    forwardEvents,
    $$props,
    data,
    size
  ];
}
let Icon$1 = class Icon6 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$Q, create_fragment$S, safe_not_equal, {
      use: 0,
      data: 10,
      viewBox: 1,
      size: 11,
      width: 2,
      height: 3,
      color: 4,
      stroke: 5,
      fill: 6
    });
  }
};
function create_fragment$R(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$q = "text-xs";
function instance$P($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$q, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Label$3 = class Label9 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$P, create_fragment$R, safe_not_equal, { use: 0 });
  }
};
const Post2 = Post$1;
Post2.Header = Header$1;
Post2.Header.Avatar = Avatar7;
Post2.Header.Creator = Creator;
Post2.Header.Created = Created;
Post2.Content = Content6;
Post2.Images = Images;
Post2.Status = Status2;
Post2.Actions = Actions$1;
Post2.Actions.Action = Action4;
Post2.Actions.Action.Icon = Icon$1;
Post2.Actions.Action.Label = Label$3;
const get_label_slot_changes$3 = (dirty) => ({});
const get_label_slot_context$3 = (ctx) => ({});
function create_if_block$o(ctx) {
  let p;
  let t2;
  let p_id_value;
  let p_transition;
  let current;
  return {
    c() {
      p = element("p");
      t2 = text(
        /*error*/
        ctx[1]
      );
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true, id: true });
      var p_nodes = children(p);
      t2 = claim_text(
        p_nodes,
        /*error*/
        ctx[1]
      );
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(p, "class", "!mt-2 text-sm text-danger");
      attr(p, "id", p_id_value = /*name*/
      ctx[0] + "-error");
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      append_hydration(p, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*error*/
      2)
        set_data(
          t2,
          /*error*/
          ctx2[1]
        );
      if (!current || dirty & /*name*/
      1 && p_id_value !== (p_id_value = /*name*/
      ctx2[0] + "-error")) {
        attr(p, "id", p_id_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!p_transition)
            p_transition = create_bidirectional_transition(p, slide, {}, true);
          p_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!p_transition)
          p_transition = create_bidirectional_transition(p, slide, {}, false);
        p_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (detaching && p_transition)
        p_transition.end();
    }
  };
}
function create_fragment$Q(ctx) {
  let div2;
  let t0;
  let button;
  let ul;
  let ul_style_value;
  let t1;
  let current;
  let mounted;
  let dispose;
  const label_slot_template = (
    /*#slots*/
    ctx[11].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_label_slot_context$3
  );
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  let if_block = (
    /*error*/
    ctx[1] && create_if_block$o(ctx)
  );
  return {
    c() {
      div2 = element("div");
      if (label_slot)
        label_slot.c();
      t0 = space();
      button = element("button");
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div_nodes = children(div2);
      if (label_slot)
        label_slot.l(div_nodes);
      t0 = claim_space(div_nodes);
      button = claim_element(div_nodes, "BUTTON", { tabindex: true, class: true, type: true });
      var button_nodes = children(button);
      ul = claim_element(button_nodes, "UL", { class: true, style: true, tabindex: true });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach);
      button_nodes.forEach(detach);
      t1 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(
        ul,
        "class",
        /*finalClass*/
        ctx[3]
      );
      attr(ul, "style", ul_style_value = /*$$props*/
      ctx[6].style);
      attr(ul, "tabindex", "-1");
      attr(button, "tabindex", "-1");
      attr(button, "class", "text-left");
      attr(button, "type", "button");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (label_slot) {
        label_slot.m(div2, null);
      }
      append_hydration(div2, t0);
      append_hydration(div2, button);
      append_hydration(button, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[12](ul);
      append_hydration(div2, t1);
      if (if_block)
        if_block.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "keydown",
          /*handleKeydown*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_label_slot_changes$3
            ),
            get_label_slot_context$3
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*finalClass*/
      8) {
        attr(
          ul,
          "class",
          /*finalClass*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*$$props*/
      64 && ul_style_value !== (ul_style_value = /*$$props*/
      ctx2[6].style)) {
        attr(ul, "style", ul_style_value);
      }
      if (
        /*error*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*error*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$o(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(default_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      transition_out(default_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (label_slot)
        label_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      ctx[12](null);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
const defaultClass$p = "mt-1 grid-cols-4 gap-2";
const defaultType = "space-y-4";
const pillType = "grid";
function instance$O($$self, $$props, $$invalidate) {
  let finalClass;
  let $selectedRadio;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { name } = $$props;
  let { type = "default" } = $$props;
  let { selected = void 0 } = $$props;
  let { error: error2 = void 0 } = $$props;
  let selectedRadio = writable(selected);
  component_subscribe($$self, selectedRadio, (value) => $$invalidate(9, $selectedRadio = value));
  let list;
  let items = [];
  let focusIndex = 0;
  function handleKeydown(e2) {
    if (e2.key === "Spacebar") {
      e2.preventDefault();
      e2.stopPropagation();
    } else if (e2.key === "ArrowUp") {
      e2.preventDefault();
      e2.stopPropagation();
      focusIndex = focusIndex > 0 ? focusIndex - 1 : items.length - 1;
      if (items.length > 0) {
        const target = items[focusIndex];
        if (target) {
          const input = target.querySelector("input");
          if (input)
            input == null ? void 0 : input.focus();
        }
      }
    } else if (e2.key === "ArrowDown") {
      e2.preventDefault();
      e2.stopPropagation();
      focusIndex = focusIndex < items.length - 1 ? focusIndex + 1 : 0;
      if (items.length > 0) {
        const target = items[focusIndex];
        if (target) {
          const input = target.querySelector("input");
          if (input)
            input == null ? void 0 : input.focus();
        }
      }
    }
  }
  setContext("radio-name", name);
  setContext("radio-type", type);
  setContext("radio-selected", selectedRadio);
  onMount(() => {
    items = list.querySelectorAll("li");
  });
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      list = $$value;
      $$invalidate(2, list);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("name" in $$new_props)
      $$invalidate(0, name = $$new_props.name);
    if ("type" in $$new_props)
      $$invalidate(8, type = $$new_props.type);
    if ("selected" in $$new_props)
      $$invalidate(7, selected = $$new_props.selected);
    if ("error" in $$new_props)
      $$invalidate(1, error2 = $$new_props.error);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$selectedRadio*/
    512) {
      $$invalidate(7, selected = $selectedRadio);
    }
    $$invalidate(3, finalClass = twMerge(defaultClass$p, type === "default" ? defaultType : false, type === "pill" ? pillType : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    name,
    error2,
    list,
    finalClass,
    selectedRadio,
    handleKeydown,
    $$props,
    selected,
    type,
    $selectedRadio,
    $$scope,
    slots,
    ul_binding
  ];
}
let RadioGroup$1 = class RadioGroup extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$O, create_fragment$Q, safe_not_equal, { name: 0, type: 8, selected: 7, error: 1 });
  }
};
function create_fragment$P(ctx) {
  let legend;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let legend_levels = [
    { for: (
      /*name*/
      ctx[3]
    ) },
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class", "for"]
    )
  ];
  let legend_data = {};
  for (let i2 = 0; i2 < legend_levels.length; i2 += 1) {
    legend_data = assign$1(legend_data, legend_levels[i2]);
  }
  return {
    c() {
      legend = element("legend");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      legend = claim_element(nodes, "LEGEND", { for: true, class: true });
      var legend_nodes = children(legend);
      if (default_slot)
        default_slot.l(legend_nodes);
      legend_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(legend, legend_data);
    },
    m(target, anchor) {
      insert_hydration(target, legend, anchor);
      if (default_slot) {
        default_slot.m(legend, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            legend,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, legend)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(legend, legend_data = get_spread_update(legend_levels, [
        { for: (
          /*name*/
          ctx2[3]
        ) },
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class", "for"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(legend);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$o = "text-secondary-content font-medium text-sm";
function instance$N($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const name = getContext("radio-name");
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$o, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, name, $$props, $$scope, slots];
}
class GroupLabel2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$N, create_fragment$P, safe_not_equal, { use: 0 });
  }
}
const get_description_slot_changes$1 = (dirty) => ({});
const get_description_slot_context$1 = (ctx) => ({});
const get_label_slot_changes$2 = (dirty) => ({});
const get_label_slot_context$2 = (ctx) => ({});
function create_if_block_3$9(ctx) {
  let li;
  let button;
  let input;
  let value_has_changed = false;
  let t0;
  let span;
  let span_id_value;
  let t1;
  let hoverbackground;
  let current;
  let binding_group;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  hoverbackground = new HoverBackground({});
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[14][0]
  );
  return {
    c() {
      li = element("li");
      button = element("button");
      input = element("input");
      t0 = space();
      span = element("span");
      if (default_slot)
        default_slot.c();
      t1 = space();
      create_component(hoverbackground.$$.fragment);
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { tabindex: true, class: true });
      var li_nodes = children(li);
      button = claim_element(li_nodes, "BUTTON", { type: true, tabindex: true });
      var button_nodes = children(button);
      input = claim_element(button_nodes, "INPUT", {
        type: true,
        id: true,
        name: true,
        class: true
      });
      t0 = claim_space(button_nodes);
      span = claim_element(button_nodes, "SPAN", { tabindex: true, id: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      t1 = claim_space(button_nodes);
      claim_component(hoverbackground.$$.fragment, button_nodes);
      button_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(input, "type", "radio");
      attr(
        input,
        "id",
        /*id*/
        ctx[0]
      );
      attr(
        input,
        "name",
        /*name*/
        ctx[5]
      );
      input.__value = /*value*/
      ctx[1];
      set_input_value(input, input.__value);
      attr(input, "class", "sr-only");
      attr(span, "tabindex", "-1");
      attr(span, "id", span_id_value = /*id*/
      ctx[0] ? `${/*id*/
      ctx[0]}-label` : void 0);
      attr(button, "type", "button");
      attr(button, "tabindex", "-1");
      attr(li, "tabindex", "-1");
      attr(
        li,
        "class",
        /*finalClass*/
        ctx[3]
      );
      toggle_class(
        li,
        "bg-default",
        /*$selected*/
        ctx[4] !== /*value*/
        ctx[1]
      );
      toggle_class(
        li,
        "text-default-content",
        /*$selected*/
        ctx[4] !== /*value*/
        ctx[1]
      );
      toggle_class(
        li,
        "bg-primary",
        /*$selected*/
        ctx[4] === /*value*/
        ctx[1]
      );
      toggle_class(
        li,
        "text-primary-content",
        /*$selected*/
        ctx[4] === /*value*/
        ctx[1]
      );
      binding_group.p(input);
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, button);
      append_hydration(button, input);
      input.checked = input.__value === /*$selected*/
      ctx[4];
      append_hydration(button, t0);
      append_hydration(button, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      append_hydration(button, t1);
      mount_component(hoverbackground, button, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "click",
            /*click_handler*/
            ctx[12]
          ),
          listen(
            input,
            "change",
            /*input_change_handler_1*/
            ctx[15]
          ),
          listen(
            button,
            "click",
            /*handleClick*/
            ctx[8]
          ),
          listen(
            button,
            "keydown",
            /*handleClick*/
            ctx[8]
          ),
          listen(
            button,
            "keypress",
            /*handleClick*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*id*/
      1) {
        attr(
          input,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*value*/
      2) {
        input.__value = /*value*/
        ctx2[1];
        set_input_value(input, input.__value);
        value_has_changed = true;
      }
      if (value_has_changed || dirty & /*$selected*/
      16) {
        input.checked = input.__value === /*$selected*/
        ctx2[4];
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*id*/
      1 && span_id_value !== (span_id_value = /*id*/
      ctx2[0] ? `${/*id*/
      ctx2[0]}-label` : void 0)) {
        attr(span, "id", span_id_value);
      }
      if (!current || dirty & /*finalClass*/
      8) {
        attr(
          li,
          "class",
          /*finalClass*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*finalClass, $selected, value*/
      26) {
        toggle_class(
          li,
          "bg-default",
          /*$selected*/
          ctx2[4] !== /*value*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*finalClass, $selected, value*/
      26) {
        toggle_class(
          li,
          "text-default-content",
          /*$selected*/
          ctx2[4] !== /*value*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*finalClass, $selected, value*/
      26) {
        toggle_class(
          li,
          "bg-primary",
          /*$selected*/
          ctx2[4] === /*value*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*finalClass, $selected, value*/
      26) {
        toggle_class(
          li,
          "text-primary-content",
          /*$selected*/
          ctx2[4] === /*value*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(hoverbackground.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      transition_out(hoverbackground.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(hoverbackground);
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$n(ctx) {
  let li;
  let div1;
  let input;
  let value_has_changed = false;
  let t0;
  let div0;
  let t1;
  let current;
  let binding_group;
  let mounted;
  let dispose;
  let if_block = (
    /*$$slots*/
    (ctx[9].label || /*$$slots*/
    ctx[9].description) && create_if_block_1$f(ctx)
  );
  binding_group = init_binding_group(
    /*$$binding_groups*/
    ctx[14][0]
  );
  return {
    c() {
      li = element("li");
      div1 = element("div");
      input = element("input");
      t0 = space();
      div0 = element("div");
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { tabindex: true, class: true });
      var li_nodes = children(li);
      div1 = claim_element(li_nodes, "DIV", { tabindex: true, class: true });
      var div1_nodes = children(div1);
      input = claim_element(div1_nodes, "INPUT", {
        id: true,
        name: true,
        type: true,
        class: true
      });
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { tabindex: true, class: true });
      children(div0).forEach(detach);
      div1_nodes.forEach(detach);
      t1 = claim_space(li_nodes);
      if (if_block)
        if_block.l(li_nodes);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(
        input,
        "id",
        /*id*/
        ctx[0]
      );
      attr(
        input,
        "name",
        /*name*/
        ctx[5]
      );
      attr(input, "type", "radio");
      input.__value = /*value*/
      ctx[1];
      set_input_value(input, input.__value);
      input.disabled = /*disabled*/
      ctx[2];
      attr(
        input,
        "class",
        /*finalClass*/
        ctx[3]
      );
      toggle_class(
        input,
        "checked:border-default",
        /*disabled*/
        ctx[2]
      );
      toggle_class(
        input,
        "group-hover:border-default",
        /*disabled*/
        ctx[2]
      );
      toggle_class(
        input,
        "cursor-default",
        /*disabled*/
        ctx[2]
      );
      toggle_class(input, "cursor-pointer", !/*disabled*/
      ctx[2]);
      attr(div0, "tabindex", "-1");
      attr(div0, "class", "absolute rounded-full transition-size duration-200 z-10");
      toggle_class(
        div0,
        "h-0",
        /*$selected*/
        ctx[4] !== /*value*/
        ctx[1]
      );
      toggle_class(
        div0,
        "w-0",
        /*$selected*/
        ctx[4] !== /*value*/
        ctx[1]
      );
      toggle_class(
        div0,
        "h-4",
        /*$selected*/
        ctx[4] === /*value*/
        ctx[1]
      );
      toggle_class(
        div0,
        "w-4",
        /*$selected*/
        ctx[4] === /*value*/
        ctx[1]
      );
      toggle_class(div0, "bg-primary", !/*disabled*/
      ctx[2] && /*$selected*/
      ctx[4] === /*value*/
      ctx[1]);
      toggle_class(
        div0,
        "bg-default",
        /*disabled*/
        ctx[2] && /*$selected*/
        ctx[4] === /*value*/
        ctx[1]
      );
      attr(div1, "tabindex", "-1");
      attr(div1, "class", "flex items-center justify-center h-6 w-6 relative group");
      attr(li, "tabindex", "-1");
      attr(li, "class", "group relative flex items-start");
      toggle_class(
        li,
        "opacity-75",
        /*disabled*/
        ctx[2]
      );
      binding_group.p(input);
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, div1);
      append_hydration(div1, input);
      input.checked = input.__value === /*$selected*/
      ctx[4];
      append_hydration(div1, t0);
      append_hydration(div1, div0);
      append_hydration(li, t1);
      if (if_block)
        if_block.m(li, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "click",
            /*handleClick*/
            ctx[8]
          ),
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*id*/
      1) {
        attr(
          input,
          "id",
          /*id*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*value*/
      2) {
        input.__value = /*value*/
        ctx2[1];
        set_input_value(input, input.__value);
        value_has_changed = true;
      }
      if (!current || dirty & /*disabled*/
      4) {
        input.disabled = /*disabled*/
        ctx2[2];
      }
      if (!current || dirty & /*finalClass*/
      8) {
        attr(
          input,
          "class",
          /*finalClass*/
          ctx2[3]
        );
      }
      if (value_has_changed || dirty & /*$selected*/
      16) {
        input.checked = input.__value === /*$selected*/
        ctx2[4];
      }
      if (!current || dirty & /*finalClass, disabled*/
      12) {
        toggle_class(
          input,
          "checked:border-default",
          /*disabled*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*finalClass, disabled*/
      12) {
        toggle_class(
          input,
          "group-hover:border-default",
          /*disabled*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*finalClass, disabled*/
      12) {
        toggle_class(
          input,
          "cursor-default",
          /*disabled*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*finalClass, disabled*/
      12) {
        toggle_class(input, "cursor-pointer", !/*disabled*/
        ctx2[2]);
      }
      if (!current || dirty & /*$selected, value*/
      18) {
        toggle_class(
          div0,
          "h-0",
          /*$selected*/
          ctx2[4] !== /*value*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*$selected, value*/
      18) {
        toggle_class(
          div0,
          "w-0",
          /*$selected*/
          ctx2[4] !== /*value*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*$selected, value*/
      18) {
        toggle_class(
          div0,
          "h-4",
          /*$selected*/
          ctx2[4] === /*value*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*$selected, value*/
      18) {
        toggle_class(
          div0,
          "w-4",
          /*$selected*/
          ctx2[4] === /*value*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*disabled, $selected, value*/
      22) {
        toggle_class(div0, "bg-primary", !/*disabled*/
        ctx2[2] && /*$selected*/
        ctx2[4] === /*value*/
        ctx2[1]);
      }
      if (!current || dirty & /*disabled, $selected, value*/
      22) {
        toggle_class(
          div0,
          "bg-default",
          /*disabled*/
          ctx2[2] && /*$selected*/
          ctx2[4] === /*value*/
          ctx2[1]
        );
      }
      if (
        /*$$slots*/
        ctx2[9].label || /*$$slots*/
        ctx2[9].description
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$f(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(li, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*disabled*/
      4) {
        toggle_class(
          li,
          "opacity-75",
          /*disabled*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (if_block)
        if_block.d();
      binding_group.r();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$f(ctx) {
  let button;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  const label_slot_template = (
    /*#slots*/
    ctx[11].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_label_slot_context$2
  );
  let if_block = (
    /*$$slots*/
    ctx[9].label && /*$$slots*/
    ctx[9].description && create_if_block_2$a()
  );
  const description_slot_template = (
    /*#slots*/
    ctx[11].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    get_description_slot_context$1
  );
  return {
    c() {
      button = element("button");
      if (label_slot)
        label_slot.c();
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      if (description_slot)
        description_slot.c();
      this.h();
    },
    l(nodes) {
      button = claim_element(nodes, "BUTTON", { tabindex: true, class: true });
      var button_nodes = children(button);
      if (label_slot)
        label_slot.l(button_nodes);
      t0 = claim_space(button_nodes);
      if (if_block)
        if_block.l(button_nodes);
      t1 = claim_space(button_nodes);
      if (description_slot)
        description_slot.l(button_nodes);
      button_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(button, "tabindex", "-1");
      attr(button, "class", "ml-3 text-sm cursor-pointer");
    },
    m(target, anchor) {
      insert_hydration(target, button, anchor);
      if (label_slot) {
        label_slot.m(button, null);
      }
      append_hydration(button, t0);
      if (if_block)
        if_block.m(button, null);
      append_hydration(button, t1);
      if (description_slot) {
        description_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handleClick*/
          ctx[8]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_label_slot_changes$2
            ),
            get_label_slot_context$2
          );
        }
      }
      if (
        /*$$slots*/
        ctx2[9].label && /*$$slots*/
        ctx2[9].description
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_2$a();
          if_block.c();
          if_block.m(button, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              get_description_slot_changes$1
            ),
            get_description_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(description_slot, local);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      transition_out(description_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (label_slot)
        label_slot.d(detaching);
      if (if_block)
        if_block.d();
      if (description_slot)
        description_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_2$a(ctx) {
  let t2;
  return {
    c() {
      t2 = text("|");
    },
    l(nodes) {
      t2 = claim_text(nodes, "|");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_fragment$O(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$n, create_if_block_3$9];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*type*/
      ctx2[6] === "default"
    )
      return 0;
    if (
      /*type*/
      ctx2[6] === "pill"
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (if_block)
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
const defaultClass$n = "radio bg-surface text-surface border-border checked:bg-none border checked:border-primary group-hover:border-primary group-focus:border-primary active:border-primary focus:active:border-primary focus:border-primary rounded-full h-6 w-6";
const pillClass = "group relative border border-border rounded-md py-3 px-3 flex items-center justify-center text-sm font-medium sm:flex-1 cursor-pointer focus:outline-none";
function instance$M($$self, $$props, $$invalidate) {
  let finalClass;
  let $selected;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { id = void 0 } = $$props;
  let { value } = $$props;
  let { disabled = false } = $$props;
  const name = getContext("radio-name");
  const type = getContext("radio-type");
  const selected = getContext("radio-selected");
  component_subscribe($$self, selected, (value2) => $$invalidate(4, $selected = value2));
  function handleClick() {
    if (!disabled) {
      set_store_value(selected, $selected = value, $selected);
    }
  }
  setContext("radio-id", id);
  const $$binding_groups = [[]];
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_change_handler() {
    $selected = this.__value;
    selected.set($selected);
  }
  function input_change_handler_1() {
    $selected = this.__value;
    selected.set($selected);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(16, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("id" in $$new_props)
      $$invalidate(0, id = $$new_props.id);
    if ("value" in $$new_props)
      $$invalidate(1, value = $$new_props.value);
    if ("disabled" in $$new_props)
      $$invalidate(2, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(10, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(3, finalClass = twMerge(type === "default" ? defaultClass$n : false, type === "pill" ? pillClass : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    id,
    value,
    disabled,
    finalClass,
    $selected,
    name,
    type,
    selected,
    handleClick,
    $$slots,
    $$scope,
    slots,
    click_handler,
    input_change_handler,
    $$binding_groups,
    input_change_handler_1
  ];
}
class Radio extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$M, create_fragment$O, safe_not_equal, { id: 0, value: 1, disabled: 2 });
  }
}
function create_fragment$N(ctx) {
  let label;
  let label_for_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let label_levels = [
    {
      for: label_for_value = /*id*/
      ctx[3] ? (
        /*id*/
        ctx[3]
      ) : void 0
    },
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class", "for"]
    )
  ];
  let label_data = {};
  for (let i2 = 0; i2 < label_levels.length; i2 += 1) {
    label_data = assign$1(label_data, label_levels[i2]);
  }
  return {
    c() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      label = claim_element(nodes, "LABEL", { for: true, class: true });
      var label_nodes = children(label);
      if (default_slot)
        default_slot.l(label_nodes);
      label_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(label, label_data);
    },
    m(target, anchor) {
      insert_hydration(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            label,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, label)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        { for: label_for_value },
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class", "for"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$m = "font-medium cursor-pointer text-content";
function instance$L($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const id = getContext("radio-name");
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$m, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, id, $$props, $$scope, slots];
}
let Label$2 = class Label10 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$L, create_fragment$N, safe_not_equal, { use: 0 });
  }
};
function create_fragment$M(ctx) {
  let span;
  let span_id_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let span_levels = [
    {
      id: span_id_value = /*id*/
      ctx[3] ? `${/*id*/
      ctx[3]}-description` : void 0
    },
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class", "id"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { id: true, class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        { id: span_id_value },
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class", "id"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$l = "text-secondary-content";
function instance$K($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const id = getContext("radio-id");
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$l, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, id, $$props, $$scope, slots];
}
let Description$1 = class Description7 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$K, create_fragment$M, safe_not_equal, { use: 0 });
  }
};
const RadioGroup2 = RadioGroup$1;
RadioGroup2.Label = GroupLabel2;
RadioGroup2.Radio = Radio;
RadioGroup2.Radio.Label = Label$2;
RadioGroup2.Radio.Description = Description$1;
const Rating_svelte_svelte_type_style_lang = "";
const get_comparison_slot_changes = (dirty) => ({});
const get_comparison_slot_context = (ctx) => ({});
const get_goal_slot_changes = (dirty) => ({});
const get_goal_slot_context = (ctx) => ({});
const get_value_slot_changes$1 = (dirty) => ({});
const get_value_slot_context$1 = (ctx) => ({});
const get_icon_slot_changes$1 = (dirty) => ({});
const get_icon_slot_context$1 = (ctx) => ({});
const get_title_slot_changes$2 = (dirty) => ({});
const get_title_slot_context$2 = (ctx) => ({});
function create_if_block$m(ctx) {
  let div2;
  let t2;
  let current;
  const title_slot_template = (
    /*#slots*/
    ctx[7].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_title_slot_context$2
  );
  const icon_slot_template = (
    /*#slots*/
    ctx[7].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_icon_slot_context$1
  );
  return {
    c() {
      div2 = element("div");
      if (title_slot)
        title_slot.c();
      t2 = space();
      if (icon_slot)
        icon_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (title_slot)
        title_slot.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (icon_slot)
        icon_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "relative flex flex-row items-center justify-between");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (title_slot) {
        title_slot.m(div2, null);
      }
      append_hydration(div2, t2);
      if (icon_slot) {
        icon_slot.m(div2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_title_slot_changes$2
            ),
            get_title_slot_context$2
          );
        }
      }
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_icon_slot_changes$1
            ),
            get_icon_slot_context$1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (title_slot)
        title_slot.d(detaching);
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_fragment$L(ctx) {
  let div2;
  let t0;
  let t1;
  let t2;
  let t3;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*$$slots*/
    (ctx[5].title || /*$$slots*/
    ctx[5].icon) && create_if_block$m(ctx)
  );
  const value_slot_template = (
    /*#slots*/
    ctx[7].value
  );
  const value_slot = create_slot(
    value_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_value_slot_context$1
  );
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const goal_slot_template = (
    /*#slots*/
    ctx[7].goal
  );
  const goal_slot = create_slot(
    goal_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_goal_slot_context
  );
  const comparison_slot_template = (
    /*#slots*/
    ctx[7].comparison
  );
  const comparison_slot = create_slot(
    comparison_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_comparison_slot_context
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      if (value_slot)
        value_slot.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      if (goal_slot)
        goal_slot.c();
      t3 = space();
      if (comparison_slot)
        comparison_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (if_block)
        if_block.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (value_slot)
        value_slot.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (goal_slot)
        goal_slot.l(div_nodes);
      t3 = claim_space(div_nodes);
      if (comparison_slot)
        comparison_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
      toggle_class(
        div2,
        "border",
        /*bordered*/
        ctx[1]
      );
      toggle_class(
        div2,
        "border-border",
        /*bordered*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (if_block)
        if_block.m(div2, null);
      append_hydration(div2, t0);
      if (value_slot) {
        value_slot.m(div2, null);
      }
      append_hydration(div2, t1);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      append_hydration(div2, t2);
      if (goal_slot) {
        goal_slot.m(div2, null);
      }
      append_hydration(div2, t3);
      if (comparison_slot) {
        comparison_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[5].title || /*$$slots*/
        ctx2[5].icon
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$m(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (value_slot) {
        if (value_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            value_slot,
            value_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              value_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_value_slot_changes$1
            ),
            get_value_slot_context$1
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (goal_slot) {
        if (goal_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            goal_slot,
            goal_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              goal_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_goal_slot_changes
            ),
            get_goal_slot_context
          );
        }
      }
      if (comparison_slot) {
        if (comparison_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            comparison_slot,
            comparison_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              comparison_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_comparison_slot_changes
            ),
            get_comparison_slot_context
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(
        div2,
        "border",
        /*bordered*/
        ctx2[1]
      );
      toggle_class(
        div2,
        "border-border",
        /*bordered*/
        ctx2[1]
      );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(value_slot, local);
      transition_in(default_slot, local);
      transition_in(goal_slot, local);
      transition_in(comparison_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(value_slot, local);
      transition_out(default_slot, local);
      transition_out(goal_slot, local);
      transition_out(comparison_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block)
        if_block.d();
      if (value_slot)
        value_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (goal_slot)
        goal_slot.d(detaching);
      if (comparison_slot)
        comparison_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$k = "overflow-hidden rounded-md px-4 py-5 shadow-md sm:p-5 bg-surface";
function instance$J($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { bordered = true } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("bordered" in $$new_props)
      $$invalidate(1, bordered = $$new_props.bordered);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(2, finalClass = twMerge(defaultClass$k, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, bordered, finalClass, forwardEvents, $$props, $$slots, $$scope, slots];
}
let Statistic$1 = class Statistic extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$J, create_fragment$L, safe_not_equal, { use: 0, bordered: 1 });
  }
};
function create_fragment$K(ctx) {
  let dt;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let dt_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let dt_data = {};
  for (let i2 = 0; i2 < dt_levels.length; i2 += 1) {
    dt_data = assign$1(dt_data, dt_levels[i2]);
  }
  return {
    c() {
      dt = element("dt");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      dt = claim_element(nodes, "DT", { class: true });
      var dt_nodes = children(dt);
      if (default_slot)
        default_slot.l(dt_nodes);
      dt_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(dt, dt_data);
    },
    m(target, anchor) {
      insert_hydration(target, dt, anchor);
      if (default_slot) {
        default_slot.m(dt, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            dt,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, dt)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(dt, dt_data = get_spread_update(dt_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(dt);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$j = "truncate text-sm font-medium text-secondary-content";
function instance$I($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$j, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
let Title$3 = class Title7 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$I, create_fragment$K, safe_not_equal, { use: 0 });
  }
};
function create_fragment$J(ctx) {
  let dd;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let dd_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let dd_data = {};
  for (let i2 = 0; i2 < dd_levels.length; i2 += 1) {
    dd_data = assign$1(dd_data, dd_levels[i2]);
  }
  return {
    c() {
      dd = element("dd");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      dd = claim_element(nodes, "DD", { class: true });
      var dd_nodes = children(dd);
      if (default_slot)
        default_slot.l(dd_nodes);
      dd_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(dd, dd_data);
    },
    m(target, anchor) {
      insert_hydration(target, dd, anchor);
      if (default_slot) {
        default_slot.m(dd, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            dd,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, dd)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(dd, dd_data = get_spread_update(dd_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(dd);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$i = "mt-1 text-3xl font-semibold tracking-tight text-content";
function instance$H($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$i, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
class Value extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$H, create_fragment$J, safe_not_equal, { use: 0 });
  }
}
function create_fragment$I(ctx) {
  let dd;
  let svg;
  let useActions_action;
  let mounted;
  let dispose;
  let dd_levels = [
    { class: (
      /*finalClass*/
      ctx[7]
    ) },
    exclude(
      /*$$props*/
      ctx[10],
      [
        "use",
        "class",
        "data",
        "size",
        "width",
        "height",
        "color",
        "stroke",
        "fill",
        "viewBox"
      ]
    )
  ];
  let dd_data = {};
  for (let i2 = 0; i2 < dd_levels.length; i2 += 1) {
    dd_data = assign$1(dd_data, dd_levels[i2]);
  }
  return {
    c() {
      dd = element("dd");
      svg = svg_element("svg");
      this.h();
    },
    l(nodes) {
      dd = claim_element(nodes, "DD", { class: true });
      var dd_nodes = children(dd);
      svg = claim_svg_element(dd_nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        stroke: true,
        fill: true,
        color: true
      });
      var svg_nodes = children(svg);
      svg_nodes.forEach(detach);
      dd_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(
        svg,
        "width",
        /*width*/
        ctx[2]
      );
      attr(
        svg,
        "height",
        /*height*/
        ctx[3]
      );
      attr(
        svg,
        "viewBox",
        /*viewBox*/
        ctx[1]
      );
      attr(
        svg,
        "stroke",
        /*stroke*/
        ctx[5]
      );
      attr(
        svg,
        "fill",
        /*fill*/
        ctx[6]
      );
      attr(
        svg,
        "color",
        /*color*/
        ctx[4]
      );
      set_attributes(dd, dd_data);
    },
    m(target, anchor) {
      insert_hydration(target, dd, anchor);
      append_hydration(dd, svg);
      svg.innerHTML = /*elements*/
      ctx[8];
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            dd,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[9].call(null, dd)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*elements*/
      256)
        svg.innerHTML = /*elements*/
        ctx2[8];
      if (dirty & /*width*/
      4) {
        attr(
          svg,
          "width",
          /*width*/
          ctx2[2]
        );
      }
      if (dirty & /*height*/
      8) {
        attr(
          svg,
          "height",
          /*height*/
          ctx2[3]
        );
      }
      if (dirty & /*viewBox*/
      2) {
        attr(
          svg,
          "viewBox",
          /*viewBox*/
          ctx2[1]
        );
      }
      if (dirty & /*stroke*/
      32) {
        attr(
          svg,
          "stroke",
          /*stroke*/
          ctx2[5]
        );
      }
      if (dirty & /*fill*/
      64) {
        attr(
          svg,
          "fill",
          /*fill*/
          ctx2[6]
        );
      }
      if (dirty & /*color*/
      16) {
        attr(
          svg,
          "color",
          /*color*/
          ctx2[4]
        );
      }
      set_attributes(dd, dd_data = get_spread_update(dd_levels, [
        dirty & /*finalClass*/
        128 && { class: (
          /*finalClass*/
          ctx2[7]
        ) },
        dirty & /*$$props*/
        1024 && exclude(
          /*$$props*/
          ctx2[10],
          [
            "use",
            "class",
            "data",
            "size",
            "width",
            "height",
            "color",
            "stroke",
            "fill",
            "viewBox"
          ]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(dd);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$h = "text-content absolute -top-3 -right-2";
function extractViewBox$1(svg) {
  const regex = /viewBox="([\d\- ]+)"/;
  const res = regex.exec(svg);
  if (!res)
    return "0 0 24 24";
  return res[1];
}
function instance$G($$self, $$props, $$invalidate) {
  let elements2;
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { data = "" } = $$props;
  let { viewBox = extractViewBox$1(data) } = $$props;
  let { size = "38px" } = $$props;
  let { width: width2 = size } = $$props;
  let { height = size } = $$props;
  let { color: color2 = "currentColor" } = $$props;
  let { stroke = void 0 } = $$props;
  let { fill: fill2 = color2 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("data" in $$new_props)
      $$invalidate(11, data = $$new_props.data);
    if ("viewBox" in $$new_props)
      $$invalidate(1, viewBox = $$new_props.viewBox);
    if ("size" in $$new_props)
      $$invalidate(12, size = $$new_props.size);
    if ("width" in $$new_props)
      $$invalidate(2, width2 = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(3, height = $$new_props.height);
    if ("color" in $$new_props)
      $$invalidate(4, color2 = $$new_props.color);
    if ("stroke" in $$new_props)
      $$invalidate(5, stroke = $$new_props.stroke);
    if ("fill" in $$new_props)
      $$invalidate(6, fill2 = $$new_props.fill);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data*/
    2048) {
      $$invalidate(8, elements2 = data.replace(/<svg ([^>]*)>/, "").replace("</svg>", ""));
    }
    $$invalidate(7, finalClass = twMerge(defaultClass$h, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    viewBox,
    width2,
    height,
    color2,
    stroke,
    fill2,
    finalClass,
    elements2,
    forwardEvents,
    $$props,
    data,
    size
  ];
}
class Icon7 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$G, create_fragment$I, safe_not_equal, {
      use: 0,
      data: 11,
      viewBox: 1,
      size: 12,
      width: 2,
      height: 3,
      color: 4,
      stroke: 5,
      fill: 6
    });
  }
}
function create_fragment$H(ctx) {
  let dd;
  let progress_1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  progress_1 = new Progress$1({ props: { value: (
    /*progress*/
    ctx[1]
  ) } });
  let dd_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class"]
    )
  ];
  let dd_data = {};
  for (let i2 = 0; i2 < dd_levels.length; i2 += 1) {
    dd_data = assign$1(dd_data, dd_levels[i2]);
  }
  return {
    c() {
      dd = element("dd");
      create_component(progress_1.$$.fragment);
      this.h();
    },
    l(nodes) {
      dd = claim_element(nodes, "DD", { class: true });
      var dd_nodes = children(dd);
      claim_component(progress_1.$$.fragment, dd_nodes);
      dd_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(dd, dd_data);
    },
    m(target, anchor) {
      insert_hydration(target, dd, anchor);
      mount_component(progress_1, dd, null);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            dd,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, dd)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const progress_1_changes = {};
      if (dirty & /*progress*/
      2)
        progress_1_changes.value = /*progress*/
        ctx2[1];
      progress_1.$set(progress_1_changes);
      set_attributes(dd, dd_data = get_spread_update(dd_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(progress_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(progress_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(dd);
      }
      destroy_component(progress_1);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$g = "mt-2";
function instance$F($$self, $$props, $$invalidate) {
  let finalClass;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { progress } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("progress" in $$new_props)
      $$invalidate(1, progress = $$new_props.progress);
  };
  $$self.$$.update = () => {
    $$invalidate(2, finalClass = twMerge(defaultClass$g, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, progress, finalClass, forwardEvents, $$props];
}
class Goal extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$F, create_fragment$H, safe_not_equal, { use: 0, progress: 1 });
  }
}
const get_trend_slot_changes = (dirty) => ({});
const get_trend_slot_context = (ctx) => ({});
const get_value_slot_changes = (dirty) => ({});
const get_value_slot_context = (ctx) => ({});
function create_fragment$G(ctx) {
  let dd;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const value_slot_template = (
    /*#slots*/
    ctx[5].value
  );
  const value_slot = create_slot(
    value_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_value_slot_context
  );
  const trend_slot_template = (
    /*#slots*/
    ctx[5].trend
  );
  const trend_slot = create_slot(
    trend_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    get_trend_slot_context
  );
  let dd_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let dd_data = {};
  for (let i2 = 0; i2 < dd_levels.length; i2 += 1) {
    dd_data = assign$1(dd_data, dd_levels[i2]);
  }
  return {
    c() {
      dd = element("dd");
      if (value_slot)
        value_slot.c();
      t2 = space();
      if (trend_slot)
        trend_slot.c();
      this.h();
    },
    l(nodes) {
      dd = claim_element(nodes, "DD", { class: true });
      var dd_nodes = children(dd);
      if (value_slot)
        value_slot.l(dd_nodes);
      t2 = claim_space(dd_nodes);
      if (trend_slot)
        trend_slot.l(dd_nodes);
      dd_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(dd, dd_data);
    },
    m(target, anchor) {
      insert_hydration(target, dd, anchor);
      if (value_slot) {
        value_slot.m(dd, null);
      }
      append_hydration(dd, t2);
      if (trend_slot) {
        trend_slot.m(dd, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            dd,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, dd)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (value_slot) {
        if (value_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            value_slot,
            value_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              value_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_value_slot_changes
            ),
            get_value_slot_context
          );
        }
      }
      if (trend_slot) {
        if (trend_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            trend_slot,
            trend_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              trend_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              get_trend_slot_changes
            ),
            get_trend_slot_context
          );
        }
      }
      set_attributes(dd, dd_data = get_spread_update(dd_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(value_slot, local);
      transition_in(trend_slot, local);
      current = true;
    },
    o(local) {
      transition_out(value_slot, local);
      transition_out(trend_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(dd);
      }
      if (value_slot)
        value_slot.d(detaching);
      if (trend_slot)
        trend_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$f = "mt-1 text-sm flex flex-row justify-between items-center tracking-tight";
function instance$E($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$f, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
class Comparison extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$E, create_fragment$G, safe_not_equal, { use: 0 });
  }
}
function create_fragment$F(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$e = "text-secondary-content";
function instance$D($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$e, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
class ComparisonValue extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$D, create_fragment$F, safe_not_equal, { use: 0 });
  }
}
function create_fragment$E(ctx) {
  let svg;
  let useActions_action;
  let mounted;
  let dispose;
  let svg_levels = [
    { xmlns: "http://www.w3.org/2000/svg" },
    { width: (
      /*width*/
      ctx[2]
    ) },
    { height: (
      /*height*/
      ctx[3]
    ) },
    { viewBox: (
      /*viewBox*/
      ctx[1]
    ) },
    { stroke: (
      /*stroke*/
      ctx[5]
    ) },
    { fill: (
      /*fill*/
      ctx[6]
    ) },
    { color: (
      /*color*/
      ctx[4]
    ) },
    exclude(
      /*$$props*/
      ctx[9],
      [
        "use",
        "fill",
        "viewBox",
        "width",
        "height",
        "stroke",
        "size",
        "color",
        "data"
      ]
    )
  ];
  let svg_data = {};
  for (let i2 = 0; i2 < svg_levels.length; i2 += 1) {
    svg_data = assign$1(svg_data, svg_levels[i2]);
  }
  return {
    c() {
      svg = svg_element("svg");
      this.h();
    },
    l(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        stroke: true,
        fill: true,
        color: true
      });
      var svg_nodes = children(svg);
      svg_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_svg_attributes(svg, svg_data);
    },
    m(target, anchor) {
      insert_hydration(target, svg, anchor);
      svg.innerHTML = /*elements*/
      ctx[7];
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            svg,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[8].call(null, svg)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*elements*/
      128)
        svg.innerHTML = /*elements*/
        ctx2[7];
      set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
        { xmlns: "http://www.w3.org/2000/svg" },
        dirty & /*width*/
        4 && { width: (
          /*width*/
          ctx2[2]
        ) },
        dirty & /*height*/
        8 && { height: (
          /*height*/
          ctx2[3]
        ) },
        dirty & /*viewBox*/
        2 && { viewBox: (
          /*viewBox*/
          ctx2[1]
        ) },
        dirty & /*stroke*/
        32 && { stroke: (
          /*stroke*/
          ctx2[5]
        ) },
        dirty & /*fill*/
        64 && { fill: (
          /*fill*/
          ctx2[6]
        ) },
        dirty & /*color*/
        16 && { color: (
          /*color*/
          ctx2[4]
        ) },
        dirty & /*$$props*/
        512 && exclude(
          /*$$props*/
          ctx2[9],
          [
            "use",
            "fill",
            "viewBox",
            "width",
            "height",
            "stroke",
            "size",
            "color",
            "data"
          ]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function extractViewBox(svg) {
  const regex = /viewBox="([\d\- ]+)"/;
  const res = regex.exec(svg);
  if (!res)
    return "0 0 24 24";
  return res[1];
}
function instance$C($$self, $$props, $$invalidate) {
  let elements2;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { data = "" } = $$props;
  let { viewBox = extractViewBox(data) } = $$props;
  let { size = "12px" } = $$props;
  let { width: width2 = size } = $$props;
  let { height = size } = $$props;
  let { color: color2 = "currentColor" } = $$props;
  let { stroke = void 0 } = $$props;
  let { fill: fill2 = color2 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("data" in $$new_props)
      $$invalidate(10, data = $$new_props.data);
    if ("viewBox" in $$new_props)
      $$invalidate(1, viewBox = $$new_props.viewBox);
    if ("size" in $$new_props)
      $$invalidate(11, size = $$new_props.size);
    if ("width" in $$new_props)
      $$invalidate(2, width2 = $$new_props.width);
    if ("height" in $$new_props)
      $$invalidate(3, height = $$new_props.height);
    if ("color" in $$new_props)
      $$invalidate(4, color2 = $$new_props.color);
    if ("stroke" in $$new_props)
      $$invalidate(5, stroke = $$new_props.stroke);
    if ("fill" in $$new_props)
      $$invalidate(6, fill2 = $$new_props.fill);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data*/
    1024) {
      $$invalidate(7, elements2 = data.replace(/<svg ([^>]*)>/, "").replace("</svg>", ""));
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    viewBox,
    width2,
    height,
    color2,
    stroke,
    fill2,
    elements2,
    forwardEvents,
    $$props,
    data,
    size
  ];
}
class TrendIcon extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$C, create_fragment$E, safe_not_equal, {
      use: 0,
      data: 10,
      viewBox: 1,
      size: 11,
      width: 2,
      height: 3,
      color: 4,
      stroke: 5,
      fill: 6
    });
  }
}
const get_icon_slot_changes = (dirty) => ({});
const get_icon_slot_context = (ctx) => ({});
function create_if_block$l(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$e, create_else_block$a];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[4].icon
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block$a(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block_2$9, create_if_block_3$8, create_else_block_1$3];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*trend*/
      ctx2[0] === "up"
    )
      return 0;
    if (
      /*trend*/
      ctx2[0] === "down"
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      span = element("span");
      if_block.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if_block.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "mr-1");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if_blocks[current_block_type_index].m(span, null);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(span, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if_blocks[current_block_type_index].d();
    }
  };
}
function create_if_block_1$e(ctx) {
  let span;
  let current;
  const icon_slot_template = (
    /*#slots*/
    ctx[5].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_icon_slot_context
  );
  return {
    c() {
      span = element("span");
      if (icon_slot)
        icon_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (icon_slot)
        icon_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "mr-1");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (icon_slot) {
        icon_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_icon_slot_changes
            ),
            get_icon_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      current = true;
    },
    o(local) {
      transition_out(icon_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (icon_slot)
        icon_slot.d(detaching);
    }
  };
}
function create_else_block_1$3(ctx) {
  let trendicon;
  let current;
  trendicon = new TrendIcon({ props: { data: trending_neutral } });
  return {
    c() {
      create_component(trendicon.$$.fragment);
    },
    l(nodes) {
      claim_component(trendicon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(trendicon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(trendicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(trendicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(trendicon, detaching);
    }
  };
}
function create_if_block_3$8(ctx) {
  let trendicon;
  let current;
  trendicon = new TrendIcon({ props: { data: trending_down } });
  return {
    c() {
      create_component(trendicon.$$.fragment);
    },
    l(nodes) {
      claim_component(trendicon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(trendicon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(trendicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(trendicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(trendicon, detaching);
    }
  };
}
function create_if_block_2$9(ctx) {
  let trendicon;
  let current;
  trendicon = new TrendIcon({ props: { data: trending_up } });
  return {
    c() {
      create_component(trendicon.$$.fragment);
    },
    l(nodes) {
      claim_component(trendicon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(trendicon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(trendicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(trendicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(trendicon, detaching);
    }
  };
}
function create_default_slot$b(ctx) {
  let t2;
  let span;
  let current;
  let if_block = (
    /*showIcon*/
    ctx[1] && create_if_block$l(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      t2 = space();
      span = element("span");
      if (default_slot)
        default_slot.c();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      t2 = claim_space(nodes);
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*showIcon*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*showIcon*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$l(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
        detach(span);
      }
      if (if_block)
        if_block.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$D(ctx) {
  let badge;
  let current;
  badge = new Badge2({
    props: {
      class: (
        /*finalClass*/
        ctx[2]
      ),
      style: (
        /*$$props*/
        ctx[3].style
      ),
      $$slots: { default: [create_default_slot$b] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(badge.$$.fragment);
    },
    l(nodes) {
      claim_component(badge.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(badge, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const badge_changes = {};
      if (dirty & /*finalClass*/
      4)
        badge_changes.class = /*finalClass*/
        ctx2[2];
      if (dirty & /*$$props*/
      8)
        badge_changes.style = /*$$props*/
        ctx2[3].style;
      if (dirty & /*$$scope, $$slots, trend, showIcon*/
      83) {
        badge_changes.$$scope = { dirty, ctx: ctx2 };
      }
      badge.$set(badge_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(badge.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge, detaching);
    }
  };
}
const trendUpClass = "bg-success text-success-content";
const trendDownClass = "bg-error text-error-content";
const trendEvenClass = "bg-info text-info-content";
function instance$B($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { trend = void 0 } = $$props;
  let { showIcon = true } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("trend" in $$new_props)
      $$invalidate(0, trend = $$new_props.trend);
    if ("showIcon" in $$new_props)
      $$invalidate(1, showIcon = $$new_props.showIcon);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(2, finalClass = twMerge(trend === "up" ? trendUpClass : false, trend === "down" ? trendDownClass : false, trend === "neutral" ? trendEvenClass : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [trend, showIcon, finalClass, $$props, $$slots, slots, $$scope];
}
class Trend extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$B, create_fragment$D, safe_not_equal, { trend: 0, showIcon: 1 });
  }
}
const Statistic2 = Statistic$1;
Statistic2.Icon = Icon7;
Statistic2.Title = Title$3;
Statistic2.Value = Value;
Statistic2.Goal = Goal;
Statistic2.Comparison = Comparison;
Statistic2.Comparison.Value = ComparisonValue;
Statistic2.Comparison.Trend = Trend;
Statistic2.Comparison.Trend.Icon = TrendIcon;
const get_summary_slot_changes = (dirty) => ({});
const get_summary_slot_context = (ctx) => ({});
function create_if_block_3$7(ctx) {
  let nav;
  let ol;
  let ol_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  return {
    c() {
      nav = element("nav");
      ol = element("ol");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      nav = claim_element(nodes, "NAV", {});
      var nav_nodes = children(nav);
      ol = claim_element(nav_nodes, "OL", { class: true, style: true });
      var ol_nodes = children(ol);
      if (default_slot)
        default_slot.l(ol_nodes);
      ol_nodes.forEach(detach);
      nav_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(
        ol,
        "class",
        /*finalClass*/
        ctx[1]
      );
      attr(ol, "style", ol_style_value = /*$$props*/
      ctx[3].style);
    },
    m(target, anchor) {
      insert_hydration(target, nav, anchor);
      append_hydration(nav, ol);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*finalClass*/
      2) {
        attr(
          ol,
          "class",
          /*finalClass*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*$$props*/
      8 && ol_style_value !== (ol_style_value = /*$$props*/
      ctx2[3].style)) {
        attr(ol, "style", ol_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(nav);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block_2$8(ctx) {
  let div2;
  let nav;
  let ol;
  let div_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  return {
    c() {
      div2 = element("div");
      nav = element("nav");
      ol = element("ol");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div2);
      nav = claim_element(div_nodes, "NAV", { class: true });
      var nav_nodes = children(nav);
      ol = claim_element(nav_nodes, "OL", { class: true });
      var ol_nodes = children(ol);
      if (default_slot)
        default_slot.l(ol_nodes);
      ol_nodes.forEach(detach);
      nav_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(ol, "class", "space-y-6");
      attr(nav, "class", "flex justify-center");
      attr(
        div2,
        "class",
        /*finalClass*/
        ctx[1]
      );
      attr(div2, "style", div_style_value = /*$$props*/
      ctx[3].style);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, nav);
      append_hydration(nav, ol);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*finalClass*/
      2) {
        attr(
          div2,
          "class",
          /*finalClass*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*$$props*/
      8 && div_style_value !== (div_style_value = /*$$props*/
      ctx2[3].style)) {
        attr(div2, "style", div_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block_1$d(ctx) {
  let nav;
  let t2;
  let ol;
  let nav_style_value;
  let current;
  const summary_slot_template = (
    /*#slots*/
    ctx[6].summary
  );
  const summary_slot = create_slot(
    summary_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_summary_slot_context
  );
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  return {
    c() {
      nav = element("nav");
      if (summary_slot)
        summary_slot.c();
      t2 = space();
      ol = element("ol");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      nav = claim_element(nodes, "NAV", { class: true, style: true });
      var nav_nodes = children(nav);
      if (summary_slot)
        summary_slot.l(nav_nodes);
      t2 = claim_space(nav_nodes);
      ol = claim_element(nav_nodes, "OL", { class: true });
      var ol_nodes = children(ol);
      if (default_slot)
        default_slot.l(ol_nodes);
      ol_nodes.forEach(detach);
      nav_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(ol, "class", "ml-8 flex items-center space-x-5");
      attr(
        nav,
        "class",
        /*finalClass*/
        ctx[1]
      );
      attr(nav, "style", nav_style_value = /*$$props*/
      ctx[3].style);
    },
    m(target, anchor) {
      insert_hydration(target, nav, anchor);
      if (summary_slot) {
        summary_slot.m(nav, null);
      }
      append_hydration(nav, t2);
      append_hydration(nav, ol);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (summary_slot) {
        if (summary_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            summary_slot,
            summary_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              summary_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_summary_slot_changes
            ),
            get_summary_slot_context
          );
        }
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*finalClass*/
      2) {
        attr(
          nav,
          "class",
          /*finalClass*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*$$props*/
      8 && nav_style_value !== (nav_style_value = /*$$props*/
      ctx2[3].style)) {
        attr(nav, "style", nav_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(summary_slot, local);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(summary_slot, local);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(nav);
      }
      if (summary_slot)
        summary_slot.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_if_block$k(ctx) {
  let nav;
  let ol;
  let ol_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  return {
    c() {
      nav = element("nav");
      ol = element("ol");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      nav = claim_element(nodes, "NAV", {});
      var nav_nodes = children(nav);
      ol = claim_element(nav_nodes, "OL", { class: true, style: true });
      var ol_nodes = children(ol);
      if (default_slot)
        default_slot.l(ol_nodes);
      ol_nodes.forEach(detach);
      nav_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(
        ol,
        "class",
        /*finalClass*/
        ctx[1]
      );
      attr(ol, "style", ol_style_value = /*$$props*/
      ctx[3].style);
    },
    m(target, anchor) {
      insert_hydration(target, nav, anchor);
      append_hydration(nav, ol);
      if (default_slot) {
        default_slot.m(ol, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*finalClass*/
      2) {
        attr(
          ol,
          "class",
          /*finalClass*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*$$props*/
      8 && ol_style_value !== (ol_style_value = /*$$props*/
      ctx2[3].style)) {
        attr(ol, "style", ol_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(nav);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$C(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$k, create_if_block_1$d, create_if_block_2$8, create_if_block_3$7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*variant*/
      ctx2[0] === "simple"
    )
      return 0;
    if (
      /*variant*/
      ctx2[0] === "bullets"
    )
      return 1;
    if (
      /*variant*/
      ctx2[0] === "bullets-text"
    )
      return 2;
    if (
      /*variant*/
      ctx2[0] === "circles-text"
    )
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
const bulletsClass = "flex items-center justify-center";
const bulletsTextClass = "py-12 px-4 sm:px-6 lg:px-8";
const circlesTextClass = "overflow-hidden";
const simpleClass = "space-y-4 md:flex md:space-y-0 md:space-x-8";
function instance$A($$self, $$props, $$invalidate) {
  let finalClass;
  let $acitveStep;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { variant = "simple" } = $$props;
  let { currentStep } = $$props;
  let acitveStep = writable(currentStep);
  component_subscribe($$self, acitveStep, (value) => $$invalidate(7, $acitveStep = value));
  setContext("steps-variant", variant);
  setContext("steps-currentStep", acitveStep);
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("variant" in $$new_props)
      $$invalidate(0, variant = $$new_props.variant);
    if ("currentStep" in $$new_props)
      $$invalidate(4, currentStep = $$new_props.currentStep);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*currentStep*/
    16) {
      set_store_value(acitveStep, $acitveStep = currentStep, $acitveStep);
    }
    $$invalidate(1, finalClass = twMerge(variant === "bullets" ? bulletsClass : false, variant === "bullets-text" ? bulletsTextClass : false, variant === "circles-text" ? circlesTextClass : false, variant === "simple" ? simpleClass : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [variant, finalClass, acitveStep, $$props, currentStep, $$scope, slots];
}
let Steps$1 = class Steps extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$A, create_fragment$C, safe_not_equal, { variant: 0, currentStep: 4 });
  }
};
const Step_svelte_svelte_type_style_lang = "";
const get_description_slot_changes_5 = (dirty) => ({});
const get_description_slot_context_5 = (ctx) => ({});
const get_title_slot_changes_11 = (dirty) => ({});
const get_title_slot_context_11 = (ctx) => ({});
const get_description_slot_changes_4 = (dirty) => ({});
const get_description_slot_context_4 = (ctx) => ({});
const get_title_slot_changes_10 = (dirty) => ({});
const get_title_slot_context_10 = (ctx) => ({});
const get_description_slot_changes_3 = (dirty) => ({});
const get_description_slot_context_3 = (ctx) => ({});
const get_title_slot_changes_9 = (dirty) => ({});
const get_title_slot_context_9 = (ctx) => ({});
const get_title_slot_changes_8 = (dirty) => ({});
const get_title_slot_context_8 = (ctx) => ({});
const get_title_slot_changes_7 = (dirty) => ({});
const get_title_slot_context_7 = (ctx) => ({});
const get_title_slot_changes_6 = (dirty) => ({});
const get_title_slot_context_6 = (ctx) => ({});
const get_title_slot_changes_5 = (dirty) => ({});
const get_title_slot_context_5 = (ctx) => ({});
const get_title_slot_changes_4 = (dirty) => ({});
const get_title_slot_context_4 = (ctx) => ({});
const get_title_slot_changes_3 = (dirty) => ({});
const get_title_slot_context_3 = (ctx) => ({});
const get_description_slot_changes_2 = (dirty) => ({});
const get_description_slot_context_2 = (ctx) => ({});
const get_title_slot_changes_2 = (dirty) => ({});
const get_title_slot_context_2 = (ctx) => ({});
const get_description_slot_changes_1 = (dirty) => ({});
const get_description_slot_context_1 = (ctx) => ({});
const get_title_slot_changes_1 = (dirty) => ({});
const get_title_slot_context_1 = (ctx) => ({});
const get_description_slot_changes = (dirty) => ({});
const get_description_slot_context = (ctx) => ({});
const get_title_slot_changes$1 = (dirty) => ({});
const get_title_slot_context$1 = (ctx) => ({});
function create_if_block_9$2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_10$2, create_if_block_11$1, create_else_block_3$1];
  const if_blocks = [];
  function select_block_type_4(ctx2, dirty) {
    if (
      /*$currentStep*/
      ctx2[3] > /*step*/
      ctx2[2]
    )
      return 0;
    if (
      /*$currentStep*/
      ctx2[3] === /*step*/
      ctx2[2]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_4(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_4(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_6$3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_7$3, create_if_block_8$3, create_else_block_2$1];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*$currentStep*/
      ctx2[3] > /*step*/
      ctx2[2]
    )
      return 0;
    if (
      /*$currentStep*/
      ctx2[3] === /*step*/
      ctx2[2]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_3(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_3$6(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4$5, create_if_block_5$5, create_else_block_1$2];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$currentStep*/
      ctx2[3] > /*step*/
      ctx2[2]
    )
      return 0;
    if (
      /*$currentStep*/
      ctx2[3] === /*step*/
      ctx2[2]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block$j(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$c, create_if_block_2$7, create_else_block$9];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$currentStep*/
      ctx2[3] > /*step*/
      ctx2[2]
    )
      return 0;
    if (
      /*$currentStep*/
      ctx2[3] === /*step*/
      ctx2[2]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block_3$1(ctx) {
  let li;
  let div2;
  let t0;
  let a3;
  let span2;
  let textContent = `<span class="relative z-10 flex h-8 w-8 items-center justify-center rounded-full border-2 border-border bg-surface group-hover:border-border"><span class="h-2.5 w-2.5 rounded-full bg-transparent group-hover:bg-default"></span></span>`;
  let t1;
  let span3;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[10].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_title_slot_context_11
  );
  const description_slot_template = (
    /*#slots*/
    ctx[10].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_description_slot_context_5
  );
  let a_levels = [
    { href: (
      /*href*/
      ctx[1]
    ) },
    { class: "group relative flex items-start" },
    exclude(
      /*$$props*/
      ctx[8],
      ["use", "class"]
    )
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      div2 = element("div");
      t0 = space();
      a3 = element("a");
      span2 = element("span");
      span2.innerHTML = textContent;
      t1 = space();
      span3 = element("span");
      if (title_slot)
        title_slot.c();
      t2 = space();
      if (description_slot)
        description_slot.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { "data-step": true, class: true });
      var li_nodes = children(li);
      div2 = claim_element(li_nodes, "DIV", { class: true });
      children(div2).forEach(detach);
      t0 = claim_space(li_nodes);
      a3 = claim_element(li_nodes, "A", { href: true, class: true });
      var a_nodes = children(a3);
      span2 = claim_element(a_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span2) !== "svelte-w5e3ld")
        span2.innerHTML = textContent;
      t1 = claim_space(a_nodes);
      span3 = claim_element(a_nodes, "SPAN", { class: true });
      var span3_nodes = children(span3);
      if (title_slot)
        title_slot.l(span3_nodes);
      t2 = claim_space(span3_nodes);
      if (description_slot)
        description_slot.l(span3_nodes);
      span3_nodes.forEach(detach);
      a_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "divider absolute top-4 left-4 -ml-px mt-0.5 h-full w-0.5 bg-default svelte-1tu4tg");
      attr(span2, "class", "flex h-9 items-center");
      attr(span3, "class", "ml-4 flex min-w-0 flex-col");
      set_attributes(a3, a_data);
      toggle_class(a3, "svelte-1tu4tg", true);
      attr(
        li,
        "data-step",
        /*step*/
        ctx[2]
      );
      attr(li, "class", "step relative pb-10 svelte-1tu4tg");
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, div2);
      append_hydration(li, t0);
      append_hydration(li, a3);
      append_hydration(a3, span2);
      append_hydration(a3, t1);
      append_hydration(a3, span3);
      if (title_slot) {
        title_slot.m(span3, null);
      }
      append_hydration(span3, t2);
      if (description_slot) {
        description_slot.m(span3, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            a3,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[5].call(null, a3)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_title_slot_changes_11
            ),
            get_title_slot_context_11
          );
        }
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_description_slot_changes_5
            ),
            get_description_slot_context_5
          );
        }
      }
      set_attributes(a3, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        { class: "group relative flex items-start" },
        dirty & /*$$props*/
        256 && exclude(
          /*$$props*/
          ctx2[8],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(a3, "svelte-1tu4tg", true);
      if (!current || dirty & /*step*/
      4) {
        attr(
          li,
          "data-step",
          /*step*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(description_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      transition_out(description_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (title_slot)
        title_slot.d(detaching);
      if (description_slot)
        description_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_11$1(ctx) {
  let li;
  let div2;
  let t0;
  let a3;
  let span2;
  let textContent = `<span class="relative z-10 flex h-8 w-8 items-center justify-center rounded-full border-2 border-primary bg-surface"><span class="h-2.5 w-2.5 rounded-full bg-primary"></span></span>`;
  let t1;
  let span3;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[10].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_title_slot_context_10
  );
  const description_slot_template = (
    /*#slots*/
    ctx[10].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_description_slot_context_4
  );
  let a_levels = [
    { href: (
      /*href*/
      ctx[1]
    ) },
    { class: "group relative flex items-start" },
    exclude(
      /*$$props*/
      ctx[8],
      ["use", "class"]
    )
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      div2 = element("div");
      t0 = space();
      a3 = element("a");
      span2 = element("span");
      span2.innerHTML = textContent;
      t1 = space();
      span3 = element("span");
      if (title_slot)
        title_slot.c();
      t2 = space();
      if (description_slot)
        description_slot.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { "data-step": true, class: true });
      var li_nodes = children(li);
      div2 = claim_element(li_nodes, "DIV", { class: true });
      children(div2).forEach(detach);
      t0 = claim_space(li_nodes);
      a3 = claim_element(li_nodes, "A", { href: true, class: true });
      var a_nodes = children(a3);
      span2 = claim_element(a_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span2) !== "svelte-amjwkz")
        span2.innerHTML = textContent;
      t1 = claim_space(a_nodes);
      span3 = claim_element(a_nodes, "SPAN", { class: true });
      var span3_nodes = children(span3);
      if (title_slot)
        title_slot.l(span3_nodes);
      t2 = claim_space(span3_nodes);
      if (description_slot)
        description_slot.l(span3_nodes);
      span3_nodes.forEach(detach);
      a_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "divider absolute top-4 left-4 -ml-px mt-0.5 h-full w-0.5 bg-default svelte-1tu4tg");
      attr(span2, "class", "flex h-9 items-center");
      attr(span3, "class", "ml-4 flex min-w-0 flex-col");
      set_attributes(a3, a_data);
      toggle_class(a3, "svelte-1tu4tg", true);
      attr(
        li,
        "data-step",
        /*step*/
        ctx[2]
      );
      attr(li, "class", "step relative pb-10 svelte-1tu4tg");
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, div2);
      append_hydration(li, t0);
      append_hydration(li, a3);
      append_hydration(a3, span2);
      append_hydration(a3, t1);
      append_hydration(a3, span3);
      if (title_slot) {
        title_slot.m(span3, null);
      }
      append_hydration(span3, t2);
      if (description_slot) {
        description_slot.m(span3, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            a3,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[5].call(null, a3)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_title_slot_changes_10
            ),
            get_title_slot_context_10
          );
        }
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_description_slot_changes_4
            ),
            get_description_slot_context_4
          );
        }
      }
      set_attributes(a3, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        { class: "group relative flex items-start" },
        dirty & /*$$props*/
        256 && exclude(
          /*$$props*/
          ctx2[8],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(a3, "svelte-1tu4tg", true);
      if (!current || dirty & /*step*/
      4) {
        attr(
          li,
          "data-step",
          /*step*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(description_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      transition_out(description_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (title_slot)
        title_slot.d(detaching);
      if (description_slot)
        description_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_10$2(ctx) {
  let li;
  let div2;
  let t0;
  let a3;
  let span1;
  let textContent = `<span class="relative z-10 flex h-8 w-8 items-center justify-center rounded-full bg-primary group-hover:bg-primary-hover"><svg class="h-5 w-5 text-primary-content" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.704 4.153a.75.75 0 01.143 1.052l-8 10.5a.75.75 0 01-1.127.075l-4.5-4.5a.75.75 0 011.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 011.05-.143z" clip-rule="evenodd"></path></svg></span>`;
  let t1;
  let span2;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[10].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_title_slot_context_9
  );
  const description_slot_template = (
    /*#slots*/
    ctx[10].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_description_slot_context_3
  );
  let a_levels = [
    { href: (
      /*href*/
      ctx[1]
    ) },
    { class: "group relative flex items-start" },
    exclude(
      /*$$props*/
      ctx[8],
      ["use", "class"]
    )
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      div2 = element("div");
      t0 = space();
      a3 = element("a");
      span1 = element("span");
      span1.innerHTML = textContent;
      t1 = space();
      span2 = element("span");
      if (title_slot)
        title_slot.c();
      t2 = space();
      if (description_slot)
        description_slot.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { "data-step": true, class: true });
      var li_nodes = children(li);
      div2 = claim_element(li_nodes, "DIV", { class: true });
      children(div2).forEach(detach);
      t0 = claim_space(li_nodes);
      a3 = claim_element(li_nodes, "A", { href: true, class: true });
      var a_nodes = children(a3);
      span1 = claim_element(a_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span1) !== "svelte-sszc3z")
        span1.innerHTML = textContent;
      t1 = claim_space(a_nodes);
      span2 = claim_element(a_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      if (title_slot)
        title_slot.l(span2_nodes);
      t2 = claim_space(span2_nodes);
      if (description_slot)
        description_slot.l(span2_nodes);
      span2_nodes.forEach(detach);
      a_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "absolute top-4 left-4 -ml-px mt-0.5 h-full w-0.5 bg-primary");
      attr(span1, "class", "flex h-9 items-center");
      attr(span2, "class", "ml-4 flex min-w-0 flex-col");
      set_attributes(a3, a_data);
      attr(
        li,
        "data-step",
        /*step*/
        ctx[2]
      );
      attr(li, "class", "relative pb-10");
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, div2);
      append_hydration(li, t0);
      append_hydration(li, a3);
      append_hydration(a3, span1);
      append_hydration(a3, t1);
      append_hydration(a3, span2);
      if (title_slot) {
        title_slot.m(span2, null);
      }
      append_hydration(span2, t2);
      if (description_slot) {
        description_slot.m(span2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            a3,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[5].call(null, a3)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_title_slot_changes_9
            ),
            get_title_slot_context_9
          );
        }
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_description_slot_changes_3
            ),
            get_description_slot_context_3
          );
        }
      }
      set_attributes(a3, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        { class: "group relative flex items-start" },
        dirty & /*$$props*/
        256 && exclude(
          /*$$props*/
          ctx2[8],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      if (!current || dirty & /*step*/
      4) {
        attr(
          li,
          "data-step",
          /*step*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(description_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      transition_out(description_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (title_slot)
        title_slot.d(detaching);
      if (description_slot)
        description_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_2$1(ctx) {
  let li;
  let a3;
  let div2;
  let div1;
  let textContent = `<div class="h-2 w-2 rounded-full bg-border group-hover:bg-default"></div>`;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[10].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_title_slot_context_8
  );
  let a_levels = [
    { href: (
      /*href*/
      ctx[1]
    ) },
    { class: "group" },
    exclude(
      /*$$props*/
      ctx[8],
      ["use", "class"]
    )
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      a3 = element("a");
      div2 = element("div");
      div1 = element("div");
      div1.innerHTML = textContent;
      t2 = space();
      if (title_slot)
        title_slot.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { "data-step": true });
      var li_nodes = children(li);
      a3 = claim_element(li_nodes, "A", { href: true, class: true });
      var a_nodes = children(a3);
      div2 = claim_element(a_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(div1) !== "svelte-wqxym6")
        div1.innerHTML = textContent;
      t2 = claim_space(div2_nodes);
      if (title_slot)
        title_slot.l(div2_nodes);
      div2_nodes.forEach(detach);
      a_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div1, "class", "relative flex h-5 w-5 flex-shrink-0 items-center justify-center");
      attr(div2, "class", "flex items-start");
      set_attributes(a3, a_data);
      attr(
        li,
        "data-step",
        /*step*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, a3);
      append_hydration(a3, div2);
      append_hydration(div2, div1);
      append_hydration(div2, t2);
      if (title_slot) {
        title_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            a3,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[5].call(null, a3)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_title_slot_changes_8
            ),
            get_title_slot_context_8
          );
        }
      }
      set_attributes(a3, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        { class: "group" },
        dirty & /*$$props*/
        256 && exclude(
          /*$$props*/
          ctx2[8],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      if (!current || dirty & /*step*/
      4) {
        attr(
          li,
          "data-step",
          /*step*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (title_slot)
        title_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_8$3(ctx) {
  let li;
  let a3;
  let span2;
  let textContent = `<span class="absolute h-4 w-4 rounded-full bg-primary opacity-50"></span> <span class="relative block h-2 w-2 rounded-full bg-primary"></span>`;
  let t1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[10].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_title_slot_context_7
  );
  let a_levels = [
    { href: (
      /*href*/
      ctx[1]
    ) },
    { class: "flex items-start" },
    exclude(
      /*$$props*/
      ctx[8],
      ["use", "class"]
    )
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      a3 = element("a");
      span2 = element("span");
      span2.innerHTML = textContent;
      t1 = space();
      if (title_slot)
        title_slot.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { "data-step": true });
      var li_nodes = children(li);
      a3 = claim_element(li_nodes, "A", { href: true, class: true });
      var a_nodes = children(a3);
      span2 = claim_element(a_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span2) !== "svelte-1v8rmgg")
        span2.innerHTML = textContent;
      t1 = claim_space(a_nodes);
      if (title_slot)
        title_slot.l(a_nodes);
      a_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span2, "class", "relative flex h-5 w-5 flex-shrink-0 items-center justify-center");
      set_attributes(a3, a_data);
      attr(
        li,
        "data-step",
        /*step*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, a3);
      append_hydration(a3, span2);
      append_hydration(a3, t1);
      if (title_slot) {
        title_slot.m(a3, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            a3,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[5].call(null, a3)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_title_slot_changes_7
            ),
            get_title_slot_context_7
          );
        }
      }
      set_attributes(a3, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        { class: "flex items-start" },
        dirty & /*$$props*/
        256 && exclude(
          /*$$props*/
          ctx2[8],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      if (!current || dirty & /*step*/
      4) {
        attr(
          li,
          "data-step",
          /*step*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (title_slot)
        title_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_7$3(ctx) {
  let li;
  let a3;
  let span1;
  let span0;
  let textContent = `<svg class="h-full w-full text-primary group-hover:text-primary-hover" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z" clip-rule="evenodd"></path></svg>`;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[10].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_title_slot_context_6
  );
  let a_levels = [
    { href: (
      /*href*/
      ctx[1]
    ) },
    { class: "group" },
    exclude(
      /*$$props*/
      ctx[8],
      ["use", "class"]
    )
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      a3 = element("a");
      span1 = element("span");
      span0 = element("span");
      span0.innerHTML = textContent;
      t2 = space();
      if (title_slot)
        title_slot.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { "data-step": true });
      var li_nodes = children(li);
      a3 = claim_element(li_nodes, "A", { href: true, class: true });
      var a_nodes = children(a3);
      span1 = claim_element(a_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span0) !== "svelte-1scoe4m")
        span0.innerHTML = textContent;
      t2 = claim_space(span1_nodes);
      if (title_slot)
        title_slot.l(span1_nodes);
      span1_nodes.forEach(detach);
      a_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "class", "relative flex h-5 w-5 flex-shrink-0 items-center justify-center");
      attr(span1, "class", "flex items-start");
      set_attributes(a3, a_data);
      attr(
        li,
        "data-step",
        /*step*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, a3);
      append_hydration(a3, span1);
      append_hydration(span1, span0);
      append_hydration(span1, t2);
      if (title_slot) {
        title_slot.m(span1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            a3,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[5].call(null, a3)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_title_slot_changes_6
            ),
            get_title_slot_context_6
          );
        }
      }
      set_attributes(a3, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        { class: "group" },
        dirty & /*$$props*/
        256 && exclude(
          /*$$props*/
          ctx2[8],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      if (!current || dirty & /*step*/
      4) {
        attr(
          li,
          "data-step",
          /*step*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (title_slot)
        title_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_1$2(ctx) {
  let li;
  let a3;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[10].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_title_slot_context_5
  );
  let a_levels = [
    { href: (
      /*href*/
      ctx[1]
    ) },
    { class: (
      /*finalClass*/
      ctx[4]
    ) },
    exclude(
      /*$$props*/
      ctx[8],
      ["use", "class"]
    )
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      a3 = element("a");
      if (title_slot)
        title_slot.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { "data-step": true });
      var li_nodes = children(li);
      a3 = claim_element(li_nodes, "A", { href: true, class: true });
      var a_nodes = children(a3);
      if (title_slot)
        title_slot.l(a_nodes);
      a_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(a3, a_data);
      attr(
        li,
        "data-step",
        /*step*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, a3);
      if (title_slot) {
        title_slot.m(a3, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            a3,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[5].call(null, a3)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_title_slot_changes_5
            ),
            get_title_slot_context_5
          );
        }
      }
      set_attributes(a3, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        (!current || dirty & /*finalClass*/
        16) && { class: (
          /*finalClass*/
          ctx2[4]
        ) },
        dirty & /*$$props*/
        256 && exclude(
          /*$$props*/
          ctx2[8],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      if (!current || dirty & /*step*/
      4) {
        attr(
          li,
          "data-step",
          /*step*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (title_slot)
        title_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_5$5(ctx) {
  let li;
  let a3;
  let span1;
  let textContent = `<span class="h-full w-full rounded-full bg-primary opacity-50"></span>`;
  let t0;
  let span2;
  let t1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[10].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_title_slot_context_4
  );
  let a_levels = [
    { href: (
      /*href*/
      ctx[1]
    ) },
    { class: (
      /*finalClass*/
      ctx[4]
    ) },
    exclude(
      /*$$props*/
      ctx[8],
      ["use", "class"]
    )
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      a3 = element("a");
      span1 = element("span");
      span1.innerHTML = textContent;
      t0 = space();
      span2 = element("span");
      t1 = space();
      if (title_slot)
        title_slot.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { "data-step": true });
      var li_nodes = children(li);
      a3 = claim_element(li_nodes, "A", { href: true, class: true });
      var a_nodes = children(a3);
      span1 = claim_element(a_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span1) !== "svelte-n2bl0t")
        span1.innerHTML = textContent;
      t0 = claim_space(a_nodes);
      span2 = claim_element(a_nodes, "SPAN", { class: true });
      children(span2).forEach(detach);
      t1 = claim_space(a_nodes);
      if (title_slot)
        title_slot.l(a_nodes);
      a_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span1, "class", "absolute flex h-5 w-5 p-px");
      attr(span2, "class", "relative block h-2.5 w-2.5 rounded-full bg-primary");
      set_attributes(a3, a_data);
      attr(
        li,
        "data-step",
        /*step*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, a3);
      append_hydration(a3, span1);
      append_hydration(a3, t0);
      append_hydration(a3, span2);
      append_hydration(a3, t1);
      if (title_slot) {
        title_slot.m(a3, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            a3,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[5].call(null, a3)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_title_slot_changes_4
            ),
            get_title_slot_context_4
          );
        }
      }
      set_attributes(a3, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        (!current || dirty & /*finalClass*/
        16) && { class: (
          /*finalClass*/
          ctx2[4]
        ) },
        dirty & /*$$props*/
        256 && exclude(
          /*$$props*/
          ctx2[8],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      if (!current || dirty & /*step*/
      4) {
        attr(
          li,
          "data-step",
          /*step*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (title_slot)
        title_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4$5(ctx) {
  let li;
  let a3;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[10].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_title_slot_context_3
  );
  let a_levels = [
    { href: (
      /*href*/
      ctx[1]
    ) },
    { class: (
      /*finalClass*/
      ctx[4]
    ) },
    exclude(
      /*$$props*/
      ctx[8],
      ["use", "class"]
    )
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      a3 = element("a");
      if (title_slot)
        title_slot.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { "data-step": true });
      var li_nodes = children(li);
      a3 = claim_element(li_nodes, "A", { href: true, class: true });
      var a_nodes = children(a3);
      if (title_slot)
        title_slot.l(a_nodes);
      a_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(a3, a_data);
      attr(
        li,
        "data-step",
        /*step*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, a3);
      if (title_slot) {
        title_slot.m(a3, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            a3,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[5].call(null, a3)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_title_slot_changes_3
            ),
            get_title_slot_context_3
          );
        }
      }
      set_attributes(a3, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        (!current || dirty & /*finalClass*/
        16) && { class: (
          /*finalClass*/
          ctx2[4]
        ) },
        dirty & /*$$props*/
        256 && exclude(
          /*$$props*/
          ctx2[8],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      if (!current || dirty & /*step*/
      4) {
        attr(
          li,
          "data-step",
          /*step*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (title_slot)
        title_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block$9(ctx) {
  let li;
  let a3;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[10].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_title_slot_context_2
  );
  const description_slot_template = (
    /*#slots*/
    ctx[10].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_description_slot_context_2
  );
  let a_levels = [
    { href: (
      /*href*/
      ctx[1]
    ) },
    { class: (
      /*finalClass*/
      ctx[4]
    ) },
    exclude(
      /*$$props*/
      ctx[8],
      ["use", "class"]
    )
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      a3 = element("a");
      if (title_slot)
        title_slot.c();
      t2 = space();
      if (description_slot)
        description_slot.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { "data-step": true, class: true });
      var li_nodes = children(li);
      a3 = claim_element(li_nodes, "A", { href: true, class: true });
      var a_nodes = children(a3);
      if (title_slot)
        title_slot.l(a_nodes);
      t2 = claim_space(a_nodes);
      if (description_slot)
        description_slot.l(a_nodes);
      a_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(a3, a_data);
      attr(
        li,
        "data-step",
        /*step*/
        ctx[2]
      );
      attr(li, "class", "md:flex-1");
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, a3);
      if (title_slot) {
        title_slot.m(a3, null);
      }
      append_hydration(a3, t2);
      if (description_slot) {
        description_slot.m(a3, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            a3,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[5].call(null, a3)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_title_slot_changes_2
            ),
            get_title_slot_context_2
          );
        }
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_description_slot_changes_2
            ),
            get_description_slot_context_2
          );
        }
      }
      set_attributes(a3, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        (!current || dirty & /*finalClass*/
        16) && { class: (
          /*finalClass*/
          ctx2[4]
        ) },
        dirty & /*$$props*/
        256 && exclude(
          /*$$props*/
          ctx2[8],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      if (!current || dirty & /*step*/
      4) {
        attr(
          li,
          "data-step",
          /*step*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(description_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      transition_out(description_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (title_slot)
        title_slot.d(detaching);
      if (description_slot)
        description_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$7(ctx) {
  let li;
  let a3;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[10].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_title_slot_context_1
  );
  const description_slot_template = (
    /*#slots*/
    ctx[10].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_description_slot_context_1
  );
  let a_levels = [
    { href: (
      /*href*/
      ctx[1]
    ) },
    { class: (
      /*finalClass*/
      ctx[4]
    ) },
    exclude(
      /*$$props*/
      ctx[8],
      ["use", "class"]
    )
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      a3 = element("a");
      if (title_slot)
        title_slot.c();
      t2 = space();
      if (description_slot)
        description_slot.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { "data-step": true, class: true });
      var li_nodes = children(li);
      a3 = claim_element(li_nodes, "A", { href: true, class: true });
      var a_nodes = children(a3);
      if (title_slot)
        title_slot.l(a_nodes);
      t2 = claim_space(a_nodes);
      if (description_slot)
        description_slot.l(a_nodes);
      a_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(a3, a_data);
      attr(
        li,
        "data-step",
        /*step*/
        ctx[2]
      );
      attr(li, "class", "md:flex-1");
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, a3);
      if (title_slot) {
        title_slot.m(a3, null);
      }
      append_hydration(a3, t2);
      if (description_slot) {
        description_slot.m(a3, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            a3,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[5].call(null, a3)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_title_slot_changes_1
            ),
            get_title_slot_context_1
          );
        }
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_description_slot_changes_1
            ),
            get_description_slot_context_1
          );
        }
      }
      set_attributes(a3, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        (!current || dirty & /*finalClass*/
        16) && { class: (
          /*finalClass*/
          ctx2[4]
        ) },
        dirty & /*$$props*/
        256 && exclude(
          /*$$props*/
          ctx2[8],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      if (!current || dirty & /*step*/
      4) {
        attr(
          li,
          "data-step",
          /*step*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(description_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      transition_out(description_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (title_slot)
        title_slot.d(detaching);
      if (description_slot)
        description_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$c(ctx) {
  let li;
  let a3;
  let t2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const title_slot_template = (
    /*#slots*/
    ctx[10].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_title_slot_context$1
  );
  const description_slot_template = (
    /*#slots*/
    ctx[10].description
  );
  const description_slot = create_slot(
    description_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_description_slot_context
  );
  let a_levels = [
    { href: (
      /*href*/
      ctx[1]
    ) },
    { class: (
      /*finalClass*/
      ctx[4]
    ) },
    exclude(
      /*$$props*/
      ctx[8],
      ["use", "class"]
    )
  ];
  let a_data = {};
  for (let i2 = 0; i2 < a_levels.length; i2 += 1) {
    a_data = assign$1(a_data, a_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      a3 = element("a");
      if (title_slot)
        title_slot.c();
      t2 = space();
      if (description_slot)
        description_slot.c();
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", { "data-step": true, class: true });
      var li_nodes = children(li);
      a3 = claim_element(li_nodes, "A", { href: true, class: true });
      var a_nodes = children(a3);
      if (title_slot)
        title_slot.l(a_nodes);
      t2 = claim_space(a_nodes);
      if (description_slot)
        description_slot.l(a_nodes);
      a_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(a3, a_data);
      attr(
        li,
        "data-step",
        /*step*/
        ctx[2]
      );
      attr(li, "class", "md:flex-1");
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, a3);
      if (title_slot) {
        title_slot.m(a3, null);
      }
      append_hydration(a3, t2);
      if (description_slot) {
        description_slot.m(a3, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            a3,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[5].call(null, a3)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_title_slot_changes$1
            ),
            get_title_slot_context$1
          );
        }
      }
      if (description_slot) {
        if (description_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            description_slot,
            description_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              description_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_description_slot_changes
            ),
            get_description_slot_context
          );
        }
      }
      set_attributes(a3, a_data = get_spread_update(a_levels, [
        (!current || dirty & /*href*/
        2) && { href: (
          /*href*/
          ctx2[1]
        ) },
        (!current || dirty & /*finalClass*/
        16) && { class: (
          /*finalClass*/
          ctx2[4]
        ) },
        dirty & /*$$props*/
        256 && exclude(
          /*$$props*/
          ctx2[8],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      if (!current || dirty & /*step*/
      4) {
        attr(
          li,
          "data-step",
          /*step*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(title_slot, local);
      transition_in(description_slot, local);
      current = true;
    },
    o(local) {
      transition_out(title_slot, local);
      transition_out(description_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (title_slot)
        title_slot.d(detaching);
      if (description_slot)
        description_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$B(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$j, create_if_block_3$6, create_if_block_6$3, create_if_block_9$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*variant*/
      ctx2[7] === "simple"
    )
      return 0;
    if (
      /*variant*/
      ctx2[7] === "bullets"
    )
      return 1;
    if (
      /*variant*/
      ctx2[7] === "bullets-text"
    )
      return 2;
    if (
      /*variant*/
      ctx2[7] === "circles-text"
    )
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (if_block)
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
const bulletsPreviousStep = "block h-2.5 w-2.5 rounded-full bg-default hover:bg-default";
const bulletsCurrentStep = "relative flex items-center justify-center";
const bulletsNextStep = "block h-2.5 w-2.5 rounded-full bg-primary hover:bg-primary-hover";
const simplePreviousStep$2 = "group flex flex-col border-l-4 border-border hover:border-border py-2 pl-4 md:border-l-0 md:border-t-4 md:pl-0 md:pt-4 md:pb-0";
const simpleCurrentStep$1 = "flex flex-col border-l-4 border-primary py-2 pl-4 md:border-l-0 md:border-t-4 md:pl-0 md:pt-4 md:pb-0";
const simpleNextStep$1 = "group flex flex-col border-l-4 border-primary hover:border-primary-hover py-2 pl-4 md:border-l-0 md:border-t-4 md:pl-0 md:pt-4 md:pb-0";
function instance$z($$self, $$props, $$invalidate) {
  let finalClass;
  let $currentStep;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { href } = $$props;
  let { step } = $$props;
  const currentStep = getContext("steps-currentStep");
  component_subscribe($$self, currentStep, (value) => $$invalidate(3, $currentStep = value));
  const variant = getContext("steps-variant");
  setContext("steps-step", step);
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("href" in $$new_props)
      $$invalidate(1, href = $$new_props.href);
    if ("step" in $$new_props)
      $$invalidate(2, step = $$new_props.step);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(4, finalClass = twMerge(
      variant === "bullets" && $currentStep < step ? bulletsPreviousStep : false,
      variant === "bullets" && $currentStep === step ? bulletsCurrentStep : false,
      variant === "bullets" && $currentStep > step ? bulletsNextStep : false,
      variant === "simple" && $currentStep < step ? simplePreviousStep$2 : false,
      variant === "simple" && $currentStep === step ? simpleCurrentStep$1 : false,
      variant === "simple" && $currentStep > step ? simpleNextStep$1 : false,
      $$props.class
    ));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    href,
    step,
    $currentStep,
    finalClass,
    forwardEvents,
    currentStep,
    variant,
    $$props,
    $$scope,
    slots
  ];
}
class Step extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$z, create_fragment$B, safe_not_equal, { use: 0, href: 1, step: 2 });
  }
}
function create_if_block_9$1(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_10$1, create_if_block_11, create_else_block_3];
  const if_blocks = [];
  function select_block_type_4(ctx2, dirty) {
    if (
      /*$currentStep*/
      ctx2[1] > /*step*/
      ctx2[6]
    )
      return 0;
    if (
      /*$currentStep*/
      ctx2[1] === /*step*/
      ctx2[6]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_4(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_4(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_6$2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_7$2, create_if_block_8$2, create_else_block_2];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*$currentStep*/
      ctx2[1] > /*step*/
      ctx2[6]
    )
      return 0;
    if (
      /*$currentStep*/
      ctx2[1] === /*step*/
      ctx2[6]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_3(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block_3$5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4$4, create_if_block_5$4, create_else_block_1$1];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$currentStep*/
      ctx2[1] > /*step*/
      ctx2[6]
    )
      return 0;
    if (
      /*$currentStep*/
      ctx2[1] === /*step*/
      ctx2[6]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block$i(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$b, create_if_block_2$6, create_else_block$8];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$currentStep*/
      ctx2[1] > /*step*/
      ctx2[6]
    )
      return 0;
    if (
      /*$currentStep*/
      ctx2[1] === /*step*/
      ctx2[6]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block_3(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_11(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_10$1(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_2(ctx) {
  let p;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let p_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let p_data = {};
  for (let i2 = 0; i2 < p_levels.length; i2 += 1) {
    p_data = assign$1(p_data, p_levels[i2]);
  }
  return {
    c() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(p, p_data);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            p,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, p)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_8$2(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_7$2(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block_1$1(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_5$4(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4$4(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block$8(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$6(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$b(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$A(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$i, create_if_block_3$5, create_if_block_6$2, create_if_block_9$1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*variant*/
      ctx2[5] === "simple"
    )
      return 0;
    if (
      /*variant*/
      ctx2[5] === "bullets"
    )
      return 1;
    if (
      /*variant*/
      ctx2[5] === "bullets-text"
    )
      return 2;
    if (
      /*variant*/
      ctx2[5] === "circles-text"
    )
      return 3;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (if_block)
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
const bulletsTextNextStep = "ml-3 text-sm font-medium text-content";
const bulletsTextCurrentStep = "ml-3 text-sm font-medium text-primary";
const bulletsTextPreviousStep = "ml-3 text-sm font-medium text-secondary-content group-hover:text-content";
const circlesTextNextStep = "text-sm font-medium text-content";
const circlesTextCurrentStep = "text-sm font-medium text-primary";
const circlesTextPreviousStep = "text-sm font-medium text-secondary-content";
const simpleNextStep = "text-sm font-medium text-primary group-hover:text-primary-hover";
const simpleCurrentStep = "text-sm font-medium text-primary";
const simplePreviousStep$1 = "text-sm font-medium text-content";
function instance$y($$self, $$props, $$invalidate) {
  let finalClass;
  let $currentStep;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const currentStep = getContext("steps-currentStep");
  component_subscribe($$self, currentStep, (value) => $$invalidate(1, $currentStep = value));
  const variant = getContext("steps-variant");
  const step = getContext("steps-step");
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(2, finalClass = twMerge(
      variant === "bullets" ? "sr-only" : false,
      variant === "bullets-text" && $currentStep < step ? bulletsTextPreviousStep : false,
      variant === "bullets-text" && $currentStep === step ? bulletsTextCurrentStep : false,
      variant === "bullets-text" && $currentStep > step ? bulletsTextNextStep : false,
      variant === "circles-text" && $currentStep < step ? circlesTextPreviousStep : false,
      variant === "circles-text" && $currentStep === step ? circlesTextCurrentStep : false,
      variant === "circles-text" && $currentStep > step ? circlesTextNextStep : false,
      variant === "simple" && $currentStep < step ? simplePreviousStep$1 : false,
      variant === "simple" && $currentStep === step ? simpleCurrentStep : false,
      variant === "simple" && $currentStep > step ? simpleNextStep : false,
      $$props.class
    ));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    $currentStep,
    finalClass,
    forwardEvents,
    currentStep,
    variant,
    step,
    $$props,
    $$scope,
    slots
  ];
}
let Title$2 = class Title8 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$y, create_fragment$A, safe_not_equal, { use: 0 });
  }
};
function create_if_block_3$4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_4$3, create_if_block_5$3, create_else_block_1];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*$currentStep*/
      ctx2[1] > /*step*/
      ctx2[6]
    )
      return 0;
    if (
      /*$currentStep*/
      ctx2[1] === /*step*/
      ctx2[6]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_2(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_if_block$h(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1$a, create_if_block_2$5, create_else_block$7];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*$currentStep*/
      ctx2[1] > /*step*/
      ctx2[6]
    )
      return 0;
    if (
      /*$currentStep*/
      ctx2[1] === /*step*/
      ctx2[6]
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type_1(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block_1(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_5$3(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_4$3(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block$7(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2$5(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1$a(ctx) {
  let span;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let span_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    )
  ];
  let span_data = {};
  for (let i2 = 0; i2 < span_levels.length; i2 += 1) {
    span_data = assign$1(span_data, span_levels[i2]);
  }
  return {
    c() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(span, span_data);
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, span)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$z(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$h, create_if_block_3$4];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*variant*/
      ctx2[5] === "simple"
    )
      return 0;
    if (
      /*variant*/
      ctx2[5] === "circles-text"
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (if_block)
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
const circleStep = "text-sm text-secondary-content";
const simpleStep = "text-sm font-medium text-content";
const simplePreviousStep = "text-sm font-medium text-secondary-content";
function instance$x($$self, $$props, $$invalidate) {
  let finalClass;
  let $currentStep;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const currentStep = getContext("steps-currentStep");
  component_subscribe($$self, currentStep, (value) => $$invalidate(1, $currentStep = value));
  const variant = getContext("steps-variant");
  const step = getContext("steps-step");
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(2, finalClass = twMerge(
      variant === "circles-text" ? circleStep : false,
      variant === "simple" && $currentStep < step ? simplePreviousStep : variant === "simple" ? simpleStep : false,
      $$props.class
    ));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    $currentStep,
    finalClass,
    forwardEvents,
    currentStep,
    variant,
    step,
    $$props,
    $$scope,
    slots
  ];
}
class Description8 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$x, create_fragment$z, safe_not_equal, { use: 0 });
  }
}
function create_fragment$y(ctx) {
  let p;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let p_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let p_data = {};
  for (let i2 = 0; i2 < p_levels.length; i2 += 1) {
    p_data = assign$1(p_data, p_levels[i2]);
  }
  return {
    c() {
      p = element("p");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      if (default_slot)
        default_slot.l(p_nodes);
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(p, p_data);
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      if (default_slot) {
        default_slot.m(p, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            p,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, p)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(p, p_data = get_spread_update(p_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$d = "text-sm font-medium";
function instance$w($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$d, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
class Summary extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$w, create_fragment$y, safe_not_equal, { use: 0 });
  }
}
const Steps2 = Steps$1;
Steps2.Summary = Summary;
Steps2.Step = Step;
Steps2.Step.Title = Title$2;
Steps2.Step.Description = Description8;
const get_footer_slot_changes = (dirty) => ({});
const get_footer_slot_context = (ctx) => ({});
const get_body_slot_changes = (dirty) => ({});
const get_body_slot_context = (ctx) => ({});
const get_header_slot_changes = (dirty) => ({});
const get_header_slot_context = (ctx) => ({});
function create_fragment$x(ctx) {
  let div2;
  let t0;
  let t1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const header_slot_template = (
    /*#slots*/
    ctx[6].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_header_slot_context
  );
  const body_slot_template = (
    /*#slots*/
    ctx[6].body
  );
  const body_slot = create_slot(
    body_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_body_slot_context
  );
  const footer_slot_template = (
    /*#slots*/
    ctx[6].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    get_footer_slot_context
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (header_slot)
        header_slot.c();
      t0 = space();
      if (body_slot)
        body_slot.c();
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (header_slot)
        header_slot.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (body_slot)
        body_slot.l(div_nodes);
      t1 = claim_space(div_nodes);
      if (footer_slot)
        footer_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (header_slot) {
        header_slot.m(div2, null);
      }
      append_hydration(div2, t0);
      if (body_slot) {
        body_slot.m(div2, null);
      }
      append_hydration(div2, t1);
      if (footer_slot) {
        footer_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
      if (body_slot) {
        if (body_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            body_slot,
            body_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              body_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_body_slot_changes
            ),
            get_body_slot_context
          );
        }
      }
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              get_footer_slot_changes
            ),
            get_footer_slot_context
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      transition_in(body_slot, local);
      transition_in(footer_slot, local);
      current = true;
    },
    o(local) {
      transition_out(header_slot, local);
      transition_out(body_slot, local);
      transition_out(footer_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (header_slot)
        header_slot.d(detaching);
      if (body_slot)
        body_slot.d(detaching);
      if (footer_slot)
        footer_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$c = "bg-surface";
function instance$v($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { columns } = $$props;
  let header = writable(false);
  let footer = writable(false);
  let scrollbarWidth = writable(0);
  setContext("table-columns", columns);
  setContext("table-header", header);
  setContext("table-footer", footer);
  setContext("table-scrollbar-width", scrollbarWidth);
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("columns" in $$new_props)
      $$invalidate(4, columns = $$new_props.columns);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$c, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, columns, $$scope, slots];
}
let Table$1 = class Table extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$v, create_fragment$x, safe_not_equal, { use: 0, columns: 4 });
  }
};
const HeaderRow_svelte_svelte_type_style_lang = "";
function create_if_block$g(ctx) {
  let span;
  let icon;
  let current;
  icon = new Icon$7({ props: { data: sort } });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "sort-container flex-none rounded opacity-0 group-hover:opacity-100 group-focus:opacity-100 transition-transform hidden group-hover:block group-focus:block svelte-16vw4tg");
      toggle_class(
        span,
        "scale-y-flip",
        /*column*/
        ctx[0].column !== /*orderBy*/
        ctx[1] || /*column*/
        ctx[0].column === /*orderBy*/
        ctx[1] && /*order*/
        ctx[2] === "asc"
      );
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*column, orderBy, order*/
      7) {
        toggle_class(
          span,
          "scale-y-flip",
          /*column*/
          ctx2[0].column !== /*orderBy*/
          ctx2[1] || /*column*/
          ctx2[0].column === /*orderBy*/
          ctx2[1] && /*order*/
          ctx2[2] === "asc"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_fragment$w(ctx) {
  let th;
  let button;
  let span;
  let t0_value = (
    /*column*/
    ctx[0].label + ""
  );
  let t0;
  let t1;
  let button_aria_label_value;
  let th_class_value;
  let th_style_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*onColumnHeaderClick*/
    ctx[3] && create_if_block$g(ctx)
  );
  return {
    c() {
      th = element("th");
      button = element("button");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      th = claim_element(nodes, "TH", { class: true, style: true, scope: true });
      var th_nodes = children(th);
      button = claim_element(th_nodes, "BUTTON", {
        "aria-label": true,
        class: true,
        style: true
      });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, t0_value);
      span_nodes.forEach(detach);
      t1 = claim_space(button_nodes);
      if (if_block)
        if_block.l(button_nodes);
      button_nodes.forEach(detach);
      th_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "text-sm");
      attr(button, "aria-label", button_aria_label_value = /*column*/
      ctx[0].label + " column sort");
      attr(button, "class", "group inline-flex items-center text-secondary-content");
      set_style(button, "height", "24px");
      toggle_class(button, "cursor-default", !/*onColumnHeaderClick*/
      ctx[3]);
      attr(th, "class", th_class_value = null_to_empty(
        /*finalClass*/
        ctx[4]
      ) + " svelte-16vw4tg");
      attr(th, "style", th_style_value = /*$$props*/
      (ctx[7].style ? (
        /*$$props*/
        ctx[7].style
      ) : "") + /*column*/
      (ctx[0].class ? "" : ` width:${/*columnWidth*/
      ctx[5]}%`));
      attr(th, "scope", "col");
      toggle_class(
        th,
        "cursor-pointer",
        /*onColumnHeaderClick*/
        ctx[3]
      );
      toggle_class(th, "cursor-default", !/*onColumnHeaderClick*/
      ctx[3]);
      toggle_class(
        th,
        "active",
        /*column*/
        ctx[0].column === /*orderBy*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert_hydration(target, th, anchor);
      append_hydration(th, button);
      append_hydration(button, span);
      append_hydration(span, t0);
      append_hydration(button, t1);
      if (if_block)
        if_block.m(button, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          th,
          "click",
          /*handleClick*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*column*/
      1) && t0_value !== (t0_value = /*column*/
      ctx2[0].label + ""))
        set_data(t0, t0_value);
      if (
        /*onColumnHeaderClick*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*onColumnHeaderClick*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$g(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(button, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*column*/
      1 && button_aria_label_value !== (button_aria_label_value = /*column*/
      ctx2[0].label + " column sort")) {
        attr(button, "aria-label", button_aria_label_value);
      }
      if (!current || dirty & /*onColumnHeaderClick*/
      8) {
        toggle_class(button, "cursor-default", !/*onColumnHeaderClick*/
        ctx2[3]);
      }
      if (!current || dirty & /*finalClass*/
      16 && th_class_value !== (th_class_value = null_to_empty(
        /*finalClass*/
        ctx2[4]
      ) + " svelte-16vw4tg")) {
        attr(th, "class", th_class_value);
      }
      if (!current || dirty & /*$$props, column, columnWidth*/
      161 && th_style_value !== (th_style_value = /*$$props*/
      (ctx2[7].style ? (
        /*$$props*/
        ctx2[7].style
      ) : "") + /*column*/
      (ctx2[0].class ? "" : ` width:${/*columnWidth*/
      ctx2[5]}%`))) {
        attr(th, "style", th_style_value);
      }
      if (!current || dirty & /*finalClass, onColumnHeaderClick*/
      24) {
        toggle_class(
          th,
          "cursor-pointer",
          /*onColumnHeaderClick*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*finalClass, onColumnHeaderClick*/
      24) {
        toggle_class(th, "cursor-default", !/*onColumnHeaderClick*/
        ctx2[3]);
      }
      if (!current || dirty & /*finalClass, column, orderBy*/
      19) {
        toggle_class(
          th,
          "active",
          /*column*/
          ctx2[0].column === /*orderBy*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(th);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
const defaultClass$b = "sticky top-0 py-4 last:hover:active last:focus:active last:active:active first:pl-4 last:pl-3 last:pr-4 pr-3 last:sm:pr-6 text-sm sm:pl-6 box-border";
const rightClass$1 = "pl-3 pr-4 sm:pr-6 text-right last:text-right";
const leftClass$1 = "text-left";
const noPlacementClass$1 = "last:text-right";
function instance$u($$self, $$props, $$invalidate) {
  let columnWidth;
  let finalClass;
  let { column } = $$props;
  let { columnCount } = $$props;
  let { orderBy } = $$props;
  let { order: order2 = "asc" } = $$props;
  let { onColumnHeaderClick = void 0 } = $$props;
  function handleClick() {
    if (onColumnHeaderClick) {
      onColumnHeaderClick(column.column);
    }
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("column" in $$new_props)
      $$invalidate(0, column = $$new_props.column);
    if ("columnCount" in $$new_props)
      $$invalidate(8, columnCount = $$new_props.columnCount);
    if ("orderBy" in $$new_props)
      $$invalidate(1, orderBy = $$new_props.orderBy);
    if ("order" in $$new_props)
      $$invalidate(2, order2 = $$new_props.order);
    if ("onColumnHeaderClick" in $$new_props)
      $$invalidate(3, onColumnHeaderClick = $$new_props.onColumnHeaderClick);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*columnCount*/
    256) {
      $$invalidate(5, columnWidth = 100 / columnCount);
    }
    $$invalidate(4, finalClass = twMerge(
      defaultClass$b,
      column.class ? column.class : false,
      column.placement === "right" ? rightClass$1 : column.placement === "left" ? leftClass$1 : noPlacementClass$1,
      $$props.class
    ));
  };
  $$props = exclude_internal_props($$props);
  return [
    column,
    orderBy,
    order2,
    onColumnHeaderClick,
    finalClass,
    columnWidth,
    handleClick,
    $$props,
    columnCount
  ];
}
class HeaderRow extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$u, create_fragment$w, safe_not_equal, {
      column: 0,
      columnCount: 8,
      orderBy: 1,
      order: 2,
      onColumnHeaderClick: 3
    });
  }
}
function get_each_context$9(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  child_ctx[13] = i2;
  return child_ctx;
}
function create_each_block$9(ctx) {
  let headerrow;
  let current;
  headerrow = new HeaderRow({
    props: {
      classes: (
        /*index*/
        (ctx[13] !== 0 ? "hidden " : "") + "truncate md:table-cell"
      ),
      column: (
        /*column*/
        ctx[11]
      ),
      columnCount: (
        /*columns*/
        ctx[7].length
      ),
      order: (
        /*order*/
        ctx[2]
      ),
      orderBy: (
        /*orderBy*/
        ctx[1]
      ),
      onColumnHeaderClick: (
        /*onColumnHeaderClick*/
        ctx[3]
      )
    }
  });
  return {
    c() {
      create_component(headerrow.$$.fragment);
    },
    l(nodes) {
      claim_component(headerrow.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(headerrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const headerrow_changes = {};
      if (dirty & /*order*/
      4)
        headerrow_changes.order = /*order*/
        ctx2[2];
      if (dirty & /*orderBy*/
      2)
        headerrow_changes.orderBy = /*orderBy*/
        ctx2[1];
      if (dirty & /*onColumnHeaderClick*/
      8)
        headerrow_changes.onColumnHeaderClick = /*onColumnHeaderClick*/
        ctx2[3];
      headerrow.$set(headerrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(headerrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(headerrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(headerrow, detaching);
    }
  };
}
function create_fragment$v(ctx) {
  let table;
  let thead;
  let tr;
  let table_style_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*columns*/
    ctx[7]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$9(get_each_context$9(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let table_levels = [
    { class: (
      /*finalClass*/
      ctx[4]
    ) },
    {
      style: table_style_value = "padding-right:" + /*$scrollbarWidth*/
      ctx[5] + "px"
    },
    exclude(
      /*$$props*/
      ctx[9],
      ["use", "class"]
    )
  ];
  let table_data = {};
  for (let i2 = 0; i2 < table_levels.length; i2 += 1) {
    table_data = assign$1(table_data, table_levels[i2]);
  }
  return {
    c() {
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      this.h();
    },
    l(nodes) {
      table = claim_element(nodes, "TABLE", { class: true, style: true });
      var table_nodes = children(table);
      thead = claim_element(table_nodes, "THEAD", {});
      var thead_nodes = children(thead);
      tr = claim_element(thead_nodes, "TR", { class: true });
      var tr_nodes = children(tr);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(tr_nodes);
      }
      tr_nodes.forEach(detach);
      thead_nodes.forEach(detach);
      table_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(tr, "class", "table-row");
      set_attributes(table, table_data);
    },
    m(target, anchor) {
      insert_hydration(target, table, anchor);
      append_hydration(table, thead);
      append_hydration(thead, tr);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(tr, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            table,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[6].call(null, table)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*columns, order, orderBy, onColumnHeaderClick*/
      142) {
        each_value = ensure_array_like(
          /*columns*/
          ctx2[7]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$9(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$9(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(tr, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      set_attributes(table, table_data = get_spread_update(table_levels, [
        (!current || dirty & /*finalClass*/
        16) && { class: (
          /*finalClass*/
          ctx2[4]
        ) },
        (!current || dirty & /*$scrollbarWidth*/
        32 && table_style_value !== (table_style_value = "padding-right:" + /*$scrollbarWidth*/
        ctx2[5] + "px")) && { style: table_style_value },
        dirty & /*$$props*/
        512 && exclude(
          /*$$props*/
          ctx2[9],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(table);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$a = "flex-shrink table min-w-full border-separate border-spacing-0 table-fixed shadow-md bg-surface relative";
function instance$t($$self, $$props, $$invalidate) {
  let finalClass;
  let $scrollbarWidth;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { orderBy } = $$props;
  let { order: order2 = "asc" } = $$props;
  let { onColumnHeaderClick = void 0 } = $$props;
  const header = getContext("table-header");
  const columns = getContext("table-columns");
  const scrollbarWidth = getContext("table-scrollbar-width");
  component_subscribe($$self, scrollbarWidth, (value) => $$invalidate(5, $scrollbarWidth = value));
  header.set(true);
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("orderBy" in $$new_props)
      $$invalidate(1, orderBy = $$new_props.orderBy);
    if ("order" in $$new_props)
      $$invalidate(2, order2 = $$new_props.order);
    if ("onColumnHeaderClick" in $$new_props)
      $$invalidate(3, onColumnHeaderClick = $$new_props.onColumnHeaderClick);
  };
  $$self.$$.update = () => {
    $$invalidate(4, finalClass = twMerge(defaultClass$a, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    orderBy,
    order2,
    onColumnHeaderClick,
    finalClass,
    $scrollbarWidth,
    forwardEvents,
    columns,
    scrollbarWidth,
    $$props
  ];
}
class Header4 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$t, create_fragment$v, safe_not_equal, {
      use: 0,
      orderBy: 1,
      order: 2,
      onColumnHeaderClick: 3
    });
  }
}
function create_fragment$u(ctx) {
  let div2;
  let table;
  let tbody;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let table_levels = [
    { class: (
      /*finalClass*/
      ctx[3]
    ) },
    exclude(
      /*$$props*/
      ctx[8],
      ["use", "class"]
    )
  ];
  let table_data = {};
  for (let i2 = 0; i2 < table_levels.length; i2 += 1) {
    table_data = assign$1(table_data, table_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      table = element("table");
      tbody = element("tbody");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { id: true, class: true, style: true });
      var div_nodes = children(div2);
      table = claim_element(div_nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      tbody = claim_element(table_nodes, "TBODY", {});
      var tbody_nodes = children(tbody);
      if (default_slot)
        default_slot.l(tbody_nodes);
      tbody_nodes.forEach(detach);
      table_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(table, table_data);
      attr(
        div2,
        "id",
        /*id*/
        ctx[1]
      );
      attr(div2, "class", "overflow-y-auto overflow-x-hidden");
      set_style(div2, "height", "calc(100% - " + /*heightToRemove*/
      ctx[4] + "px)");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, table);
      append_hydration(table, tbody);
      if (default_slot) {
        default_slot.m(tbody, null);
      }
      ctx[11](div2);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            table,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[5].call(null, table)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(table, table_data = get_spread_update(table_levels, [
        (!current || dirty & /*finalClass*/
        8) && { class: (
          /*finalClass*/
          ctx2[3]
        ) },
        dirty & /*$$props*/
        256 && exclude(
          /*$$props*/
          ctx2[8],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      if (!current || dirty & /*id*/
      2) {
        attr(
          div2,
          "id",
          /*id*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*heightToRemove*/
      16) {
        set_style(div2, "height", "calc(100% - " + /*heightToRemove*/
        ctx2[4] + "px)");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[11](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$9 = "table min-w-full border-separate bg-surface border-spacing-0 table-fixed border-b border-border";
function instance$s($$self, $$props, $$invalidate) {
  let heightToRemove;
  let finalClass;
  let $scrollbarWidth;
  let $header;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { id = "table-body" } = $$props;
  let el;
  const header = getContext("table-header");
  component_subscribe($$self, header, (value) => $$invalidate(13, $header = value));
  const scrollbarWidth = getContext("table-scrollbar-width");
  component_subscribe($$self, scrollbarWidth, (value) => $$invalidate(12, $scrollbarWidth = value));
  let headerHeight = $header ? 61 : 0;
  onMount(() => {
    const isScrollable = el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;
    if (isScrollable) {
      set_store_value(scrollbarWidth, $scrollbarWidth = el.offsetWidth - el.clientWidth, $scrollbarWidth);
    } else {
      set_store_value(scrollbarWidth, $scrollbarWidth = 0, $scrollbarWidth);
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("id" in $$new_props)
      $$invalidate(1, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(3, finalClass = twMerge(defaultClass$9, $$props.class));
  };
  $$invalidate(4, heightToRemove = headerHeight + 64);
  $$props = exclude_internal_props($$props);
  return [
    use,
    id,
    el,
    finalClass,
    heightToRemove,
    forwardEvents,
    header,
    scrollbarWidth,
    $$props,
    $$scope,
    slots,
    div_binding
  ];
}
class Body2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$s, create_fragment$u, safe_not_equal, { use: 0, id: 1 });
  }
}
function create_key_block(ctx) {
  let tr;
  let tr_style_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  let tr_levels = [
    { id: (
      /*id*/
      ctx[1]
    ) },
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    {
      style: tr_style_value = "height: 48px; max-height: 48px;" + /*$$props*/
      ctx[4].style
    },
    exclude(
      /*$$props*/
      ctx[4],
      ["use", "class", "style"]
    )
  ];
  let tr_data = {};
  for (let i2 = 0; i2 < tr_levels.length; i2 += 1) {
    tr_data = assign$1(tr_data, tr_levels[i2]);
  }
  return {
    c() {
      tr = element("tr");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      tr = claim_element(nodes, "TR", { id: true, class: true, style: true });
      var tr_nodes = children(tr);
      if (default_slot)
        default_slot.l(tr_nodes);
      tr_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(tr, tr_data);
    },
    m(target, anchor) {
      insert_hydration(target, tr, anchor);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            tr,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[3].call(null, tr)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(tr, tr_data = get_spread_update(tr_levels, [
        (!current || dirty & /*id*/
        2) && { id: (
          /*id*/
          ctx2[1]
        ) },
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        (!current || dirty & /*$$props*/
        16 && tr_style_value !== (tr_style_value = "height: 48px; max-height: 48px;" + /*$$props*/
        ctx2[4].style)) && { style: tr_style_value },
        dirty & /*$$props*/
        16 && exclude(
          /*$$props*/
          ctx2[4],
          ["use", "class", "style"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(tr);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$t(ctx) {
  let previous_key = (
    /*id*/
    ctx[1]
  );
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    l(nodes) {
      key_block.l(nodes);
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert_hydration(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & /*id*/
      2 && safe_not_equal(previous_key, previous_key = /*id*/
      ctx2[1])) {
        group_outros();
        transition_out(key_block, 1, 1, noop$1);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(key_block_anchor);
      }
      key_block.d(detaching);
    }
  };
}
const defaultClass$8 = "table-row h-12 max-h-[3rem] cursor-pointer hover:bg-hover hover:bg-opacity-5 bg-surface";
function instance$r($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { id } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("id" in $$new_props)
      $$invalidate(1, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(5, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(2, finalClass = twMerge(defaultClass$8, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, id, finalClass, forwardEvents, $$props, $$scope, slots];
}
class Row extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$r, create_fragment$t, safe_not_equal, { use: 0, id: 1 });
  }
}
function create_fragment$s(ctx) {
  let td;
  let span;
  let td_style_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let td_levels = [
    { class: (
      /*finalClass*/
      ctx[2]
    ) },
    {
      style: td_style_value = /*$$props*/
      (ctx[6].style ? (
        /*$$props*/
        ctx[6].style
      ) : "") + /*columns*/
      (ctx[5][
        /*column*/
        ctx[1]
      ].class ? "" : ` width:${/*columnWidth*/
      ctx[3]}%`)
    },
    exclude(
      /*$$props*/
      ctx[6],
      ["use", "class", "style"]
    )
  ];
  let td_data = {};
  for (let i2 = 0; i2 < td_levels.length; i2 += 1) {
    td_data = assign$1(td_data, td_levels[i2]);
  }
  return {
    c() {
      td = element("td");
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      td = claim_element(nodes, "TD", { class: true, style: true });
      var td_nodes = children(td);
      span = claim_element(td_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach);
      td_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "block md:inline w-full static left-0 right-0 truncate");
      set_attributes(td, td_data);
    },
    m(target, anchor) {
      insert_hydration(target, td, anchor);
      append_hydration(td, span);
      if (default_slot) {
        default_slot.m(span, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            td,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[4].call(null, td)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(td, td_data = get_spread_update(td_levels, [
        (!current || dirty & /*finalClass*/
        4) && { class: (
          /*finalClass*/
          ctx2[2]
        ) },
        (!current || dirty & /*$$props, column, columnWidth*/
        74 && td_style_value !== (td_style_value = /*$$props*/
        (ctx2[6].style ? (
          /*$$props*/
          ctx2[6].style
        ) : "") + /*columns*/
        (ctx2[5][
          /*column*/
          ctx2[1]
        ].class ? "" : ` width:${/*columnWidth*/
        ctx2[3]}%`))) && { style: td_style_value },
        dirty & /*$$props*/
        64 && exclude(
          /*$$props*/
          ctx2[6],
          ["use", "class", "style"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(td);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$7 = "table-col first:pl-4 last:pl-3 last:pr-4 last:sm:pr-6 border-t truncate border-border py-2.5 pr-3 text-sm sm:pl-6 font-semibold md:font-normal text-secondary-content box-border";
const rightClass = "text-right pl-3 pr-4 sm:pr-6 last:text-right";
const leftClass = "text-left";
const noPlacementClass = "last:text-right";
function instance$q($$self, $$props, $$invalidate) {
  let columnWidth;
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { column } = $$props;
  const columns = getContext("table-columns");
  $$self.$$set = ($$new_props) => {
    $$invalidate(6, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("column" in $$new_props)
      $$invalidate(1, column = $$new_props.column);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(2, finalClass = twMerge(
      defaultClass$7,
      columns[column].class ? columns[column].class : false,
      columns[column].placement === "right" ? rightClass : columns[column].placement === "left" ? leftClass : noPlacementClass,
      $$props.class
    ));
  };
  $$invalidate(3, columnWidth = 100 / columns.length);
  $$props = exclude_internal_props($$props);
  return [
    use,
    column,
    finalClass,
    columnWidth,
    forwardEvents,
    columns,
    $$props,
    $$scope,
    slots
  ];
}
class Cell extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$q, create_fragment$s, safe_not_equal, { use: 0, column: 1 });
  }
}
function create_fragment$r(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$6 = "flex-shrink shadow-negative-md sticky bottom-0 bg-surface border-border border-t text-sm";
function instance$p($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const footer = getContext("table-footer");
  footer.set(true);
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$6, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
class Footer3 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$p, create_fragment$r, safe_not_equal, { use: 0 });
  }
}
const Table2 = Table$1;
Table2.Header = Header4;
Table2.Header.Row = HeaderRow;
Table2.Body = Body2;
Table2.Body.Row = Row;
Table2.Body.Row.Cell = Cell;
Table2.Footer = Footer3;
const get_label_slot_changes_1 = (dirty) => ({});
const get_label_slot_context_1 = (ctx) => ({});
const get_actions_slot_changes = (dirty) => ({});
const get_actions_slot_context = (ctx) => ({});
const get_pills_slot_changes = (dirty) => ({});
const get_pills_slot_context = (ctx) => ({});
const get_title_slot_changes = (dirty) => ({});
const get_title_slot_context = (ctx) => ({});
const get_label_slot_changes$1 = (dirty) => ({});
const get_label_slot_context$1 = (ctx) => ({});
function create_else_block$6(ctx) {
  let div1;
  let t0;
  let div0;
  let textarea_1;
  let div0_class_value;
  let t1;
  let div1_class_value;
  let div1_style_value;
  let current;
  let mounted;
  let dispose;
  const label_slot_template = (
    /*#slots*/
    ctx[12].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_label_slot_context_1
  );
  let if_block = (
    /*error*/
    ctx[2] && create_if_block_8$1(ctx)
  );
  return {
    c() {
      div1 = element("div");
      if (label_slot)
        label_slot.c();
      t0 = space();
      div0 = element("div");
      textarea_1 = element("textarea");
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      if (label_slot)
        label_slot.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      textarea_1 = claim_element(div0_nodes, "TEXTAREA", {
        rows: true,
        autocapitalize: true,
        autocomplete: true,
        name: true,
        id: true,
        class: true,
        placeholder: true
      });
      children(textarea_1).forEach(detach);
      div0_nodes.forEach(detach);
      t1 = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(textarea_1, "rows", "4");
      attr(
        textarea_1,
        "autocapitalize",
        /*autocapitalize*/
        ctx[5]
      );
      attr(
        textarea_1,
        "autocomplete",
        /*autocomplete*/
        ctx[4]
      );
      attr(
        textarea_1,
        "name",
        /*name*/
        ctx[1]
      );
      textarea_1.readOnly = /*readonly*/
      ctx[6];
      textarea_1.disabled = /*disabled*/
      ctx[7];
      attr(
        textarea_1,
        "id",
        /*name*/
        ctx[1]
      );
      attr(textarea_1, "class", "block w-full outline-none focus:outline-none sm:text-sm rounded-md placeholder-secondary-content placeholder-opacity-80");
      attr(
        textarea_1,
        "placeholder",
        /*placeholder*/
        ctx[3]
      );
      toggle_class(
        textarea_1,
        "border-danger",
        /*error*/
        ctx[2]
      );
      toggle_class(
        textarea_1,
        "text-danger",
        /*error*/
        ctx[2]
      );
      toggle_class(
        textarea_1,
        "placeholder-red-300",
        /*error*/
        ctx[2]
      );
      toggle_class(
        textarea_1,
        "focus:border-red-500",
        /*error*/
        ctx[2]
      );
      toggle_class(textarea_1, "focus:border-primary", !/*error*/
      ctx[2]);
      toggle_class(textarea_1, "border-border", !/*error*/
      ctx[2]);
      toggle_class(textarea_1, "bg-surface", !/*disabled*/
      ctx[7]);
      toggle_class(
        textarea_1,
        "bg-default",
        /*disabled*/
        ctx[7]
      );
      attr(div0, "class", div0_class_value = "mt-1 opacity-75=" + /*disabled*/
      ctx[7]);
      attr(div1, "class", div1_class_value = /*$$props*/
      ctx[10].class);
      attr(div1, "style", div1_style_value = /*$$props*/
      ctx[10].style);
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      if (label_slot) {
        label_slot.m(div1, null);
      }
      append_hydration(div1, t0);
      append_hydration(div1, div0);
      append_hydration(div0, textarea_1);
      ctx[15](textarea_1);
      set_input_value(
        textarea_1,
        /*value*/
        ctx[0]
      );
      append_hydration(div1, t1);
      if (if_block)
        if_block.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          textarea_1,
          "input",
          /*textarea_1_input_handler_1*/
          ctx[16]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_label_slot_changes_1
            ),
            get_label_slot_context_1
          );
        }
      }
      if (!current || dirty & /*autocapitalize*/
      32) {
        attr(
          textarea_1,
          "autocapitalize",
          /*autocapitalize*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*autocomplete*/
      16) {
        attr(
          textarea_1,
          "autocomplete",
          /*autocomplete*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*name*/
      2) {
        attr(
          textarea_1,
          "name",
          /*name*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*readonly*/
      64) {
        textarea_1.readOnly = /*readonly*/
        ctx2[6];
      }
      if (!current || dirty & /*disabled*/
      128) {
        textarea_1.disabled = /*disabled*/
        ctx2[7];
      }
      if (!current || dirty & /*name*/
      2) {
        attr(
          textarea_1,
          "id",
          /*name*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*placeholder*/
      8) {
        attr(
          textarea_1,
          "placeholder",
          /*placeholder*/
          ctx2[3]
        );
      }
      if (dirty & /*value*/
      1) {
        set_input_value(
          textarea_1,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          textarea_1,
          "border-danger",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          textarea_1,
          "text-danger",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          textarea_1,
          "placeholder-red-300",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          textarea_1,
          "focus:border-red-500",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(textarea_1, "focus:border-primary", !/*error*/
        ctx2[2]);
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(textarea_1, "border-border", !/*error*/
        ctx2[2]);
      }
      if (!current || dirty & /*disabled*/
      128) {
        toggle_class(textarea_1, "bg-surface", !/*disabled*/
        ctx2[7]);
      }
      if (!current || dirty & /*disabled*/
      128) {
        toggle_class(
          textarea_1,
          "bg-default",
          /*disabled*/
          ctx2[7]
        );
      }
      if (!current || dirty & /*disabled*/
      128 && div0_class_value !== (div0_class_value = "mt-1 opacity-75=" + /*disabled*/
      ctx2[7])) {
        attr(div0, "class", div0_class_value);
      }
      if (
        /*error*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*error*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_8$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*$$props*/
      1024 && div1_class_value !== (div1_class_value = /*$$props*/
      ctx2[10].class)) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*$$props*/
      1024 && div1_style_value !== (div1_style_value = /*$$props*/
      ctx2[10].style)) {
        attr(div1, "style", div1_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (label_slot)
        label_slot.d(detaching);
      ctx[15](null);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$f(ctx) {
  let div1;
  let t0;
  let div0;
  let t1;
  let label;
  let textContent = "Description";
  let t3;
  let textarea_1;
  let t4;
  let div0_class_value;
  let t5;
  let t6;
  let current;
  let mounted;
  let dispose;
  const label_slot_template = (
    /*#slots*/
    ctx[12].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_label_slot_context$1
  );
  const title_slot_template = (
    /*#slots*/
    ctx[12].title
  );
  const title_slot = create_slot(
    title_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_title_slot_context
  );
  let if_block0 = (
    /*$$slots*/
    (ctx[9].pills || /*$$slots*/
    ctx[9].actions) && create_if_block_5$2(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    (ctx[9].pills || /*$$slots*/
    ctx[9].actions) && create_if_block_2$4(ctx)
  );
  let if_block2 = (
    /*error*/
    ctx[2] && create_if_block_1$9(ctx)
  );
  return {
    c() {
      div1 = element("div");
      if (label_slot)
        label_slot.c();
      t0 = space();
      div0 = element("div");
      if (title_slot)
        title_slot.c();
      t1 = space();
      label = element("label");
      label.textContent = textContent;
      t3 = space();
      textarea_1 = element("textarea");
      t4 = space();
      if (if_block0)
        if_block0.c();
      t5 = space();
      if (if_block1)
        if_block1.c();
      t6 = space();
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (label_slot)
        label_slot.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (title_slot)
        title_slot.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      label = claim_element(div0_nodes, "LABEL", {
        for: true,
        class: true,
        ["data-svelte-h"]: true
      });
      if (get_svelte_dataset(label) !== "svelte-1ixtjkd")
        label.textContent = textContent;
      t3 = claim_space(div0_nodes);
      textarea_1 = claim_element(div0_nodes, "TEXTAREA", {
        rows: true,
        placeholder: true,
        autocapitalize: true,
        autocomplete: true,
        name: true,
        id: true,
        class: true
      });
      children(textarea_1).forEach(detach);
      t4 = claim_space(div0_nodes);
      if (if_block0)
        if_block0.l(div0_nodes);
      div0_nodes.forEach(detach);
      t5 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      t6 = claim_space(div1_nodes);
      if (if_block2)
        if_block2.l(div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(label, "for", "description");
      attr(label, "class", "sr-only");
      attr(textarea_1, "rows", "2");
      attr(
        textarea_1,
        "placeholder",
        /*placeholder*/
        ctx[3]
      );
      attr(
        textarea_1,
        "autocapitalize",
        /*autocapitalize*/
        ctx[5]
      );
      attr(
        textarea_1,
        "autocomplete",
        /*autocomplete*/
        ctx[4]
      );
      attr(
        textarea_1,
        "name",
        /*name*/
        ctx[1]
      );
      textarea_1.readOnly = /*readonly*/
      ctx[6];
      textarea_1.disabled = /*disabled*/
      ctx[7];
      attr(
        textarea_1,
        "id",
        /*name*/
        ctx[1]
      );
      attr(textarea_1, "class", "block bg-surface w-full resize-none border-0 py-0 focus:ring-0 sm:text-sm sm:leading-6 placeholder-secondary-content placeholder-opacity-80");
      toggle_class(textarea_1, "mb-2.5", !/*$$slots*/
      ctx[9].actions && !/*$$slots*/
      ctx[9].pills);
      toggle_class(textarea_1, "mt-2.5", !/*$$slots*/
      ctx[9].title);
      toggle_class(
        textarea_1,
        "placeholder-red-300",
        /*error*/
        ctx[2]
      );
      attr(div0, "class", div0_class_value = "mt-1 overflow-hidden rounded-md border w-full outline-none focus:outline-none sm:text-sm opacity-75=" + /*disabled*/
      ctx[7]);
      toggle_class(
        div0,
        "border-danger",
        /*error*/
        ctx[2]
      );
      toggle_class(
        div0,
        "text-danger",
        /*error*/
        ctx[2]
      );
      toggle_class(
        div0,
        "focus-within:border-red-500",
        /*error*/
        ctx[2]
      );
      toggle_class(div0, "focus-within:border-primary", !/*error*/
      ctx[2]);
      toggle_class(div0, "border-border", !/*error*/
      ctx[2]);
      toggle_class(div0, "bg-surface", !/*disabled*/
      ctx[7]);
      toggle_class(
        div0,
        "bg-default",
        /*disabled*/
        ctx[7]
      );
      attr(div1, "class", "relative");
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      if (label_slot) {
        label_slot.m(div1, null);
      }
      append_hydration(div1, t0);
      append_hydration(div1, div0);
      if (title_slot) {
        title_slot.m(div0, null);
      }
      append_hydration(div0, t1);
      append_hydration(div0, label);
      append_hydration(div0, t3);
      append_hydration(div0, textarea_1);
      ctx[13](textarea_1);
      set_input_value(
        textarea_1,
        /*value*/
        ctx[0]
      );
      append_hydration(div0, t4);
      if (if_block0)
        if_block0.m(div0, null);
      append_hydration(div1, t5);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration(div1, t6);
      if (if_block2)
        if_block2.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          textarea_1,
          "input",
          /*textarea_1_input_handler*/
          ctx[14]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_label_slot_changes$1
            ),
            get_label_slot_context$1
          );
        }
      }
      if (title_slot) {
        if (title_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            title_slot,
            title_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              title_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_title_slot_changes
            ),
            get_title_slot_context
          );
        }
      }
      if (!current || dirty & /*placeholder*/
      8) {
        attr(
          textarea_1,
          "placeholder",
          /*placeholder*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*autocapitalize*/
      32) {
        attr(
          textarea_1,
          "autocapitalize",
          /*autocapitalize*/
          ctx2[5]
        );
      }
      if (!current || dirty & /*autocomplete*/
      16) {
        attr(
          textarea_1,
          "autocomplete",
          /*autocomplete*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*name*/
      2) {
        attr(
          textarea_1,
          "name",
          /*name*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*readonly*/
      64) {
        textarea_1.readOnly = /*readonly*/
        ctx2[6];
      }
      if (!current || dirty & /*disabled*/
      128) {
        textarea_1.disabled = /*disabled*/
        ctx2[7];
      }
      if (!current || dirty & /*name*/
      2) {
        attr(
          textarea_1,
          "id",
          /*name*/
          ctx2[1]
        );
      }
      if (dirty & /*value*/
      1) {
        set_input_value(
          textarea_1,
          /*value*/
          ctx2[0]
        );
      }
      if (!current || dirty & /*$$slots*/
      512) {
        toggle_class(textarea_1, "mb-2.5", !/*$$slots*/
        ctx2[9].actions && !/*$$slots*/
        ctx2[9].pills);
      }
      if (!current || dirty & /*$$slots*/
      512) {
        toggle_class(textarea_1, "mt-2.5", !/*$$slots*/
        ctx2[9].title);
      }
      if (!current || dirty & /*error*/
      4) {
        toggle_class(
          textarea_1,
          "placeholder-red-300",
          /*error*/
          ctx2[2]
        );
      }
      if (
        /*$$slots*/
        ctx2[9].pills || /*$$slots*/
        ctx2[9].actions
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_5$2(ctx2);
          if_block0.c();
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty & /*disabled*/
      128 && div0_class_value !== (div0_class_value = "mt-1 overflow-hidden rounded-md border w-full outline-none focus:outline-none sm:text-sm opacity-75=" + /*disabled*/
      ctx2[7])) {
        attr(div0, "class", div0_class_value);
      }
      if (!current || dirty & /*disabled, error*/
      132) {
        toggle_class(
          div0,
          "border-danger",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*disabled, error*/
      132) {
        toggle_class(
          div0,
          "text-danger",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*disabled, error*/
      132) {
        toggle_class(
          div0,
          "focus-within:border-red-500",
          /*error*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*disabled, error*/
      132) {
        toggle_class(div0, "focus-within:border-primary", !/*error*/
        ctx2[2]);
      }
      if (!current || dirty & /*disabled, error*/
      132) {
        toggle_class(div0, "border-border", !/*error*/
        ctx2[2]);
      }
      if (!current || dirty & /*disabled, disabled*/
      128) {
        toggle_class(div0, "bg-surface", !/*disabled*/
        ctx2[7]);
      }
      if (!current || dirty & /*disabled, disabled*/
      128) {
        toggle_class(
          div0,
          "bg-default",
          /*disabled*/
          ctx2[7]
        );
      }
      if (
        /*$$slots*/
        ctx2[9].pills || /*$$slots*/
        ctx2[9].actions
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          512) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2$4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t6);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*error*/
        ctx2[2]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*error*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1$9(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(title_slot, local);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      transition_out(title_slot, local);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (label_slot)
        label_slot.d(detaching);
      if (title_slot)
        title_slot.d(detaching);
      ctx[13](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_8$1(ctx) {
  let p;
  let t2;
  let p_id_value;
  let p_transition;
  let current;
  return {
    c() {
      p = element("p");
      t2 = text(
        /*error*/
        ctx[2]
      );
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true, id: true });
      var p_nodes = children(p);
      t2 = claim_text(
        p_nodes,
        /*error*/
        ctx[2]
      );
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(p, "class", "mt-2 text-sm text-danger");
      attr(p, "id", p_id_value = /*name*/
      ctx[1] + "-error");
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      append_hydration(p, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*error*/
      4)
        set_data(
          t2,
          /*error*/
          ctx2[2]
        );
      if (!current || dirty & /*name*/
      2 && p_id_value !== (p_id_value = /*name*/
      ctx2[1] + "-error")) {
        attr(p, "id", p_id_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!p_transition)
            p_transition = create_bidirectional_transition(p, slide, {}, true);
          p_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!p_transition)
          p_transition = create_bidirectional_transition(p, slide, {}, false);
        p_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (detaching && p_transition)
        p_transition.end();
    }
  };
}
function create_if_block_5$2(ctx) {
  let div2;
  let t2;
  let if_block0 = (
    /*$$slots*/
    ctx[9].pills && create_if_block_7$1()
  );
  let if_block1 = (
    /*$$slots*/
    ctx[9].actions && create_if_block_6$1()
  );
  return {
    c() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { "aria-hidden": true });
      var div_nodes = children(div2);
      if (if_block0)
        if_block0.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append_hydration(div2, t2);
      if (if_block1)
        if_block1.m(div2, null);
    },
    p(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[9].pills
      ) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_7$1();
          if_block0.c();
          if_block0.m(div2, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*$$slots*/
        ctx2[9].actions
      ) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block_6$1();
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_7$1(ctx) {
  let div1;
  let textContent = `<div class="h-9"></div>`;
  return {
    c() {
      div1 = element("div");
      div1.innerHTML = textContent;
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(div1) !== "svelte-ydeluv")
        div1.innerHTML = textContent;
      this.h();
    },
    h() {
      attr(div1, "class", "py-2");
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
    }
  };
}
function create_if_block_6$1(ctx) {
  let div0;
  let t2;
  let div3;
  let textContent = `<div class="py-px"><div class="h-9"></div></div>`;
  return {
    c() {
      div0 = element("div");
      t2 = space();
      div3 = element("div");
      div3.innerHTML = textContent;
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", { class: true });
      children(div0).forEach(detach);
      t2 = claim_space(nodes);
      div3 = claim_element(nodes, "DIV", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(div3) !== "svelte-1wdtl94")
        div3.innerHTML = textContent;
      this.h();
    },
    h() {
      attr(div0, "class", "h-px");
      attr(div3, "class", "py-2");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, div3, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t2);
        detach(div3);
      }
    }
  };
}
function create_if_block_2$4(ctx) {
  let div2;
  let t2;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx[9].pills && create_if_block_4$2(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    ctx[9].actions && create_if_block_3$3(ctx)
  );
  return {
    c() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (if_block0)
        if_block0.l(div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block1)
        if_block1.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "absolute inset-x-px bottom-0");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append_hydration(div2, t2);
      if (if_block1)
        if_block1.m(div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[9].pills
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          512) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$2(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[9].actions
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          512) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3$3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
}
function create_if_block_4$2(ctx) {
  let current;
  const pills_slot_template = (
    /*#slots*/
    ctx[12].pills
  );
  const pills_slot = create_slot(
    pills_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_pills_slot_context
  );
  return {
    c() {
      if (pills_slot)
        pills_slot.c();
    },
    l(nodes) {
      if (pills_slot)
        pills_slot.l(nodes);
    },
    m(target, anchor) {
      if (pills_slot) {
        pills_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (pills_slot) {
        if (pills_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            pills_slot,
            pills_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              pills_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_pills_slot_changes
            ),
            get_pills_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(pills_slot, local);
      current = true;
    },
    o(local) {
      transition_out(pills_slot, local);
      current = false;
    },
    d(detaching) {
      if (pills_slot)
        pills_slot.d(detaching);
    }
  };
}
function create_if_block_3$3(ctx) {
  let current;
  const actions_slot_template = (
    /*#slots*/
    ctx[12].actions
  );
  const actions_slot = create_slot(
    actions_slot_template,
    ctx,
    /*$$scope*/
    ctx[11],
    get_actions_slot_context
  );
  return {
    c() {
      if (actions_slot)
        actions_slot.c();
    },
    l(nodes) {
      if (actions_slot)
        actions_slot.l(nodes);
    },
    m(target, anchor) {
      if (actions_slot) {
        actions_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (actions_slot) {
        if (actions_slot.p && (!current || dirty & /*$$scope*/
        2048)) {
          update_slot_base(
            actions_slot,
            actions_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[11],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[11]
            ) : get_slot_changes(
              actions_slot_template,
              /*$$scope*/
              ctx2[11],
              dirty,
              get_actions_slot_changes
            ),
            get_actions_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(actions_slot, local);
      current = true;
    },
    o(local) {
      transition_out(actions_slot, local);
      current = false;
    },
    d(detaching) {
      if (actions_slot)
        actions_slot.d(detaching);
    }
  };
}
function create_if_block_1$9(ctx) {
  let p;
  let t2;
  let p_id_value;
  let p_transition;
  let current;
  return {
    c() {
      p = element("p");
      t2 = text(
        /*error*/
        ctx[2]
      );
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true, id: true });
      var p_nodes = children(p);
      t2 = claim_text(
        p_nodes,
        /*error*/
        ctx[2]
      );
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(p, "class", "mt-2 text-sm text-danger");
      attr(p, "id", p_id_value = /*name*/
      ctx[1] + "-error");
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      append_hydration(p, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*error*/
      4)
        set_data(
          t2,
          /*error*/
          ctx2[2]
        );
      if (!current || dirty & /*name*/
      2 && p_id_value !== (p_id_value = /*name*/
      ctx2[1] + "-error")) {
        attr(p, "id", p_id_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!p_transition)
            p_transition = create_bidirectional_transition(p, slide, {}, true);
          p_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!p_transition)
          p_transition = create_bidirectional_transition(p, slide, {}, false);
        p_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (detaching && p_transition)
        p_transition.end();
    }
  };
}
function create_fragment$q(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$f, create_else_block$6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[9].title || /*$$slots*/
      ctx2[9].pills || /*$$slots*/
      ctx2[9].actions
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { name } = $$props;
  let { error: error2 = void 0 } = $$props;
  let { placeholder = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { autocomplete = void 0 } = $$props;
  let { autocapitalize = "off" } = $$props;
  let { readonly = false } = $$props;
  let { disabled = false } = $$props;
  let textarea;
  let currentError = writable(error2);
  setContext("textarea-error", currentError);
  setContext("textarea-name", name);
  function textarea_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      textarea = $$value;
      $$invalidate(8, textarea);
    });
  }
  function textarea_1_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  function textarea_1_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      textarea = $$value;
      $$invalidate(8, textarea);
    });
  }
  function textarea_1_input_handler_1() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(10, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("name" in $$new_props)
      $$invalidate(1, name = $$new_props.name);
    if ("error" in $$new_props)
      $$invalidate(2, error2 = $$new_props.error);
    if ("placeholder" in $$new_props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("autocomplete" in $$new_props)
      $$invalidate(4, autocomplete = $$new_props.autocomplete);
    if ("autocapitalize" in $$new_props)
      $$invalidate(5, autocapitalize = $$new_props.autocapitalize);
    if ("readonly" in $$new_props)
      $$invalidate(6, readonly = $$new_props.readonly);
    if ("disabled" in $$new_props)
      $$invalidate(7, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(11, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*error*/
    4) {
      currentError.set(error2);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    name,
    error2,
    placeholder,
    autocomplete,
    autocapitalize,
    readonly,
    disabled,
    textarea,
    $$slots,
    $$props,
    $$scope,
    slots,
    textarea_1_binding,
    textarea_1_input_handler,
    textarea_1_binding_1,
    textarea_1_input_handler_1
  ];
}
let TextArea$1 = class TextArea extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$o, create_fragment$q, safe_not_equal, {
      name: 1,
      error: 2,
      placeholder: 3,
      value: 0,
      autocomplete: 4,
      autocapitalize: 5,
      readonly: 6,
      disabled: 7
    });
  }
};
function create_fragment$p(ctx) {
  let label;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let label_levels = [
    { for: (
      /*name*/
      ctx[3]
    ) },
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[5],
      ["use", "class"]
    )
  ];
  let label_data = {};
  for (let i2 = 0; i2 < label_levels.length; i2 += 1) {
    label_data = assign$1(label_data, label_levels[i2]);
  }
  return {
    c() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      label = claim_element(nodes, "LABEL", { for: true, class: true });
      var label_nodes = children(label);
      if (default_slot)
        default_slot.l(label_nodes);
      label_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(label, label_data);
    },
    m(target, anchor) {
      insert_hydration(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            label,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, label)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        { for: (
          /*name*/
          ctx2[3]
        ) },
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        32 && exclude(
          /*$$props*/
          ctx2[5],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$5 = "block text-sm font-medium text-secondary-content";
const errorClass$1 = "text-danger";
function instance$n($$self, $$props, $$invalidate) {
  let finalClass;
  let $error;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const name = getContext("textarea-name");
  const error2 = getContext("textarea-error");
  component_subscribe($$self, error2, (value) => $$invalidate(6, $error = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$5, $error && $error.length > 0 ? errorClass$1 : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, name, error2, $$props, $error, $$scope, slots];
}
let Label$1 = class Label11 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$n, create_fragment$p, safe_not_equal, { use: 0 });
  }
};
function create_fragment$o(ctx) {
  let div2;
  let t0;
  let label;
  let t1;
  let t2;
  let input;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  let input_levels = [
    { type: "text" },
    { name: (
      /*name*/
      ctx[2]
    ) },
    { id: (
      /*name*/
      ctx[2]
    ) },
    { placeholder: (
      /*placeholder*/
      ctx[3]
    ) },
    {
      autocapitalize: (
        /*autocapitalize*/
        ctx[5]
      )
    },
    { autocomplete: (
      /*autocomplete*/
      ctx[4]
    ) },
    { readOnly: (
      /*readonly*/
      ctx[6]
    ) },
    { tabindex: (
      /*tabindex*/
      ctx[7]
    ) },
    { disabled: (
      /*disabled*/
      ctx[8]
    ) },
    { class: (
      /*finalClass*/
      ctx[9]
    ) },
    exclude(
      /*$$props*/
      ctx[11],
      ["use", "class"]
    )
  ];
  let input_data = {};
  for (let i2 = 0; i2 < input_levels.length; i2 += 1) {
    input_data = assign$1(input_data, input_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      t0 = space();
      label = element("label");
      t1 = text("Title");
      t2 = space();
      input = element("input");
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      t0 = claim_space(nodes);
      label = claim_element(nodes, "LABEL", { for: true, class: true });
      var label_nodes = children(label);
      t1 = claim_text(label_nodes, "Title");
      label_nodes.forEach(detach);
      t2 = claim_space(nodes);
      input = claim_element(nodes, "INPUT", {
        type: true,
        name: true,
        id: true,
        placeholder: true,
        autocapitalize: true,
        autocomplete: true,
        tabindex: true,
        class: true
      });
      this.h();
    },
    h() {
      attr(
        label,
        "for",
        /*name*/
        ctx[2]
      );
      attr(label, "class", "sr-only");
      set_attributes(input, input_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      insert_hydration(target, t0, anchor);
      insert_hydration(target, label, anchor);
      append_hydration(label, t1);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, input, anchor);
      if (input.autofocus)
        input.focus();
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[14]
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            input,
            /*use*/
            ctx[1]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[10].call(null, input)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*name*/
      4) {
        attr(
          label,
          "for",
          /*name*/
          ctx2[2]
        );
      }
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "text" },
        (!current || dirty & /*name*/
        4) && { name: (
          /*name*/
          ctx2[2]
        ) },
        (!current || dirty & /*name*/
        4) && { id: (
          /*name*/
          ctx2[2]
        ) },
        (!current || dirty & /*placeholder*/
        8) && { placeholder: (
          /*placeholder*/
          ctx2[3]
        ) },
        (!current || dirty & /*autocapitalize*/
        32) && {
          autocapitalize: (
            /*autocapitalize*/
            ctx2[5]
          )
        },
        (!current || dirty & /*autocomplete*/
        16) && { autocomplete: (
          /*autocomplete*/
          ctx2[4]
        ) },
        (!current || dirty & /*readonly*/
        64) && { readOnly: (
          /*readonly*/
          ctx2[6]
        ) },
        (!current || dirty & /*tabindex*/
        128) && { tabindex: (
          /*tabindex*/
          ctx2[7]
        ) },
        (!current || dirty & /*disabled*/
        256) && { disabled: (
          /*disabled*/
          ctx2[8]
        ) },
        (!current || dirty & /*finalClass*/
        512) && { class: (
          /*finalClass*/
          ctx2[9]
        ) },
        dirty & /*$$props*/
        2048 && exclude(
          /*$$props*/
          ctx2[11],
          ["use", "class"]
        )
      ]));
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      2)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[1]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t0);
        detach(label);
        detach(t2);
        detach(input);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$4 = "block w-full bg-surface border-0 pt-2.5 text-lg font-medium placeholder-secondary-content placeholder-opacity-80 focus:ring-0";
function instance$m($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { name } = $$props;
  let { placeholder = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { autocomplete = void 0 } = $$props;
  let { autocapitalize = "off" } = $$props;
  let { readonly = void 0 } = $$props;
  let { tabindex = void 0 } = $$props;
  let { disabled = false } = $$props;
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(11, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("name" in $$new_props)
      $$invalidate(2, name = $$new_props.name);
    if ("placeholder" in $$new_props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("autocomplete" in $$new_props)
      $$invalidate(4, autocomplete = $$new_props.autocomplete);
    if ("autocapitalize" in $$new_props)
      $$invalidate(5, autocapitalize = $$new_props.autocapitalize);
    if ("readonly" in $$new_props)
      $$invalidate(6, readonly = $$new_props.readonly);
    if ("tabindex" in $$new_props)
      $$invalidate(7, tabindex = $$new_props.tabindex);
    if ("disabled" in $$new_props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(9, finalClass = twMerge(defaultClass$4, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    use,
    name,
    placeholder,
    autocomplete,
    autocapitalize,
    readonly,
    tabindex,
    disabled,
    finalClass,
    forwardEvents,
    $$props,
    $$scope,
    slots,
    input_input_handler
  ];
}
let Title$1 = class Title9 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$m, create_fragment$o, safe_not_equal, {
      use: 1,
      name: 2,
      placeholder: 3,
      value: 0,
      autocomplete: 4,
      autocapitalize: 5,
      readonly: 6,
      tabindex: 7,
      disabled: 8
    });
  }
};
function create_fragment$n(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$3 = "flex flex-nowrap justify-end space-x-2 px-2 py-2 sm:px-3";
function instance$l($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$3, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
class Pills extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$l, create_fragment$n, safe_not_equal, { use: 0 });
  }
}
function create_fragment$m(ctx) {
  let div2;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  let div_levels = [
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[3],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        8 && exclude(
          /*$$props*/
          ctx2[3],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$2 = "flex items-center justify-between space-x-3 border-t border-border px-2 py-2 sm:px-3";
function instance$k($$self, $$props, $$invalidate) {
  let finalClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(3, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(4, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$2, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, $$props, $$scope, slots];
}
class Actions2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$k, create_fragment$m, safe_not_equal, { use: 0 });
  }
}
const TextArea2 = TextArea$1;
TextArea2.Label = Label$1;
TextArea2.Title = Title$1;
TextArea2.Pills = Pills;
TextArea2.Actions = Actions2;
function create_fragment$l(ctx) {
  let div2;
  let ul;
  let div_class_value;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    {
      class: div_class_value = "flow-root" + /*$$props*/
      (ctx[2].class ? ` ${/*$$props*/
      ctx[2].class}` : "")
    },
    exclude(
      /*$$props*/
      ctx[2],
      ["use", "class"]
    )
  ];
  let div_data = {};
  for (let i2 = 0; i2 < div_levels.length; i2 += 1) {
    div_data = assign$1(div_data, div_levels[i2]);
  }
  return {
    c() {
      div2 = element("div");
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      ul = claim_element(div_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(ul, "class", "-mb-8");
      set_attributes(div2, div_data);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, ul);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[1].call(null, div2)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div2, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*$$props*/
        4 && div_class_value !== (div_class_value = "flow-root" + /*$$props*/
        (ctx2[2].class ? ` ${/*$$props*/
        ctx2[2].class}` : ""))) && { class: div_class_value },
        dirty & /*$$props*/
        4 && exclude(
          /*$$props*/
          ctx2[2],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  $$self.$$set = ($$new_props) => {
    $$invalidate(2, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$props = exclude_internal_props($$props);
  return [use, forwardEvents, $$props, $$scope, slots];
}
let Timeline$1 = class Timeline extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$j, create_fragment$l, safe_not_equal, { use: 0 });
  }
};
const Item_svelte_svelte_type_style_lang = "";
function create_else_block$5(ctx) {
  let li;
  let div6;
  let span0;
  let t0;
  let div5;
  let div2;
  let div1;
  let div0;
  let span1;
  let icon_1;
  let t1;
  let div4;
  let div3;
  let html_tag;
  let t2;
  let span2;
  let t3_value = formatDate(
    /*created*/
    ctx[4]
  ) + "";
  let t3;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  icon_1 = new Icon$7({ props: { data: (
    /*icon*/
    ctx[6]
  ) } });
  let li_levels = [exclude(
    /*$$props*/
    ctx[8],
    ["use"]
  )];
  let li_data = {};
  for (let i2 = 0; i2 < li_levels.length; i2 += 1) {
    li_data = assign$1(li_data, li_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      div6 = element("div");
      span0 = element("span");
      t0 = space();
      div5 = element("div");
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      span1 = element("span");
      create_component(icon_1.$$.fragment);
      t1 = space();
      div4 = element("div");
      div3 = element("div");
      html_tag = new HtmlTagHydration(false);
      t2 = space();
      span2 = element("span");
      t3 = text(t3_value);
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      div6 = claim_element(li_nodes, "DIV", { class: true });
      var div6_nodes = children(div6);
      span0 = claim_element(div6_nodes, "SPAN", { class: true });
      children(span0).forEach(detach);
      t0 = claim_space(div6_nodes);
      div5 = claim_element(div6_nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      div2 = claim_element(div5_nodes, "DIV", {});
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      span1 = claim_element(div0_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      claim_component(icon_1.$$.fragment, span1_nodes);
      span1_nodes.forEach(detach);
      div0_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      t1 = claim_space(div5_nodes);
      div4 = claim_element(div5_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      html_tag = claim_html_tag(div3_nodes, false);
      t2 = claim_space(div3_nodes);
      span2 = claim_element(div3_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      t3 = claim_text(span2_nodes, t3_value);
      span2_nodes.forEach(detach);
      div3_nodes.forEach(detach);
      div4_nodes.forEach(detach);
      div5_nodes.forEach(detach);
      div6_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "class", "divider absolute top-5 left-5 -ml-px h-full w-0.5 bg-default svelte-1xpiqas");
      attr(span1, "class", "text-content");
      attr(div0, "class", "flex h-8 w-8 items-center justify-center rounded-full bg-default ring-8 ring-surface");
      attr(div1, "class", "relative px-1");
      html_tag.a = t2;
      attr(span2, "class", "whitespace-nowrap ml-1");
      attr(div3, "class", "text-sm text-secondary-content");
      attr(div4, "class", "min-w-0 flex-1 py-1.5");
      attr(div5, "class", "relative flex items-start space-x-3");
      attr(div6, "class", "relative pb-8");
      set_attributes(li, li_data);
      toggle_class(li, "svelte-1xpiqas", true);
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, div6);
      append_hydration(div6, span0);
      append_hydration(div6, t0);
      append_hydration(div6, div5);
      append_hydration(div5, div2);
      append_hydration(div2, div1);
      append_hydration(div1, div0);
      append_hydration(div0, span1);
      mount_component(icon_1, span1, null);
      append_hydration(div5, t1);
      append_hydration(div5, div4);
      append_hydration(div4, div3);
      html_tag.m(
        /*description*/
        ctx[5],
        div3
      );
      append_hydration(div3, t2);
      append_hydration(div3, span2);
      append_hydration(span2, t3);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            li,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[7].call(null, li)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const icon_1_changes = {};
      if (dirty & /*icon*/
      64)
        icon_1_changes.data = /*icon*/
        ctx2[6];
      icon_1.$set(icon_1_changes);
      if (!current || dirty & /*description*/
      32)
        html_tag.p(
          /*description*/
          ctx2[5]
        );
      if ((!current || dirty & /*created*/
      16) && t3_value !== (t3_value = formatDate(
        /*created*/
        ctx2[4]
      ) + ""))
        set_data(t3, t3_value);
      set_attributes(li, li_data = get_spread_update(li_levels, [dirty & /*$$props*/
      256 && exclude(
        /*$$props*/
        ctx2[8],
        ["use"]
      )]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(li, "svelte-1xpiqas", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      destroy_component(icon_1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$e(ctx) {
  let li;
  let div6;
  let span0;
  let t0;
  let div5;
  let div0;
  let avatar_1;
  let t1;
  let span2;
  let span1;
  let icon_1;
  let t2;
  let div4;
  let div2;
  let div1;
  let span3;
  let t3;
  let t4;
  let p0;
  let t5;
  let t6_value = formatDate(
    /*created*/
    ctx[4]
  ) + "";
  let t6;
  let t7;
  let div3;
  let p1;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  avatar_1 = new Avatar$6({
    props: {
      src: (
        /*avatar*/
        ctx[2]
      ),
      alt: "user-avatar",
      size: "md",
      class: "ring-8 ring-surface"
    }
  });
  icon_1 = new Icon$7({
    props: {
      data: comment,
      size: "16px",
      class: "scale-x-[-1]"
    }
  });
  let li_levels = [exclude(
    /*$$props*/
    ctx[8],
    ["use"]
  )];
  let li_data = {};
  for (let i2 = 0; i2 < li_levels.length; i2 += 1) {
    li_data = assign$1(li_data, li_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      div6 = element("div");
      span0 = element("span");
      t0 = space();
      div5 = element("div");
      div0 = element("div");
      create_component(avatar_1.$$.fragment);
      t1 = space();
      span2 = element("span");
      span1 = element("span");
      create_component(icon_1.$$.fragment);
      t2 = space();
      div4 = element("div");
      div2 = element("div");
      div1 = element("div");
      span3 = element("span");
      t3 = text(
        /*creator*/
        ctx[3]
      );
      t4 = space();
      p0 = element("p");
      t5 = text("Commented ");
      t6 = text(t6_value);
      t7 = space();
      div3 = element("div");
      p1 = element("p");
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", {});
      var li_nodes = children(li);
      div6 = claim_element(li_nodes, "DIV", { class: true });
      var div6_nodes = children(div6);
      span0 = claim_element(div6_nodes, "SPAN", { class: true });
      children(span0).forEach(detach);
      t0 = claim_space(div6_nodes);
      div5 = claim_element(div6_nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      div0 = claim_element(div5_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      claim_component(avatar_1.$$.fragment, div0_nodes);
      t1 = claim_space(div0_nodes);
      span2 = claim_element(div0_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      span1 = claim_element(span2_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      claim_component(icon_1.$$.fragment, span1_nodes);
      span1_nodes.forEach(detach);
      span2_nodes.forEach(detach);
      div0_nodes.forEach(detach);
      t2 = claim_space(div5_nodes);
      div4 = claim_element(div5_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div2 = claim_element(div4_nodes, "DIV", {});
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      span3 = claim_element(div1_nodes, "SPAN", { class: true });
      var span3_nodes = children(span3);
      t3 = claim_text(
        span3_nodes,
        /*creator*/
        ctx[3]
      );
      span3_nodes.forEach(detach);
      div1_nodes.forEach(detach);
      t4 = claim_space(div2_nodes);
      p0 = claim_element(div2_nodes, "P", { class: true });
      var p0_nodes = children(p0);
      t5 = claim_text(p0_nodes, "Commented ");
      t6 = claim_text(p0_nodes, t6_value);
      p0_nodes.forEach(detach);
      div2_nodes.forEach(detach);
      t7 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      p1 = claim_element(div3_nodes, "P", {});
      var p1_nodes = children(p1);
      p1_nodes.forEach(detach);
      div3_nodes.forEach(detach);
      div4_nodes.forEach(detach);
      div5_nodes.forEach(detach);
      div6_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span0, "class", "divider absolute top-5 left-5 -ml-px h-full w-0.5 bg-default svelte-1xpiqas");
      attr(span1, "class", "text-content");
      attr(span2, "class", "absolute -bottom-1.5 -right-1 rounded-tl bg-surface px-0.5 py-px z-10");
      attr(div0, "class", "relative");
      attr(span3, "class", "font-medium text-content");
      attr(div1, "class", "text-sm");
      attr(p0, "class", "mt-0.5 text-sm text-secondary-content");
      attr(div3, "class", "mt-2 text-sm text-secondary-content");
      attr(div4, "class", "min-w-0 flex-1");
      attr(div5, "class", "relative flex items-start space-x-3");
      attr(div6, "class", "relative pb-8");
      set_attributes(li, li_data);
      toggle_class(li, "svelte-1xpiqas", true);
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, div6);
      append_hydration(div6, span0);
      append_hydration(div6, t0);
      append_hydration(div6, div5);
      append_hydration(div5, div0);
      mount_component(avatar_1, div0, null);
      append_hydration(div0, t1);
      append_hydration(div0, span2);
      append_hydration(span2, span1);
      mount_component(icon_1, span1, null);
      append_hydration(div5, t2);
      append_hydration(div5, div4);
      append_hydration(div4, div2);
      append_hydration(div2, div1);
      append_hydration(div1, span3);
      append_hydration(span3, t3);
      append_hydration(div2, t4);
      append_hydration(div2, p0);
      append_hydration(p0, t5);
      append_hydration(p0, t6);
      append_hydration(div4, t7);
      append_hydration(div4, div3);
      append_hydration(div3, p1);
      p1.innerHTML = /*description*/
      ctx[5];
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            li,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[7].call(null, li)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const avatar_1_changes = {};
      if (dirty & /*avatar*/
      4)
        avatar_1_changes.src = /*avatar*/
        ctx2[2];
      avatar_1.$set(avatar_1_changes);
      if (!current || dirty & /*creator*/
      8)
        set_data(
          t3,
          /*creator*/
          ctx2[3]
        );
      if ((!current || dirty & /*created*/
      16) && t6_value !== (t6_value = formatDate(
        /*created*/
        ctx2[4]
      ) + ""))
        set_data(t6, t6_value);
      if (!current || dirty & /*description*/
      32)
        p1.innerHTML = /*description*/
        ctx2[5];
      set_attributes(li, li_data = get_spread_update(li_levels, [dirty & /*$$props*/
      256 && exclude(
        /*$$props*/
        ctx2[8],
        ["use"]
      )]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
      toggle_class(li, "svelte-1xpiqas", true);
    },
    i(local) {
      if (current)
        return;
      transition_in(avatar_1.$$.fragment, local);
      transition_in(icon_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(avatar_1.$$.fragment, local);
      transition_out(icon_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      destroy_component(avatar_1);
      destroy_component(icon_1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$k(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$e, create_else_block$5];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*type*/
      ctx2[1] === "comment"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { type = void 0 } = $$props;
  let { avatar = void 0 } = $$props;
  let { creator } = $$props;
  let { created } = $$props;
  let { description } = $$props;
  let { icon = void 0 } = $$props;
  $$self.$$set = ($$new_props) => {
    $$invalidate(8, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("type" in $$new_props)
      $$invalidate(1, type = $$new_props.type);
    if ("avatar" in $$new_props)
      $$invalidate(2, avatar = $$new_props.avatar);
    if ("creator" in $$new_props)
      $$invalidate(3, creator = $$new_props.creator);
    if ("created" in $$new_props)
      $$invalidate(4, created = $$new_props.created);
    if ("description" in $$new_props)
      $$invalidate(5, description = $$new_props.description);
    if ("icon" in $$new_props)
      $$invalidate(6, icon = $$new_props.icon);
  };
  $$props = exclude_internal_props($$props);
  return [use, type, avatar, creator, created, description, icon, forwardEvents, $$props];
}
class Item5 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$i, create_fragment$k, safe_not_equal, {
      use: 0,
      type: 1,
      avatar: 2,
      creator: 3,
      created: 4,
      description: 5,
      icon: 6
    });
  }
}
const Timeline2 = Timeline$1;
Timeline2.Item = Item5;
function flip(node, { from: from2, to: to2 }, params = {}) {
  const style = getComputedStyle(node);
  const transform = style.transform === "none" ? "" : style.transform;
  const [ox, oy] = style.transformOrigin.split(" ").map(parseFloat);
  const dx = from2.left + from2.width * ox / to2.width - (to2.left + ox);
  const dy = from2.top + from2.height * oy / to2.height - (to2.top + oy);
  const { delay = 0, duration = (d3) => Math.sqrt(d3) * 120, easing = cubicOut } = params;
  return {
    delay,
    duration: is_function(duration) ? duration(Math.sqrt(dx * dx + dy * dy)) : duration,
    easing,
    css: (t2, u2) => {
      const x2 = u2 * dx;
      const y3 = u2 * dy;
      const sx = t2 + u2 * from2.width / to2.width;
      const sy = t2 + u2 * from2.height / to2.height;
      return `transform: ${transform} translate(${x2}px, ${y3}px) scale(${sx}, ${sy});`;
    }
  };
}
const get_options_slot_changes_1 = (dirty) => ({});
const get_options_slot_context_1 = (ctx) => ({});
const get_options_slot_changes = (dirty) => ({});
const get_options_slot_context = (ctx) => ({});
const get_leading_slot_changes = (dirty) => ({});
const get_leading_slot_context = (ctx) => ({});
function get_each_context$8(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i2];
  child_ctx[31] = i2;
  return child_ctx;
}
const get_label_slot_changes = (dirty) => ({});
const get_label_slot_context = (ctx) => ({});
function create_if_block_8(ctx) {
  let if_block_anchor;
  function select_block_type_2(ctx2, dirty) {
    if (
      /*value*/
      ctx2[0] && /*value*/
      ctx2[0][
        /*optionValue*/
        ctx2[6]
      ]
    )
      return create_if_block_9;
    if (
      /*placeholder*/
      ctx2[4]
    )
      return create_if_block_10;
  }
  let current_block_type = select_block_type_2(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_2(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) {
        if_block.d(detaching);
      }
    }
  };
}
function create_if_block_5$1(ctx) {
  let show_if;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_6, create_if_block_7];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (dirty[0] & /*value*/
    1)
      show_if = null;
    if (show_if == null)
      show_if = !!/*value*/
      (ctx2[0] && /*value*/
      ctx2[0].length > 0 && Array.isArray(
        /*value*/
        ctx2[0]
      ));
    if (show_if)
      return 0;
    if (
      /*placeholder*/
      ctx2[4]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx, [-1, -1]))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function create_if_block_10(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*placeholder*/
        ctx[4]
      );
    },
    l(nodes) {
      t2 = claim_text(
        nodes,
        /*placeholder*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*placeholder*/
      16)
        set_data(
          t2,
          /*placeholder*/
          ctx2[4]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_9(ctx) {
  let t_value = (
    /*value*/
    ctx[0][
      /*optionLabel*/
      ctx[5]
    ] + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    l(nodes) {
      t2 = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*value, optionLabel*/
      33 && t_value !== (t_value = /*value*/
      ctx2[0][
        /*optionLabel*/
        ctx2[5]
      ] + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_7(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*placeholder*/
        ctx[4]
      );
    },
    l(nodes) {
      t2 = claim_text(
        nodes,
        /*placeholder*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*placeholder*/
      16)
        set_data(
          t2,
          /*placeholder*/
          ctx2[4]
        );
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_6(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*value*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[29]
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$8(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$8(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*handleRemoveOption, value, optionLabel*/
      131105) {
        each_value = ensure_array_like(
          /*value*/
          ctx2[0]
        );
        group_outros();
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1)
          each_blocks[i2].r();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, fix_and_outro_and_destroy_block, create_each_block$8, each_1_anchor, get_each_context$8);
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1)
          each_blocks[i2].a();
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_default_slot_2$7(ctx) {
  let t_value = (
    /*item*/
    (ctx[29][
      /*optionLabel*/
      ctx[5]
    ] || /*item*/
    ctx[29].value) + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    l(nodes) {
      t2 = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*value, optionLabel*/
      33 && t_value !== (t_value = /*item*/
      (ctx2[29][
        /*optionLabel*/
        ctx2[5]
      ] || /*item*/
      ctx2[29].value) + ""))
        set_data(t2, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_close_slot(ctx) {
  let badge_close;
  let current;
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[22](
        /*index*/
        ctx[31],
        ...args
      )
    );
  }
  badge_close = new Badge2.Close({ props: { slot: "close" } });
  badge_close.$on("click", click_handler);
  return {
    c() {
      create_component(badge_close.$$.fragment);
    },
    l(nodes) {
      claim_component(badge_close.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(badge_close, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    i(local) {
      if (current)
        return;
      transition_in(badge_close.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(badge_close.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(badge_close, detaching);
    }
  };
}
function create_each_block$8(key_1, ctx) {
  let span;
  let badge;
  let t2;
  let span_intro;
  let rect;
  let stop_animation = noop$1;
  let current;
  badge = new Badge2({
    props: {
      $$slots: {
        close: [create_close_slot],
        default: [create_default_slot_2$7]
      },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      span = element("span");
      create_component(badge.$$.fragment);
      t2 = space();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      claim_component(badge.$$.fragment, span_nodes);
      t2 = claim_space(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      this.first = span;
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(badge, span, null);
      append_hydration(span, t2);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const badge_changes = {};
      if (dirty[0] & /*$$scope, value, optionLabel*/
      33554465) {
        badge_changes.$$scope = { dirty, ctx };
      }
      badge.$set(badge_changes);
    },
    r() {
      rect = span.getBoundingClientRect();
    },
    f() {
      fix_position(span);
      stop_animation();
    },
    a() {
      stop_animation();
      stop_animation = create_animation(span, rect, flip, { duration: 250 });
    },
    i(local) {
      if (current)
        return;
      transition_in(badge.$$.fragment, local);
      if (local) {
        if (!span_intro) {
          add_render_callback(() => {
            span_intro = create_in_transition(span, scale, {});
            span_intro.start();
          });
        }
      }
      current = true;
    },
    o(local) {
      transition_out(badge.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(badge);
    }
  };
}
function create_if_block_4$1(ctx) {
  let span;
  let current;
  const leading_slot_template = (
    /*#slots*/
    ctx[21].leading
  );
  const leading_slot = create_slot(
    leading_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    get_leading_slot_context
  );
  return {
    c() {
      span = element("span");
      if (leading_slot)
        leading_slot.c();
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (leading_slot)
        leading_slot.l(span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none");
      toggle_class(span, "text-secondary-content", !/*error*/
      ctx[3]);
      toggle_class(
        span,
        "text-error",
        /*error*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      if (leading_slot) {
        leading_slot.m(span, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (leading_slot) {
        if (leading_slot.p && (!current || dirty[0] & /*$$scope*/
        33554432)) {
          update_slot_base(
            leading_slot,
            leading_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              leading_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              get_leading_slot_changes
            ),
            get_leading_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(span, "text-secondary-content", !/*error*/
        ctx2[3]);
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(
          span,
          "text-error",
          /*error*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(leading_slot, local);
      current = true;
    },
    o(local) {
      transition_out(leading_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (leading_slot)
        leading_slot.d(detaching);
    }
  };
}
function create_else_block$4(ctx) {
  let span;
  let icon;
  let current;
  icon = new Icon$7({ props: { data: unfold_more_horizontal } });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 right-0 flex items-start pt-[0.4rem] pr-2 pointer-events-none");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block_3$2(ctx) {
  let span;
  let icon;
  let current;
  icon = new Icon$7({ props: { data: error } });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "absolute inset-y-0 right-0 flex items-center pr-2 pointer-events-none");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
    }
  };
}
function create_if_block_2$3(ctx) {
  let current;
  const options_slot_template = (
    /*#slots*/
    ctx[21].options
  );
  const options_slot = create_slot(
    options_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    get_options_slot_context_1
  );
  return {
    c() {
      if (options_slot)
        options_slot.c();
    },
    l(nodes) {
      if (options_slot)
        options_slot.l(nodes);
    },
    m(target, anchor) {
      if (options_slot) {
        options_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (options_slot) {
        if (options_slot.p && (!current || dirty[0] & /*$$scope*/
        33554432)) {
          update_slot_base(
            options_slot,
            options_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              options_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              get_options_slot_changes_1
            ),
            get_options_slot_context_1
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(options_slot, local);
      current = true;
    },
    o(local) {
      transition_out(options_slot, local);
      current = false;
    },
    d(detaching) {
      if (options_slot)
        options_slot.d(detaching);
    }
  };
}
function create_if_block_1$8(ctx) {
  let portal;
  let current;
  portal = new Portal({
    props: {
      $$slots: { default: [create_default_slot$a] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portal.$$.fragment);
    },
    l(nodes) {
      claim_component(portal.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(portal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const portal_changes = {};
      if (dirty[0] & /*$$scope*/
      33554432) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal.$set(portal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portal, detaching);
    }
  };
}
function create_default_slot_1$8(ctx) {
  let current;
  const options_slot_template = (
    /*#slots*/
    ctx[21].options
  );
  const options_slot = create_slot(
    options_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    get_options_slot_context
  );
  return {
    c() {
      if (options_slot)
        options_slot.c();
    },
    l(nodes) {
      if (options_slot)
        options_slot.l(nodes);
    },
    m(target, anchor) {
      if (options_slot) {
        options_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (options_slot) {
        if (options_slot.p && (!current || dirty[0] & /*$$scope*/
        33554432)) {
          update_slot_base(
            options_slot,
            options_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              options_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              get_options_slot_changes
            ),
            get_options_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(options_slot, local);
      current = true;
    },
    o(local) {
      transition_out(options_slot, local);
      current = false;
    },
    d(detaching) {
      if (options_slot)
        options_slot.d(detaching);
    }
  };
}
function create_default_slot$a(ctx) {
  let drawer;
  let current;
  drawer = new Drawer2({
    props: {
      handleClose: (
        /*handleClose*/
        ctx[16]
      ),
      placement: "bottom",
      class: "select-mobile",
      panelClass: "!max-h-[14rem]",
      $$slots: { default: [create_default_slot_1$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(drawer.$$.fragment);
    },
    l(nodes) {
      claim_component(drawer.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(drawer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const drawer_changes = {};
      if (dirty[0] & /*$$scope*/
      33554432) {
        drawer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      drawer.$set(drawer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(drawer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(drawer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(drawer, detaching);
    }
  };
}
function create_if_block$d(ctx) {
  let p;
  let t2;
  let p_id_value;
  let p_transition;
  let current;
  return {
    c() {
      p = element("p");
      t2 = text(
        /*error*/
        ctx[3]
      );
      this.h();
    },
    l(nodes) {
      p = claim_element(nodes, "P", { class: true, id: true });
      var p_nodes = children(p);
      t2 = claim_text(
        p_nodes,
        /*error*/
        ctx[3]
      );
      p_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(p, "class", "mt-2 text-sm text-danger");
      attr(p, "id", p_id_value = /*name*/
      ctx[2] + "-error");
    },
    m(target, anchor) {
      insert_hydration(target, p, anchor);
      append_hydration(p, t2);
      current = true;
    },
    p(ctx2, dirty) {
      if (!current || dirty[0] & /*error*/
      8)
        set_data(
          t2,
          /*error*/
          ctx2[3]
        );
      if (!current || dirty[0] & /*name*/
      4 && p_id_value !== (p_id_value = /*name*/
      ctx2[2] + "-error")) {
        attr(p, "id", p_id_value);
      }
    },
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!p_transition)
            p_transition = create_bidirectional_transition(p, slide, {}, true);
          p_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!p_transition)
          p_transition = create_bidirectional_transition(p, slide, {}, false);
        p_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (detaching && p_transition)
        p_transition.end();
    }
  };
}
function create_fragment$j(ctx) {
  let div1;
  let t0;
  let div0;
  let button;
  let span;
  let show_if;
  let current_block_type_index;
  let if_block0;
  let t1;
  let input_1;
  let t2;
  let t3;
  let current_block_type_index_1;
  let if_block2;
  let t4;
  let current_block_type_index_2;
  let if_block3;
  let t5;
  let div1_class_value;
  let div1_style_value;
  let clickOutside_action;
  let current;
  let mounted;
  let dispose;
  const label_slot_template = (
    /*#slots*/
    ctx[21].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    get_label_slot_context
  );
  const if_block_creators = [create_if_block_5$1, create_if_block_8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (dirty[0] & /*value*/
    1)
      show_if = null;
    if (
      /*multiple*/
      ctx2[7]
    )
      return 0;
    if (show_if == null)
      show_if = !!!Array.isArray(
        /*value*/
        ctx2[0]
      );
    if (show_if)
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1]))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = (
    /*$$slots*/
    ctx[19].leading && create_if_block_4$1(ctx)
  );
  const if_block_creators_1 = [create_if_block_3$2, create_else_block$4];
  const if_blocks_1 = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*error*/
      ctx2[3]
    )
      return 0;
    return 1;
  }
  current_block_type_index_1 = select_block_type_3(ctx);
  if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
  const if_block_creators_2 = [create_if_block_1$8, create_if_block_2$3];
  const if_blocks_2 = [];
  function select_block_type_4(ctx2, dirty) {
    if (
      /*visible*/
      ctx2[1] && /*mobile*/
      ctx2[9]
    )
      return 0;
    if (
      /*visible*/
      ctx2[1]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index_2 = select_block_type_4(ctx))) {
    if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
  }
  let if_block4 = (
    /*error*/
    ctx[3] && create_if_block$d(ctx)
  );
  return {
    c() {
      div1 = element("div");
      if (label_slot)
        label_slot.c();
      t0 = space();
      div0 = element("div");
      button = element("button");
      span = element("span");
      if (if_block0)
        if_block0.c();
      t1 = space();
      input_1 = element("input");
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      this.h();
    },
    l(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      if (label_slot)
        label_slot.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      button = claim_element(div0_nodes, "BUTTON", {
        "aria-label": true,
        type: true,
        class: true
      });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (if_block0)
        if_block0.l(span_nodes);
      span_nodes.forEach(detach);
      t1 = claim_space(button_nodes);
      input_1 = claim_element(button_nodes, "INPUT", {
        name: true,
        id: true,
        class: true,
        autocomplete: true
      });
      t2 = claim_space(button_nodes);
      if (if_block1)
        if_block1.l(button_nodes);
      t3 = claim_space(button_nodes);
      if_block2.l(button_nodes);
      button_nodes.forEach(detach);
      t4 = claim_space(div0_nodes);
      if (if_block3)
        if_block3.l(div0_nodes);
      div0_nodes.forEach(detach);
      t5 = claim_space(div1_nodes);
      if (if_block4)
        if_block4.l(div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "flex flex-row flex-wrap gap-2 truncate text-content");
      toggle_class(
        span,
        "text-secondary-content",
        /*placeholder*/
        ctx[4] && (!/*value*/
        ctx[0] || /*value*/
        ctx[0].length === 0)
      );
      toggle_class(
        span,
        "text-opacity-80",
        /*placeholder*/
        ctx[4] && (!/*value*/
        ctx[0] || /*value*/
        ctx[0].length === 0)
      );
      attr(
        input_1,
        "name",
        /*name*/
        ctx[2]
      );
      attr(
        input_1,
        "id",
        /*name*/
        ctx[2]
      );
      input_1.disabled = /*disabled*/
      ctx[8];
      attr(input_1, "class", "h-0 w-0 hidden invisible");
      input_1.readOnly = true;
      attr(input_1, "autocomplete", "off");
      attr(button, "aria-label", "toggle select");
      attr(button, "type", "button");
      attr(button, "class", "relative border pr-10 py-2 min-h-[2.5rem] text-left focus:outline-none sm:text-sm block w-full outline-none ring-0 focus:ring-0 rounded-md");
      button.disabled = /*disabled*/
      ctx[8];
      toggle_class(
        button,
        "border-danger",
        /*error*/
        ctx[3]
      );
      toggle_class(
        button,
        "text-danger",
        /*error*/
        ctx[3]
      );
      toggle_class(
        button,
        "focus:border-red-500",
        /*error*/
        ctx[3]
      );
      toggle_class(button, "focus:border-primary", !/*error*/
      ctx[3]);
      toggle_class(button, "border-border", !/*error*/
      ctx[3]);
      toggle_class(
        button,
        "bg-default",
        /*disabled*/
        ctx[8]
      );
      toggle_class(button, "bg-surface", !/*disabled*/
      ctx[8]);
      toggle_class(button, "cursor-pointer", !/*disabled*/
      ctx[8]);
      toggle_class(
        button,
        "cursor-default",
        /*disabled*/
        ctx[8]
      );
      toggle_class(
        button,
        "pl-10",
        /*$$slots*/
        ctx[19].leading
      );
      toggle_class(button, "pl-3", !/*$$slots*/
      ctx[19].leading);
      attr(div0, "class", "mt-1 relative rounded-md");
      toggle_class(
        div0,
        "text-danger",
        /*error*/
        ctx[3]
      );
      toggle_class(
        div0,
        "opacity-50",
        /*disabled*/
        ctx[8]
      );
      attr(div1, "class", div1_class_value = /*$$props*/
      ctx[18].class);
      attr(div1, "style", div1_style_value = /*$$props*/
      ctx[18].style);
    },
    m(target, anchor) {
      insert_hydration(target, div1, anchor);
      if (label_slot) {
        label_slot.m(div1, null);
      }
      append_hydration(div1, t0);
      append_hydration(div1, div0);
      append_hydration(div0, button);
      append_hydration(button, span);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(span, null);
      }
      append_hydration(button, t1);
      append_hydration(button, input_1);
      ctx[23](input_1);
      set_input_value(
        input_1,
        /*stringifyValues*/
        ctx[11]
      );
      append_hydration(button, t2);
      if (if_block1)
        if_block1.m(button, null);
      append_hydration(button, t3);
      if_blocks_1[current_block_type_index_1].m(button, null);
      append_hydration(div0, t4);
      if (~current_block_type_index_2) {
        if_blocks_2[current_block_type_index_2].m(div0, null);
      }
      append_hydration(div1, t5);
      if (if_block4)
        if_block4.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input_1,
            "input",
            /*input_1_input_handler*/
            ctx[24]
          ),
          listen(button, "click", stop_propagation(prevent_default(
            /*toggleVisible*/
            ctx[15]
          ))),
          action_destroyer(clickOutside_action = clickOutside.call(
            null,
            div1,
            /*$isMobile*/
            ctx[12] ? clickOutside_function : (
              /*handleClose*/
              ctx[16]
            )
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty[0] & /*$$scope*/
        33554432)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[25]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[25],
              dirty,
              get_label_slot_changes
            ),
            get_label_slot_context
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(span, null);
        } else {
          if_block0 = null;
        }
      }
      if (!current || dirty[0] & /*placeholder, value*/
      17) {
        toggle_class(
          span,
          "text-secondary-content",
          /*placeholder*/
          ctx2[4] && (!/*value*/
          ctx2[0] || /*value*/
          ctx2[0].length === 0)
        );
      }
      if (!current || dirty[0] & /*placeholder, value*/
      17) {
        toggle_class(
          span,
          "text-opacity-80",
          /*placeholder*/
          ctx2[4] && (!/*value*/
          ctx2[0] || /*value*/
          ctx2[0].length === 0)
        );
      }
      if (!current || dirty[0] & /*name*/
      4) {
        attr(
          input_1,
          "name",
          /*name*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*name*/
      4) {
        attr(
          input_1,
          "id",
          /*name*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      256) {
        input_1.disabled = /*disabled*/
        ctx2[8];
      }
      if (dirty[0] & /*stringifyValues*/
      2048 && input_1.value !== /*stringifyValues*/
      ctx2[11]) {
        set_input_value(
          input_1,
          /*stringifyValues*/
          ctx2[11]
        );
      }
      if (
        /*$$slots*/
        ctx2[19].leading
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          524288) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4$1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(button, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      let previous_block_index_1 = current_block_type_index_1;
      current_block_type_index_1 = select_block_type_3(ctx2);
      if (current_block_type_index_1 === previous_block_index_1) {
        if_blocks_1[current_block_type_index_1].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
          if_blocks_1[previous_block_index_1] = null;
        });
        check_outros();
        if_block2 = if_blocks_1[current_block_type_index_1];
        if (!if_block2) {
          if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(button, null);
      }
      if (!current || dirty[0] & /*disabled*/
      256) {
        button.disabled = /*disabled*/
        ctx2[8];
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(
          button,
          "border-danger",
          /*error*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(
          button,
          "text-danger",
          /*error*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(
          button,
          "focus:border-red-500",
          /*error*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(button, "focus:border-primary", !/*error*/
        ctx2[3]);
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(button, "border-border", !/*error*/
        ctx2[3]);
      }
      if (!current || dirty[0] & /*disabled*/
      256) {
        toggle_class(
          button,
          "bg-default",
          /*disabled*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      256) {
        toggle_class(button, "bg-surface", !/*disabled*/
        ctx2[8]);
      }
      if (!current || dirty[0] & /*disabled*/
      256) {
        toggle_class(button, "cursor-pointer", !/*disabled*/
        ctx2[8]);
      }
      if (!current || dirty[0] & /*disabled*/
      256) {
        toggle_class(
          button,
          "cursor-default",
          /*disabled*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*$$slots*/
      524288) {
        toggle_class(
          button,
          "pl-10",
          /*$$slots*/
          ctx2[19].leading
        );
      }
      if (!current || dirty[0] & /*$$slots*/
      524288) {
        toggle_class(button, "pl-3", !/*$$slots*/
        ctx2[19].leading);
      }
      let previous_block_index_2 = current_block_type_index_2;
      current_block_type_index_2 = select_block_type_4(ctx2);
      if (current_block_type_index_2 === previous_block_index_2) {
        if (~current_block_type_index_2) {
          if_blocks_2[current_block_type_index_2].p(ctx2, dirty);
        }
      } else {
        if (if_block3) {
          group_outros();
          transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
            if_blocks_2[previous_block_index_2] = null;
          });
          check_outros();
        }
        if (~current_block_type_index_2) {
          if_block3 = if_blocks_2[current_block_type_index_2];
          if (!if_block3) {
            if_block3 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx2);
            if_block3.c();
          } else {
            if_block3.p(ctx2, dirty);
          }
          transition_in(if_block3, 1);
          if_block3.m(div0, null);
        } else {
          if_block3 = null;
        }
      }
      if (!current || dirty[0] & /*error*/
      8) {
        toggle_class(
          div0,
          "text-danger",
          /*error*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      256) {
        toggle_class(
          div0,
          "opacity-50",
          /*disabled*/
          ctx2[8]
        );
      }
      if (
        /*error*/
        ctx2[3]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & /*error*/
          8) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block$d(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div1, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*$$props*/
      262144 && div1_class_value !== (div1_class_value = /*$$props*/
      ctx2[18].class)) {
        attr(div1, "class", div1_class_value);
      }
      if (!current || dirty[0] & /*$$props*/
      262144 && div1_style_value !== (div1_style_value = /*$$props*/
      ctx2[18].style)) {
        attr(div1, "style", div1_style_value);
      }
      if (clickOutside_action && is_function(clickOutside_action.update) && dirty[0] & /*$isMobile*/
      4096)
        clickOutside_action.update.call(
          null,
          /*$isMobile*/
          ctx2[12] ? clickOutside_function : (
            /*handleClose*/
            ctx2[16]
          )
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(label_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (label_slot)
        label_slot.d(detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      ctx[23](null);
      if (if_block1)
        if_block1.d();
      if_blocks_1[current_block_type_index_1].d();
      if (~current_block_type_index_2) {
        if_blocks_2[current_block_type_index_2].d();
      }
      if (if_block4)
        if_block4.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
const clickOutside_function = () => {
  return;
};
function instance$h($$self, $$props, $$invalidate) {
  let stringifyValues;
  let $selectedValue;
  let $isMobile;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  let { name } = $$props;
  let { error: error2 = void 0 } = $$props;
  let { placeholder = void 0 } = $$props;
  let { value = void 0 } = $$props;
  let { visible = false } = $$props;
  let { optionLabel = "label" } = $$props;
  let { optionValue = "value" } = $$props;
  let { multiple = false } = $$props;
  let { closeOnSelect = true } = $$props;
  let { disabled = false } = $$props;
  let { mobile = false } = $$props;
  let selectedValue = writable(value);
  component_subscribe($$self, selectedValue, (value2) => $$invalidate(26, $selectedValue = value2));
  let currentError = writable(error2);
  let isMobile = writable(mobile);
  component_subscribe($$self, isMobile, (value2) => $$invalidate(12, $isMobile = value2));
  let input;
  function toggleVisible() {
    if (!disabled) {
      $$invalidate(1, visible = !visible);
    }
  }
  function handleClose() {
    $$invalidate(1, visible = false);
  }
  function handleSelect(option) {
    if (multiple) {
      const tempSelectedValues = $selectedValue || [];
      const selectedIndex = tempSelectedValues.findIndex((sv) => sv.value === option.value);
      if (selectedIndex !== -1) {
        tempSelectedValues.splice(selectedIndex, 1);
        set_store_value(selectedValue, $selectedValue = tempSelectedValues, $selectedValue);
      } else {
        tempSelectedValues.push(option);
        set_store_value(selectedValue, $selectedValue = tempSelectedValues, $selectedValue);
      }
      $$invalidate(10, input.value = JSON.stringify($selectedValue), input);
      $$invalidate(0, value = $selectedValue);
    } else {
      if (value && !Array.isArray(value) && value[optionValue] === option[optionValue]) {
        $$invalidate(10, input.value = "", input);
        $$invalidate(0, value = void 0);
        set_store_value(selectedValue, $selectedValue = void 0, $selectedValue);
      } else {
        $$invalidate(10, input.value = option[optionValue], input);
        $$invalidate(0, value = option);
        set_store_value(selectedValue, $selectedValue = option, $selectedValue);
      }
    }
    if (closeOnSelect) {
      handleClose();
    }
  }
  function handleRemoveOption(e2, index2) {
    e2.stopPropagation();
    e2.preventDefault();
    const tempSelectedValues = $selectedValue;
    tempSelectedValues.splice(index2, 1);
    set_store_value(selectedValue, $selectedValue = tempSelectedValues, $selectedValue);
    $$invalidate(10, input.value = JSON.stringify($selectedValue), input);
    $$invalidate(0, value = $selectedValue);
  }
  setContext("select-error", currentError);
  setContext("select-name", name);
  setContext("select-value", selectedValue);
  setContext("select-handleSelect", handleSelect);
  setContext("select-option-label", optionLabel);
  setContext("select-option-value", optionValue);
  setContext("select-multiple", multiple);
  setContext("select-handleClose", handleClose);
  setContext("select-mobile", isMobile);
  const click_handler = (index2, e2) => handleRemoveOption(e2, index2);
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(10, input);
    });
  }
  function input_1_input_handler() {
    stringifyValues = this.value;
    $$invalidate(11, stringifyValues), $$invalidate(7, multiple), $$invalidate(0, value), $$invalidate(6, optionValue);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(18, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("name" in $$new_props)
      $$invalidate(2, name = $$new_props.name);
    if ("error" in $$new_props)
      $$invalidate(3, error2 = $$new_props.error);
    if ("placeholder" in $$new_props)
      $$invalidate(4, placeholder = $$new_props.placeholder);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("visible" in $$new_props)
      $$invalidate(1, visible = $$new_props.visible);
    if ("optionLabel" in $$new_props)
      $$invalidate(5, optionLabel = $$new_props.optionLabel);
    if ("optionValue" in $$new_props)
      $$invalidate(6, optionValue = $$new_props.optionValue);
    if ("multiple" in $$new_props)
      $$invalidate(7, multiple = $$new_props.multiple);
    if ("closeOnSelect" in $$new_props)
      $$invalidate(20, closeOnSelect = $$new_props.closeOnSelect);
    if ("disabled" in $$new_props)
      $$invalidate(8, disabled = $$new_props.disabled);
    if ("mobile" in $$new_props)
      $$invalidate(9, mobile = $$new_props.mobile);
    if ("$$scope" in $$new_props)
      $$invalidate(25, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*multiple, value, optionValue*/
    193) {
      $$invalidate(11, stringifyValues = multiple ? JSON.stringify(value) : value && value instanceof Object && !Array.isArray(value) ? value[optionValue] : "");
    }
    if ($$self.$$.dirty[0] & /*error*/
    8) {
      currentError.set(error2);
    }
    if ($$self.$$.dirty[0] & /*mobile*/
    512) {
      isMobile.set(mobile);
    }
  };
  $$props = exclude_internal_props($$props);
  return [
    value,
    visible,
    name,
    error2,
    placeholder,
    optionLabel,
    optionValue,
    multiple,
    disabled,
    mobile,
    input,
    stringifyValues,
    $isMobile,
    selectedValue,
    isMobile,
    toggleVisible,
    handleClose,
    handleRemoveOption,
    $$props,
    $$slots,
    closeOnSelect,
    slots,
    click_handler,
    input_1_binding,
    input_1_input_handler,
    $$scope
  ];
}
let Select$1 = class Select extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$h,
      create_fragment$j,
      safe_not_equal,
      {
        name: 2,
        error: 3,
        placeholder: 4,
        value: 0,
        visible: 1,
        optionLabel: 5,
        optionValue: 6,
        multiple: 7,
        closeOnSelect: 20,
        disabled: 8,
        mobile: 9
      },
      null,
      [-1, -1]
    );
  }
};
function create_fragment$i(ctx) {
  let label;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let label_levels = [
    { for: (
      /*name*/
      ctx[3]
    ) },
    { class: (
      /*finalClass*/
      ctx[1]
    ) },
    exclude(
      /*$$props*/
      ctx[5],
      ["use", "class"]
    )
  ];
  let label_data = {};
  for (let i2 = 0; i2 < label_levels.length; i2 += 1) {
    label_data = assign$1(label_data, label_levels[i2]);
  }
  return {
    c() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      label = claim_element(nodes, "LABEL", { for: true, class: true });
      var label_nodes = children(label);
      if (default_slot)
        default_slot.l(label_nodes);
      label_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(label, label_data);
    },
    m(target, anchor) {
      insert_hydration(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            label,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[2].call(null, label)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        { for: (
          /*name*/
          ctx2[3]
        ) },
        (!current || dirty & /*finalClass*/
        2) && { class: (
          /*finalClass*/
          ctx2[1]
        ) },
        dirty & /*$$props*/
        32 && exclude(
          /*$$props*/
          ctx2[5],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass$1 = "block text-sm font-medium text-secondary-content";
const errorClass = "text-danger";
function instance$g($$self, $$props, $$invalidate) {
  let finalClass;
  let $error;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  const name = getContext("select-name");
  const error2 = getContext("select-error");
  component_subscribe($$self, error2, (value) => $$invalidate(6, $error = value));
  $$self.$$set = ($$new_props) => {
    $$invalidate(5, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    $$invalidate(1, finalClass = twMerge(defaultClass$1, $error && $error.length > 0 ? errorClass : false, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [use, finalClass, forwardEvents, name, error2, $$props, $error, $$scope, slots];
}
class Label12 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$g, create_fragment$i, safe_not_equal, { use: 0 });
  }
}
function create_else_block$3(ctx) {
  let ul;
  let useActions_action;
  let ul_intro;
  let ul_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let ul_levels = [
    { class: (
      /*finalClass*/
      ctx[3]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    ),
    { role: "listbox" }
  ];
  let ul_data = {};
  for (let i2 = 0; i2 < ul_levels.length; i2 += 1) {
    ul_data = assign$1(ul_data, ul_levels[i2]);
  }
  return {
    c() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      ul = claim_element(nodes, "UL", { class: true, role: true });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(ul, ul_data);
    },
    m(target, anchor) {
      insert_hydration(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[12](ul);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            ul,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[4].call(null, ul)
          ),
          action_destroyer(floatingUI.call(null, ul, { placement: "bottom-start", offset: 8 }))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        (!current || dirty & /*finalClass*/
        8) && { class: (
          /*finalClass*/
          ctx2[3]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        ),
        { role: "listbox" }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (ul_outro)
            ul_outro.end(1);
          ul_intro = create_in_transition(ul, scale, { start: 0.9, duration: 100, delay: 150 });
          ul_intro.start();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      if (ul_intro)
        ul_intro.invalidate();
      if (local) {
        ul_outro = create_out_transition(ul, scale, { start: 0.95, duration: 75 });
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[12](null);
      if (detaching && ul_outro)
        ul_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$c(ctx) {
  let ul;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let ul_levels = [
    { class: (
      /*finalClass*/
      ctx[3]
    ) },
    exclude(
      /*$$props*/
      ctx[7],
      ["use", "class"]
    ),
    { role: "listbox" }
  ];
  let ul_data = {};
  for (let i2 = 0; i2 < ul_levels.length; i2 += 1) {
    ul_data = assign$1(ul_data, ul_levels[i2]);
  }
  return {
    c() {
      ul = element("ul");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l(nodes) {
      ul = claim_element(nodes, "UL", { class: true, role: true });
      var ul_nodes = children(ul);
      if (default_slot)
        default_slot.l(ul_nodes);
      ul_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_attributes(ul, ul_data);
    },
    m(target, anchor) {
      insert_hydration(target, ul, anchor);
      if (default_slot) {
        default_slot.m(ul, null);
      }
      ctx[11](ul);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            ul,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[4].call(null, ul)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(ul, ul_data = get_spread_update(ul_levels, [
        (!current || dirty & /*finalClass*/
        8) && { class: (
          /*finalClass*/
          ctx2[3]
        ) },
        dirty & /*$$props*/
        128 && exclude(
          /*$$props*/
          ctx2[7],
          ["use", "class"]
        ),
        { role: "listbox" }
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ul);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[11](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$h(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$c, create_else_block$3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$mobile*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(window, "keydown", prevent_default(
          /*handleKeydown*/
          ctx[6]
        ));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let finalClass;
  let $mobile;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let list;
  let items = [];
  let focusIndex = 0;
  const handleClose = getContext("select-handleClose");
  const mobile = getContext("select-mobile");
  component_subscribe($$self, mobile, (value) => $$invalidate(1, $mobile = value));
  function handleKeydown(e2) {
    e2.preventDefault();
    e2.stopPropagation();
    if (e2.key === "ArrowUp") {
      focusIndex = focusIndex > 0 ? focusIndex - 1 : items.length - 1;
      items[focusIndex].focus();
    } else if (e2.key === "ArrowDown") {
      focusIndex = focusIndex < items.length - 1 ? focusIndex + 1 : 0;
      items[focusIndex].focus();
    } else if (e2.key === "Enter") {
      console.log("Enter FIRED");
    } else if (e2.key === "Escape") {
      handleClose();
    }
  }
  let defaultClass2 = "w-full bg-surface";
  onMount(() => {
    items = list.querySelectorAll("li");
    items[focusIndex].focus();
  });
  function ul_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      list = $$value;
      $$invalidate(2, list);
    });
  }
  function ul_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      list = $$value;
      $$invalidate(2, list);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(7, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$mobile, defaultClass*/
    258) {
      if ($mobile) {
        $$invalidate(8, defaultClass2 += " h-full p-3 space-y-1");
      } else {
        $$invalidate(8, defaultClass2 += " p-1 shadow-xl border border-border rounded-md origin-top-right absolute z-10 left-0 right-0");
      }
    }
    $$invalidate(3, finalClass = twMerge(defaultClass2, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    $mobile,
    list,
    finalClass,
    forwardEvents,
    mobile,
    handleKeydown,
    $$props,
    defaultClass2,
    $$scope,
    slots,
    ul_binding,
    ul_binding_1
  ];
}
class Options2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$f, create_fragment$h, safe_not_equal, { use: 0 });
  }
}
function create_if_block$b(ctx) {
  let span;
  let icon;
  let span_transition;
  let current;
  icon = new Icon$7({ props: { data: check } });
  return {
    c() {
      span = element("span");
      create_component(icon.$$.fragment);
      this.h();
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(icon.$$.fragment, span_nodes);
      span_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "text-primary absolute inset-y-0 right-0 flex items-center pr-1.5");
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
      mount_component(icon, span, null);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!span_transition)
            span_transition = create_bidirectional_transition(span, scale, {}, true);
          span_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      if (local) {
        if (!span_transition)
          span_transition = create_bidirectional_transition(span, scale, {}, false);
        span_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_component(icon);
      if (detaching && span_transition)
        span_transition.end();
    }
  };
}
function create_fragment$g(ctx) {
  let li;
  let button;
  let div2;
  let span;
  let t0_value = (
    /*option*/
    ctx[1][
      /*optionLabel*/
      ctx[6]
    ] + ""
  );
  let t0;
  let t1;
  let t2;
  let hoverbackground;
  let useActions_action;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*optionIsSelected*/
    ctx[2] && create_if_block$b()
  );
  hoverbackground = new HoverBackground({});
  let li_levels = [
    { class: (
      /*finalClass*/
      ctx[3]
    ) },
    { role: "option" },
    {
      "aria-selected": (
        /*optionIsSelected*/
        ctx[2]
      )
    },
    { tabindex: "-1" },
    exclude(
      /*$$props*/
      ctx[9],
      ["use", "class"]
    )
  ];
  let li_data = {};
  for (let i2 = 0; i2 < li_levels.length; i2 += 1) {
    li_data = assign$1(li_data, li_levels[i2]);
  }
  return {
    c() {
      li = element("li");
      button = element("button");
      div2 = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      create_component(hoverbackground.$$.fragment);
      this.h();
    },
    l(nodes) {
      li = claim_element(nodes, "LI", {
        class: true,
        role: true,
        "aria-selected": true,
        tabindex: true
      });
      var li_nodes = children(li);
      button = claim_element(li_nodes, "BUTTON", {
        type: true,
        "aria-label": true,
        class: true
      });
      var button_nodes = children(button);
      div2 = claim_element(button_nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, t0_value);
      span_nodes.forEach(detach);
      t1 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      t2 = claim_space(div_nodes);
      claim_component(hoverbackground.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      button_nodes.forEach(detach);
      li_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(span, "class", "font-normal block truncate");
      toggle_class(
        span,
        "font-semibold",
        /*optionIsSelected*/
        ctx[2]
      );
      attr(div2, "class", "relative py-1.5 pl-2.5 pr-7 w-full rounded-md overflow-hidden");
      attr(button, "type", "button");
      attr(button, "aria-label", "select option");
      attr(button, "class", "w-full text-left");
      set_attributes(li, li_data);
    },
    m(target, anchor) {
      insert_hydration(target, li, anchor);
      append_hydration(li, button);
      append_hydration(button, div2);
      append_hydration(div2, span);
      append_hydration(span, t0);
      append_hydration(div2, t1);
      if (if_block)
        if_block.m(div2, null);
      append_hydration(div2, t2);
      mount_component(hoverbackground, div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*click_handler*/
            ctx[11]
          ),
          listen(
            li,
            "keydown",
            /*handleKeydown*/
            ctx[8]
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            li,
            /*use*/
            ctx[0]
          )),
          action_destroyer(
            /*forwardEvents*/
            ctx[4].call(null, li)
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*option*/
      2) && t0_value !== (t0_value = /*option*/
      ctx2[1][
        /*optionLabel*/
        ctx2[6]
      ] + ""))
        set_data(t0, t0_value);
      if (!current || dirty & /*optionIsSelected*/
      4) {
        toggle_class(
          span,
          "font-semibold",
          /*optionIsSelected*/
          ctx2[2]
        );
      }
      if (
        /*optionIsSelected*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*optionIsSelected*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$b();
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(li, li_data = get_spread_update(li_levels, [
        (!current || dirty & /*finalClass*/
        8) && { class: (
          /*finalClass*/
          ctx2[3]
        ) },
        { role: "option" },
        (!current || dirty & /*optionIsSelected*/
        4) && {
          "aria-selected": (
            /*optionIsSelected*/
            ctx2[2]
          )
        },
        { tabindex: "-1" },
        dirty & /*$$props*/
        512 && exclude(
          /*$$props*/
          ctx2[9],
          ["use", "class"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(hoverbackground.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(hoverbackground.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (if_block)
        if_block.d();
      destroy_component(hoverbackground);
      mounted = false;
      run_all(dispose);
    }
  };
}
const defaultClass = "group text-content cursor-pointer select-none p-0.5 w-full !outline-none !border-none !ring-0";
function instance$e($$self, $$props, $$invalidate) {
  let finalClass;
  let $value;
  let { use = [] } = $$props;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { option } = $$props;
  const value = getContext("select-value");
  component_subscribe($$self, value, (value2) => $$invalidate(10, $value = value2));
  const optionLabel = getContext("select-option-label");
  const optionValue = getContext("select-option-value");
  const handleSelect = getContext("select-handleSelect");
  const multiple = getContext("select-multiple");
  let optionIsSelected = false;
  function handleKeydown(e2) {
    if (e2.key === "Enter") {
      e2.preventDefault();
      e2.stopPropagation();
      handleSelect(option);
    }
  }
  const click_handler = () => handleSelect(option);
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("option" in $$new_props)
      $$invalidate(1, option = $$new_props.option);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$value, option*/
    1026) {
      {
        if ($value && multiple && Array.isArray($value)) {
          const isSelected = $value.find((v) => v[optionValue] === option[optionValue]);
          if (isSelected) {
            $$invalidate(2, optionIsSelected = true);
          } else {
            $$invalidate(2, optionIsSelected = false);
          }
        } else if ($value && !Array.isArray($value)) {
          if ($value[optionValue] === option[optionValue]) {
            $$invalidate(2, optionIsSelected = true);
          } else {
            $$invalidate(2, optionIsSelected = false);
          }
        }
      }
    }
    $$invalidate(3, finalClass = twMerge(defaultClass, $$props.class));
  };
  $$props = exclude_internal_props($$props);
  return [
    use,
    option,
    optionIsSelected,
    finalClass,
    forwardEvents,
    value,
    optionLabel,
    handleSelect,
    handleKeydown,
    $$props,
    $value,
    click_handler
  ];
}
class Option2 extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$e, create_fragment$g, safe_not_equal, { use: 0, option: 1 });
  }
}
const Select2 = Select$1;
Select2.Label = Label12;
Select2.Options = Options2;
Select2.Options.Option = Option2;
Select2.Leading = Icon$7;
function get_each_context$7(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i2];
  return child_ctx;
}
function get_each_context_1$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i2];
  return child_ctx;
}
function get_each_context_2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i2];
  return child_ctx;
}
function create_if_block_1$7(ctx) {
  let select;
  let updating_value;
  let current;
  function select_value_binding(value) {
    ctx[13](value);
  }
  let select_props = {
    placeholder: "Image",
    name: "imageId",
    $$slots: { options: [create_options_slot_2] },
    $$scope: { ctx }
  };
  if (
    /*imageId*/
    ctx[1] !== void 0
  ) {
    select_props.value = /*imageId*/
    ctx[1];
  }
  select = new Select2({ props: select_props });
  binding_callbacks.push(() => bind(select, "value", select_value_binding));
  return {
    c() {
      create_component(select.$$.fragment);
    },
    l(nodes) {
      claim_component(select.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty[0] & /*images*/
      64 | dirty[1] & /*$$scope*/
      4) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty[0] & /*imageId*/
      2) {
        updating_value = true;
        select_changes.value = /*imageId*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_each_block_2(ctx) {
  let select_options_option;
  let current;
  select_options_option = new Select2.Options.Option({ props: { option: (
    /*option*/
    ctx[26]
  ) } });
  return {
    c() {
      create_component(select_options_option.$$.fragment);
    },
    l(nodes) {
      claim_component(select_options_option.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select_options_option, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_options_option_changes = {};
      if (dirty[0] & /*images*/
      64)
        select_options_option_changes.option = /*option*/
        ctx2[26];
      select_options_option.$set(select_options_option_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select_options_option.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_options_option.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_options_option, detaching);
    }
  };
}
function create_default_slot_4$3(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = ensure_array_like(
    /*images*/
    ctx[6]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks[i2] = create_each_block_2(get_each_context_2(ctx, each_value_2, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*images*/
      64) {
        each_value_2 = ensure_array_like(
          /*images*/
          ctx2[6]
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_2.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_options_slot_2(ctx) {
  let select_options_1;
  let current;
  select_options_1 = new Select2.Options({
    props: {
      slot: "options",
      $$slots: { default: [create_default_slot_4$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select_options_1.$$.fragment);
    },
    l(nodes) {
      claim_component(select_options_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select_options_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_options_1_changes = {};
      if (dirty[0] & /*images*/
      64 | dirty[1] & /*$$scope*/
      4) {
        select_options_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select_options_1.$set(select_options_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select_options_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_options_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_options_1, detaching);
    }
  };
}
function create_each_block_1$2(ctx) {
  let select_options_option;
  let current;
  select_options_option = new Select2.Options.Option({ props: { option: (
    /*option*/
    ctx[26]
  ) } });
  return {
    c() {
      create_component(select_options_option.$$.fragment);
    },
    l(nodes) {
      claim_component(select_options_option.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select_options_option, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(select_options_option.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_options_option.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_options_option, detaching);
    }
  };
}
function create_default_slot_3$5(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*refreshOptions*/
    ctx[8]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*refreshOptions*/
      256) {
        each_value_1 = ensure_array_like(
          /*refreshOptions*/
          ctx2[8]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_options_slot_1$1(ctx) {
  let select_options_1;
  let current;
  select_options_1 = new Select2.Options({
    props: {
      slot: "options",
      $$slots: { default: [create_default_slot_3$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select_options_1.$$.fragment);
    },
    l(nodes) {
      claim_component(select_options_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select_options_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_options_1_changes = {};
      if (dirty[1] & /*$$scope*/
      4) {
        select_options_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select_options_1.$set(select_options_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select_options_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_options_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_options_1, detaching);
    }
  };
}
function create_default_slot_2$6(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Hide title");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Hide title");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_label_slot_1$1(ctx) {
  let toggle_contentright_label;
  let current;
  toggle_contentright_label = new Toggle.ContentRight.Label({
    props: {
      slot: "label",
      $$slots: { default: [create_default_slot_2$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(toggle_contentright_label.$$.fragment);
    },
    l(nodes) {
      claim_component(toggle_contentright_label.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(toggle_contentright_label, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const toggle_contentright_label_changes = {};
      if (dirty[1] & /*$$scope*/
      4) {
        toggle_contentright_label_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toggle_contentright_label.$set(toggle_contentright_label_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toggle_contentright_label.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toggle_contentright_label.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toggle_contentright_label, detaching);
    }
  };
}
function create_content_right_slot_1(ctx) {
  let toggle_contentright;
  let current;
  toggle_contentright = new Toggle.ContentRight({
    props: {
      slot: "content-right",
      $$slots: { label: [create_label_slot_1$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(toggle_contentright.$$.fragment);
    },
    l(nodes) {
      claim_component(toggle_contentright.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(toggle_contentright, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const toggle_contentright_changes = {};
      if (dirty[1] & /*$$scope*/
      4) {
        toggle_contentright_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toggle_contentright.$set(toggle_contentright_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toggle_contentright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toggle_contentright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toggle_contentright, detaching);
    }
  };
}
function create_if_block$a(ctx) {
  let toggle;
  let updating_on;
  let t2;
  let select;
  let updating_value;
  let current;
  function toggle_on_binding_1(value) {
    ctx[16](value);
  }
  let toggle_props = {
    name: "fontBlur",
    $$slots: {
      "content-right": [create_content_right_slot]
    },
    $$scope: { ctx }
  };
  if (
    /*fontBlur*/
    ctx[5] !== void 0
  ) {
    toggle_props.on = /*fontBlur*/
    ctx[5];
  }
  toggle = new Toggle({ props: toggle_props });
  binding_callbacks.push(() => bind(toggle, "on", toggle_on_binding_1));
  function select_value_binding_2(value) {
    ctx[17](value);
  }
  let select_props = {
    placeholder: "Font color",
    name: "fontColor",
    $$slots: { options: [create_options_slot$3] },
    $$scope: { ctx }
  };
  if (
    /*fontColor*/
    ctx[4] !== void 0
  ) {
    select_props.value = /*fontColor*/
    ctx[4];
  }
  select = new Select2({ props: select_props });
  binding_callbacks.push(() => bind(select, "value", select_value_binding_2));
  return {
    c() {
      create_component(toggle.$$.fragment);
      t2 = space();
      create_component(select.$$.fragment);
    },
    l(nodes) {
      claim_component(toggle.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(select.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(toggle, target, anchor);
      insert_hydration(target, t2, anchor);
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const toggle_changes = {};
      if (dirty[1] & /*$$scope*/
      4) {
        toggle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_on && dirty[0] & /*fontBlur*/
      32) {
        updating_on = true;
        toggle_changes.on = /*fontBlur*/
        ctx2[5];
        add_flush_callback(() => updating_on = false);
      }
      toggle.$set(toggle_changes);
      const select_changes = {};
      if (dirty[1] & /*$$scope*/
      4) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty[0] & /*fontColor*/
      16) {
        updating_value = true;
        select_changes.value = /*fontColor*/
        ctx2[4];
        add_flush_callback(() => updating_value = false);
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toggle.$$.fragment, local);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toggle.$$.fragment, local);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(toggle, detaching);
      destroy_component(select, detaching);
    }
  };
}
function create_default_slot_1$7(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Blur background");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Blur background");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_label_slot$1(ctx) {
  let toggle_contentright_label;
  let current;
  toggle_contentright_label = new Toggle.ContentRight.Label({
    props: {
      slot: "label",
      $$slots: { default: [create_default_slot_1$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(toggle_contentright_label.$$.fragment);
    },
    l(nodes) {
      claim_component(toggle_contentright_label.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(toggle_contentright_label, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const toggle_contentright_label_changes = {};
      if (dirty[1] & /*$$scope*/
      4) {
        toggle_contentright_label_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toggle_contentright_label.$set(toggle_contentright_label_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toggle_contentright_label.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toggle_contentright_label.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toggle_contentright_label, detaching);
    }
  };
}
function create_content_right_slot(ctx) {
  let toggle_contentright;
  let current;
  toggle_contentright = new Toggle.ContentRight({
    props: {
      slot: "content-right",
      $$slots: { label: [create_label_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(toggle_contentright.$$.fragment);
    },
    l(nodes) {
      claim_component(toggle_contentright.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(toggle_contentright, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const toggle_contentright_changes = {};
      if (dirty[1] & /*$$scope*/
      4) {
        toggle_contentright_changes.$$scope = { dirty, ctx: ctx2 };
      }
      toggle_contentright.$set(toggle_contentright_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toggle_contentright.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toggle_contentright.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toggle_contentright, detaching);
    }
  };
}
function create_each_block$7(ctx) {
  let select_options_option;
  let current;
  select_options_option = new Select2.Options.Option({ props: { option: (
    /*option*/
    ctx[26]
  ) } });
  return {
    c() {
      create_component(select_options_option.$$.fragment);
    },
    l(nodes) {
      claim_component(select_options_option.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select_options_option, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(select_options_option.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_options_option.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_options_option, detaching);
    }
  };
}
function create_default_slot$9(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*colorOptions*/
    ctx[9]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$7(get_each_context$7(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*colorOptions*/
      512) {
        each_value = ensure_array_like(
          /*colorOptions*/
          ctx2[9]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$7(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$7(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_options_slot$3(ctx) {
  let select_options_1;
  let current;
  select_options_1 = new Select2.Options({
    props: {
      slot: "options",
      $$slots: { default: [create_default_slot$9] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select_options_1.$$.fragment);
    },
    l(nodes) {
      claim_component(select_options_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select_options_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_options_1_changes = {};
      if (dirty[1] & /*$$scope*/
      4) {
        select_options_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select_options_1.$set(select_options_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select_options_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_options_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_options_1, detaching);
    }
  };
}
function create_fragment$f(ctx) {
  let devicepicker;
  let updating_deviceId;
  let t0;
  let div2;
  let t1;
  let select;
  let updating_value;
  let t2;
  let toggle;
  let updating_on;
  let t3;
  let if_block1_anchor;
  let current;
  function devicepicker_deviceId_binding(value) {
    ctx[12](value);
  }
  let devicepicker_props = { devices: (
    /*imageDevices*/
    ctx[7]
  ) };
  if (
    /*deviceId*/
    ctx[0] !== void 0
  ) {
    devicepicker_props.deviceId = /*deviceId*/
    ctx[0];
  }
  devicepicker = new DevicePicker({ props: devicepicker_props });
  binding_callbacks.push(() => bind(devicepicker, "deviceId", devicepicker_deviceId_binding));
  let if_block0 = (
    /*deviceId*/
    ctx[0] && create_if_block_1$7(ctx)
  );
  function select_value_binding_1(value) {
    ctx[14](value);
  }
  let select_props = {
    placeholder: "Refresh every",
    name: "refresh",
    $$slots: { options: [create_options_slot_1$1] },
    $$scope: { ctx }
  };
  if (
    /*refresh*/
    ctx[2] !== void 0
  ) {
    select_props.value = /*refresh*/
    ctx[2];
  }
  select = new Select2({ props: select_props });
  binding_callbacks.push(() => bind(select, "value", select_value_binding_1));
  function toggle_on_binding(value) {
    ctx[15](value);
  }
  let toggle_props = {
    name: "hideTitle",
    $$slots: {
      "content-right": [create_content_right_slot_1]
    },
    $$scope: { ctx }
  };
  if (
    /*hideTitle*/
    ctx[3] !== void 0
  ) {
    toggle_props.on = /*hideTitle*/
    ctx[3];
  }
  toggle = new Toggle({ props: toggle_props });
  binding_callbacks.push(() => bind(toggle, "on", toggle_on_binding));
  let if_block1 = !/*hideTitle*/
  ctx[3] && create_if_block$a(ctx);
  return {
    c() {
      create_component(devicepicker.$$.fragment);
      t0 = space();
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      create_component(select.$$.fragment);
      t2 = space();
      create_component(toggle.$$.fragment);
      t3 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l(nodes) {
      claim_component(devicepicker.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", {});
      var div_nodes = children(div2);
      if (if_block0)
        if_block0.l(div_nodes);
      div_nodes.forEach(detach);
      t1 = claim_space(nodes);
      claim_component(select.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(toggle.$$.fragment, nodes);
      t3 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      mount_component(devicepicker, target, anchor);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      insert_hydration(target, t1, anchor);
      mount_component(select, target, anchor);
      insert_hydration(target, t2, anchor);
      mount_component(toggle, target, anchor);
      insert_hydration(target, t3, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const devicepicker_changes = {};
      if (dirty[0] & /*imageDevices*/
      128)
        devicepicker_changes.devices = /*imageDevices*/
        ctx2[7];
      if (!updating_deviceId && dirty[0] & /*deviceId*/
      1) {
        updating_deviceId = true;
        devicepicker_changes.deviceId = /*deviceId*/
        ctx2[0];
        add_flush_callback(() => updating_deviceId = false);
      }
      devicepicker.$set(devicepicker_changes);
      if (
        /*deviceId*/
        ctx2[0]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*deviceId*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$7(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const select_changes = {};
      if (dirty[1] & /*$$scope*/
      4) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty[0] & /*refresh*/
      4) {
        updating_value = true;
        select_changes.value = /*refresh*/
        ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      select.$set(select_changes);
      const toggle_changes = {};
      if (dirty[1] & /*$$scope*/
      4) {
        toggle_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_on && dirty[0] & /*hideTitle*/
      8) {
        updating_on = true;
        toggle_changes.on = /*hideTitle*/
        ctx2[3];
        add_flush_callback(() => updating_on = false);
      }
      toggle.$set(toggle_changes);
      if (!/*hideTitle*/
      ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*hideTitle*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$a(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(devicepicker.$$.fragment, local);
      transition_in(if_block0);
      transition_in(select.$$.fragment, local);
      transition_in(toggle.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(devicepicker.$$.fragment, local);
      transition_out(if_block0);
      transition_out(select.$$.fragment, local);
      transition_out(toggle.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div2);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(if_block1_anchor);
      }
      destroy_component(devicepicker, detaching);
      if (if_block0)
        if_block0.d();
      destroy_component(select, detaching);
      destroy_component(toggle, detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  let imageDevices;
  let $devices;
  component_subscribe($$self, devices, ($$value) => $$invalidate(11, $devices = $$value));
  let { settings } = $$props;
  const dispatch = createEventDispatcher();
  const refreshOptions = [
    { value: "0", label: "Never" },
    { value: "1", label: "1 second" },
    { value: "5", label: "5 seconds" },
    { value: "15", label: "15 seconds" },
    { value: "30", label: "30 seconds" },
    { value: "60", label: "1 minute" },
    { value: "300", label: "5 minutes" },
    { value: "600", label: "10 minutes" },
    { value: "1800", label: "30 minutes" },
    { value: "3600", label: "1 hour" },
    { value: "21600", label: "6 hour" },
    { value: "43200", label: "12 hour" },
    { value: "86400", label: "24 hour" }
  ];
  const colorOptions = [
    { value: "black", label: "Black" },
    { value: "white", label: "White" },
    { value: "red", label: "Red" },
    { value: "green", label: "Green" },
    { value: "blue", label: "Blue" }
  ];
  let deviceId;
  let imageId;
  let refresh;
  let hideTitle;
  let fontColor;
  let fontBlur;
  let images = [];
  function onSettings(s3) {
    $$invalidate(0, deviceId = settings == null ? void 0 : settings.deviceId);
    if (deviceId) {
      const image = ($devices[deviceId].images ?? []).find((i2) => i2.id === (settings == null ? void 0 : settings.imageId));
      if (image !== void 0) {
        $$invalidate(1, imageId = { value: image.id, label: image.title });
      }
    }
    $$invalidate(2, refresh = refreshOptions.find((r) => Number(r.value) === ((settings == null ? void 0 : settings.refresh) ?? 0)) ?? refreshOptions[0]);
    $$invalidate(3, hideTitle = (settings == null ? void 0 : settings.hideTitle) ?? false);
    $$invalidate(4, fontColor = colorOptions.find((c2) => c2.value === ((settings == null ? void 0 : settings.fontColor) ?? "black")) ?? colorOptions[0]);
    $$invalidate(5, fontBlur = (settings == null ? void 0 : settings.fontBlur) ?? false);
  }
  function onDevice(value) {
    if (value === void 0) {
      return;
    }
    $$invalidate(6, images = $devices[value].images.map((i2) => ({ value: i2.id, label: i2.title })));
    if (value === settings.deviceId) {
      return;
    }
    $$invalidate(1, imageId = void 0);
    const s3 = { ...settings, deviceId, imageId };
    dispatch("settings", s3);
  }
  function onImage(option) {
    if (option === void 0 || option.value === settings.imageId) {
      return;
    }
    const s3 = { ...settings, imageId: option.value };
    dispatch("settings", s3);
  }
  function onRefresh(option) {
    if (Number(option.value) !== settings.refresh) {
      const s3 = {
        ...settings,
        refresh: Number(option.value)
      };
      dispatch("settings", s3);
    }
  }
  function onHideTitle(value) {
    if (value !== settings.hideTitle) {
      const s3 = { ...settings, hideTitle: value };
      dispatch("settings", s3);
    }
  }
  function onFontColor(option) {
    if (option.value !== settings.fontColor) {
      const s3 = { ...settings, fontColor: option.value };
      dispatch("settings", s3);
    }
  }
  function onFontBlur(value) {
    if (value !== settings.fontBlur) {
      const s3 = { ...settings, fontBlur: value };
      dispatch("settings", s3);
    }
  }
  function devicepicker_deviceId_binding(value) {
    deviceId = value;
    $$invalidate(0, deviceId);
  }
  function select_value_binding(value) {
    imageId = value;
    $$invalidate(1, imageId);
  }
  function select_value_binding_1(value) {
    refresh = value;
    $$invalidate(2, refresh);
  }
  function toggle_on_binding(value) {
    hideTitle = value;
    $$invalidate(3, hideTitle);
  }
  function toggle_on_binding_1(value) {
    fontBlur = value;
    $$invalidate(5, fontBlur);
  }
  function select_value_binding_2(value) {
    fontColor = value;
    $$invalidate(4, fontColor);
  }
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(10, settings = $$props2.settings);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$devices*/
    2048) {
      $$invalidate(7, imageDevices = (Object.values($devices) ?? []).filter((d3) => d3.images.length > 0).sort((a3, b2) => {
        if (a3.name === b2.name)
          return 0;
        if (a3.name < b2.name)
          return -1;
        return 1;
      }));
    }
    if ($$self.$$.dirty[0] & /*settings*/
    1024) {
      onSettings();
    }
    if ($$self.$$.dirty[0] & /*deviceId*/
    1) {
      onDevice(deviceId);
    }
    if ($$self.$$.dirty[0] & /*imageId*/
    2) {
      onImage(imageId);
    }
    if ($$self.$$.dirty[0] & /*refresh*/
    4) {
      onRefresh(refresh);
    }
    if ($$self.$$.dirty[0] & /*hideTitle*/
    8) {
      onHideTitle(hideTitle);
    }
    if ($$self.$$.dirty[0] & /*fontColor*/
    16) {
      onFontColor(fontColor);
    }
    if ($$self.$$.dirty[0] & /*fontBlur*/
    32) {
      onFontBlur(fontBlur);
    }
  };
  return [
    deviceId,
    imageId,
    refresh,
    hideTitle,
    fontColor,
    fontBlur,
    images,
    imageDevices,
    refreshOptions,
    colorOptions,
    settings,
    $devices,
    devicepicker_deviceId_binding,
    select_value_binding,
    select_value_binding_1,
    toggle_on_binding,
    toggle_on_binding_1,
    select_value_binding_2
  ];
}
class ImageEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$d, create_fragment$f, safe_not_equal, { settings: 10 }, null, [-1, -1]);
  }
}
/*!
 * @kurkle/color v0.3.2
 * https://github.com/kurkle/color#readme
 * (c) 2023 Jukka Kurkela
 * Released under the MIT License
 */
function round(v) {
  return v + 0.5 | 0;
}
const lim = (v, l, h4) => Math.max(Math.min(v, h4), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
const map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
const hex = [..."0123456789ABCDEF"];
const h1 = (b2) => hex[b2 & 15];
const h2 = (b2) => hex[(b2 & 240) >> 4] + hex[b2 & 15];
const eq = (b2) => (b2 & 240) >> 4 === (b2 & 15);
const isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
const alpha = (a3, f) => a3 < 255 ? f(a3) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h4, s3, l) {
  const a3 = s3 * Math.min(l, 1 - l);
  const f = (n, k2 = (n + h4 / 30) % 12) => l - a3 * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h4, s3, v) {
  const f = (n, k2 = (n + h4 / 60) % 6) => v - v * s3 * Math.max(Math.min(k2, 4 - k2, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h4, w2, b2) {
  const rgb = hsl2rgbn(h4, 1, 0.5);
  let i2;
  if (w2 + b2 > 1) {
    i2 = 1 / (w2 + b2);
    w2 *= i2;
    b2 *= i2;
  }
  for (i2 = 0; i2 < 3; i2++) {
    rgb[i2] *= 1 - w2 - b2;
    rgb[i2] += w2;
  }
  return rgb;
}
function hueValue(r, g, b2, d3, max2) {
  if (r === max2) {
    return (g - b2) / d3 + (g < b2 ? 6 : 0);
  }
  if (g === max2) {
    return (b2 - r) / d3 + 2;
  }
  return (r - g) / d3 + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b2 = v.b / range;
  const max2 = Math.max(r, g, b2);
  const min2 = Math.min(r, g, b2);
  const l = (max2 + min2) / 2;
  let h4, s3, d3;
  if (max2 !== min2) {
    d3 = max2 - min2;
    s3 = l > 0.5 ? d3 / (2 - max2 - min2) : d3 / (max2 + min2);
    h4 = hueValue(r, g, b2, d3, max2);
    h4 = h4 * 60 + 0.5;
  }
  return [h4 | 0, s3 || 0, l];
}
function calln(f, a3, b2, c2) {
  return (Array.isArray(a3) ? f(a3[0], a3[1], a3[2]) : f(a3, b2, c2)).map(n2b);
}
function hsl2rgb(h4, s3, l) {
  return calln(hsl2rgbn, h4, s3, l);
}
function hwb2rgb(h4, w2, b2) {
  return calln(hwb2rgbn, h4, w2, b2);
}
function hsv2rgb(h4, s3, v) {
  return calln(hsv2rgbn, h4, s3, v);
}
function hue(h4) {
  return (h4 % 360 + 360) % 360;
}
function hueParse(str) {
  const m3 = HUE_RE.exec(str);
  let a3 = 255;
  let v;
  if (!m3) {
    return;
  }
  if (m3[5] !== v) {
    a3 = m3[6] ? p2b(+m3[5]) : n2b(+m3[5]);
  }
  const h4 = hue(+m3[2]);
  const p1 = +m3[3] / 100;
  const p2 = +m3[4] / 100;
  if (m3[1] === "hwb") {
    v = hwb2rgb(h4, p1, p2);
  } else if (m3[1] === "hsv") {
    v = hsv2rgb(h4, p1, p2);
  } else {
    v = hsl2rgb(h4, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a: a3
  };
}
function rotate(v, deg) {
  var h4 = rgb2hsl(v);
  h4[0] = hue(h4[0] + deg);
  h4 = hsl2rgb(h4);
  v.r = h4[0];
  v.g = h4[1];
  v.b = h4[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a3 = rgb2hsl(v);
  const h4 = a3[0];
  const s3 = n2p(a3[1]);
  const l = n2p(a3[2]);
  return v.a < 255 ? `hsla(${h4}, ${s3}%, ${l}%, ${b2n(v.a)})` : `hsl(${h4}, ${s3}%, ${l}%)`;
}
const map$2 = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
const names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map$2);
  let i2, j, k2, ok, nk;
  for (i2 = 0; i2 < keys.length; i2++) {
    ok = nk = keys[i2];
    for (j = 0; j < tkeys.length; j++) {
      k2 = tkeys[j];
      nk = nk.replace(k2, map$2[k2]);
    }
    k2 = parseInt(names$1[ok], 16);
    unpacked[nk] = [k2 >> 16 & 255, k2 >> 8 & 255, k2 & 255];
  }
  return unpacked;
}
let names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a3 = names[str.toLowerCase()];
  return a3 && {
    r: a3[0],
    g: a3[1],
    b: a3[2],
    a: a3.length === 4 ? a3[3] : 255
  };
}
const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m3 = RGB_RE.exec(str);
  let a3 = 255;
  let r, g, b2;
  if (!m3) {
    return;
  }
  if (m3[7] !== r) {
    const v = +m3[7];
    a3 = m3[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m3[1];
  g = +m3[3];
  b2 = +m3[5];
  r = 255 & (m3[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m3[4] ? p2b(g) : lim(g, 0, 255));
  b2 = 255 & (m3[6] ? p2b(b2) : lim(b2, 0, 255));
  return {
    r,
    g,
    b: b2,
    a: a3
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
const to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
const from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate$1(rgb1, rgb2, t2) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b2 = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t2 * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t2 * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b2 + t2 * (from(b2n(rgb2.b)) - b2))),
    a: rgb1.a + t2 * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i2, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i2] = Math.max(0, Math.min(tmp[i2] + tmp[i2] * ratio, i2 === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone$1(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone$1(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
class Color {
  constructor(input) {
    if (input instanceof Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone$1(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w3 = 2 * p - 1;
      const a3 = c1.a - c2.a;
      const w1 = ((w3 * a3 === -1 ? w3 : (w3 + a3) / (1 + w3 * a3)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t2) {
    if (color2) {
      this._rgb = interpolate$1(this._rgb, color2._rgb, t2);
    }
    return this;
  }
  clone() {
    return new Color(this.rgb);
  }
  alpha(a3) {
    this._rgb.a = n2b(a3);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
}
/*!
 * Chart.js v4.3.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */
function noop() {
}
const uid = (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value) {
  return value === null || typeof value === "undefined";
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
const toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
const toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn2, args, thisArg) {
  if (fn2 && typeof fn2.call === "function") {
    return fn2.apply(thisArg, args);
  }
}
function each(loopable, fn2, thisArg, reverse) {
  let i2, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i2 = len - 1; i2 >= 0; i2--) {
        fn2.call(thisArg, loopable[i2], i2);
      }
    } else {
      for (i2 = 0; i2 < len; i2++) {
        fn2.call(thisArg, loopable[i2], i2);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i2 = 0; i2 < len; i2++) {
      fn2.call(thisArg, loopable[keys[i2]], keys[i2]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i2, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i2 = 0, ilen = a0.length; i2 < ilen; ++i2) {
    v0 = a0[i2];
    v1 = a1[i2];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone(source) {
  if (isArray(source)) {
    return source.map(clone);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k2 = 0;
    for (; k2 < klen; ++k2) {
      target[keys[k2]] = clone(source[keys[k2]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target, source, options) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options);
  } else {
    target[key] = clone(sval);
  }
}
function merge(target, source, options) {
  const sources = isArray(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options = options || {};
  const merger = options.merger || _merger;
  let current;
  for (let i2 = 0; i2 < ilen; ++i2) {
    current = sources[i2];
    if (!isObject(current)) {
      continue;
    }
    const keys = Object.keys(current);
    for (let k2 = 0, klen = keys.length; k2 < klen; ++k2) {
      merger(keys[k2], target, current, options);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone(sval);
  }
}
const keyResolvers = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (v) => v,
  // default resolvers
  x: (o) => o.x,
  y: (o) => o.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k2 of keys) {
      if (k2 === "") {
        break;
      }
      obj = obj && obj[k2];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
const defined = (value) => typeof value !== "undefined";
const isFunction = (value) => typeof value === "function";
const setsEqual = (a3, b2) => {
  if (a3.size !== b2.size) {
    return false;
  }
  for (const item of a3) {
    if (!b2.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e2) {
  return e2.type === "mouseup" || e2.type === "click" || e2.type === "contextmenu";
}
const PI = Math.PI;
const TAU = 2 * PI;
const PITAU = TAU + PI;
const INFINITY = Number.POSITIVE_INFINITY;
const RAD_PER_DEG = PI / 180;
const HALF_PI = PI / 2;
const QUARTER_PI = PI / 4;
const TWO_THIRDS_PI = PI * 2 / 3;
const log10 = Math.log10;
const sign = Math.sign;
function almostEquals(x2, y3, epsilon) {
  return Math.abs(x2 - y3) < epsilon;
}
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i2;
  for (i2 = 1; i2 < sqrt; i2++) {
    if (value % i2 === 0) {
      result.push(i2);
      result.push(value / i2);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a3, b2) => a3 - b2).pop();
  return result;
}
function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x2, epsilon) {
  const rounded = Math.round(x2);
  return rounded - epsilon <= x2 && rounded + epsilon >= x2;
}
function _setMinAndMaxByKey(array, target, property) {
  let i2, ilen, value;
  for (i2 = 0, ilen = array.length; i2 < ilen; i2++) {
    value = array[i2][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x2) {
  if (!isNumberFinite(x2)) {
    return;
  }
  let e2 = 1;
  let p = 0;
  while (Math.round(x2 * e2) / e2 !== x2) {
    e2 *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a3, b2) {
  return (a3 - b2 + PITAU) % TAU - PI;
}
function _normalizeAngle(a3) {
  return (a3 % TAU + TAU) % TAU;
}
function _angleBetween(angle, start2, end2, sameAngleIsFullCircle) {
  const a3 = _normalizeAngle(angle);
  const s3 = _normalizeAngle(start2);
  const e2 = _normalizeAngle(end2);
  const angleToStart = _normalizeAngle(s3 - a3);
  const angleToEnd = _normalizeAngle(e2 - a3);
  const startToAngle = _normalizeAngle(a3 - s3);
  const endToAngle = _normalizeAngle(a3 - e2);
  return a3 === s3 || a3 === e2 || sameAngleIsFullCircle && s3 === e2 || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min2, max2) {
  return Math.max(min2, Math.min(max2, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start2, end2, epsilon = 1e-6) {
  return value >= Math.min(start2, end2) - epsilon && value <= Math.max(start2, end2) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index2) => table[index2] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
const _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
  const ti = table[index2][key];
  return ti < value || ti === value && table[index2 + 1][key] === value;
} : (index2) => table[index2][key] < value);
const _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
function _filterBetween(values, min2, max2) {
  let start2 = 0;
  let end2 = values.length;
  while (start2 < end2 && values[start2] < min2) {
    start2++;
  }
  while (end2 > start2 && values[end2 - 1] > max2) {
    end2--;
  }
  return start2 > 0 || end2 < values.length ? values.slice(start2, end2) : values;
}
const arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set(items);
  if (set2.size === items.length) {
    return items;
  }
  return Array.from(set2);
}
const requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn2, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn2.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce(fn2, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn2, delay, args);
    } else {
      fn2.apply(this, args);
    }
    return delay;
  };
}
const _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
const _alignStartEnd = (align, start2, end2) => align === "start" ? start2 : align === "end" ? end2 : (start2 + end2) / 2;
const _textX = (align, left2, right2, rtl) => {
  const check2 = rtl ? "left" : "right";
  return align === check2 ? right2 : align === "center" ? (left2 + right2) / 2 : left2;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start2 = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, _parsed } = meta;
    const axis = iScale.axis;
    const { min: min2, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start2 = _limitValue(Math.min(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, iScale.axis, min2).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min2)).lo
      ), 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(Math.max(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, iScale.axis, max2, true).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max2), true).hi + 1
      ), start2, pointCount) - start2;
    } else {
      count = pointCount - start2;
    }
  }
  return {
    start: start2,
    count
  };
}
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
const atEdge = (t2) => t2 === 0 || t2 === 1;
const elasticIn = (t2, s3, p) => -(Math.pow(2, 10 * (t2 -= 1)) * Math.sin((t2 - s3) * TAU / p));
const elasticOut = (t2, s3, p) => Math.pow(2, -10 * t2) * Math.sin((t2 - s3) * TAU / p) + 1;
const effects = {
  linear: (t2) => t2,
  easeInQuad: (t2) => t2 * t2,
  easeOutQuad: (t2) => -t2 * (t2 - 2),
  easeInOutQuad: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 : -0.5 * (--t2 * (t2 - 2) - 1),
  easeInCubic: (t2) => t2 * t2 * t2,
  easeOutCubic: (t2) => (t2 -= 1) * t2 * t2 + 1,
  easeInOutCubic: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 + 2),
  easeInQuart: (t2) => t2 * t2 * t2 * t2,
  easeOutQuart: (t2) => -((t2 -= 1) * t2 * t2 * t2 - 1),
  easeInOutQuart: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 : -0.5 * ((t2 -= 2) * t2 * t2 * t2 - 2),
  easeInQuint: (t2) => t2 * t2 * t2 * t2 * t2,
  easeOutQuint: (t2) => (t2 -= 1) * t2 * t2 * t2 * t2 + 1,
  easeInOutQuint: (t2) => (t2 /= 0.5) < 1 ? 0.5 * t2 * t2 * t2 * t2 * t2 : 0.5 * ((t2 -= 2) * t2 * t2 * t2 * t2 + 2),
  easeInSine: (t2) => -Math.cos(t2 * HALF_PI) + 1,
  easeOutSine: (t2) => Math.sin(t2 * HALF_PI),
  easeInOutSine: (t2) => -0.5 * (Math.cos(PI * t2) - 1),
  easeInExpo: (t2) => t2 === 0 ? 0 : Math.pow(2, 10 * (t2 - 1)),
  easeOutExpo: (t2) => t2 === 1 ? 1 : -Math.pow(2, -10 * t2) + 1,
  easeInOutExpo: (t2) => atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * Math.pow(2, 10 * (t2 * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t2 * 2 - 1)) + 2),
  easeInCirc: (t2) => t2 >= 1 ? t2 : -(Math.sqrt(1 - t2 * t2) - 1),
  easeOutCirc: (t2) => Math.sqrt(1 - (t2 -= 1) * t2),
  easeInOutCirc: (t2) => (t2 /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t2 * t2) - 1) : 0.5 * (Math.sqrt(1 - (t2 -= 2) * t2) + 1),
  easeInElastic: (t2) => atEdge(t2) ? t2 : elasticIn(t2, 0.075, 0.3),
  easeOutElastic: (t2) => atEdge(t2) ? t2 : elasticOut(t2, 0.075, 0.3),
  easeInOutElastic(t2) {
    const s3 = 0.1125;
    const p = 0.45;
    return atEdge(t2) ? t2 : t2 < 0.5 ? 0.5 * elasticIn(t2 * 2, s3, p) : 0.5 + 0.5 * elasticOut(t2 * 2 - 1, s3, p);
  },
  easeInBack(t2) {
    const s3 = 1.70158;
    return t2 * t2 * ((s3 + 1) * t2 - s3);
  },
  easeOutBack(t2) {
    const s3 = 1.70158;
    return (t2 -= 1) * t2 * ((s3 + 1) * t2 + s3) + 1;
  },
  easeInOutBack(t2) {
    let s3 = 1.70158;
    if ((t2 /= 0.5) < 1) {
      return 0.5 * (t2 * t2 * (((s3 *= 1.525) + 1) * t2 - s3));
    }
    return 0.5 * ((t2 -= 2) * t2 * (((s3 *= 1.525) + 1) * t2 + s3) + 2);
  },
  easeInBounce: (t2) => 1 - effects.easeOutBounce(1 - t2),
  easeOutBounce(t2) {
    const m3 = 7.5625;
    const d3 = 2.75;
    if (t2 < 1 / d3) {
      return m3 * t2 * t2;
    }
    if (t2 < 2 / d3) {
      return m3 * (t2 -= 1.5 / d3) * t2 + 0.75;
    }
    if (t2 < 2.5 / d3) {
      return m3 * (t2 -= 2.25 / d3) * t2 + 0.9375;
    }
    return m3 * (t2 -= 2.625 / d3) * t2 + 0.984375;
  },
  easeInOutBounce: (t2) => t2 < 0.5 ? effects.easeInBounce(t2 * 2) * 0.5 : effects.easeOutBounce(t2 * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}
const numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
const colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults2) {
  defaults2.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults2.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults2.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults2.describe("animations", {
    _fallback: "animation"
  });
  defaults2.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults2) {
  defaults2.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale2, options) {
  options = options || {};
  const cacheKey = locale2 + JSON.stringify(options);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale2, options);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale2, options) {
  return getNumberFormat(locale2, options).format(num);
}
const formatters$4 = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale2 = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options, this.options.ticks.format);
    return formatNumber(tickValue, locale2, options);
  },
  logarithmic(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index2 > 0.8 * ticks.length) {
      return formatters$4.numeric.call(this, tickValue, index2, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters: formatters$4
};
function applyScaleDefaults(defaults2) {
  defaults2.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options) => options.lineWidth,
      tickColor: (_ctx, options) => options.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults2.route("scale.ticks", "color", "", "color");
  defaults2.route("scale.grid", "color", "", "borderColor");
  defaults2.route("scale.border", "color", "", "borderColor");
  defaults2.route("scale.title", "color", "", "color");
  defaults2.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
  });
  defaults2.describe("scales", {
    _fallback: "scale"
  });
  defaults2.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
}
const overrides = /* @__PURE__ */ Object.create(null);
const descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i2 = 0, n = keys.length; i2 < n; ++i2) {
    const k2 = keys[i2];
    node = node[k2] || (node[k2] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
class Defaults {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
    this.hoverColor = (ctx, options) => getHoverColor(options.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
}
var defaults = /* @__PURE__ */ new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i2, j, jlen, thing, nestedThing;
  for (i2 = 0; i2 < ilen; i2++) {
    thing = arrayOfThings[i2];
    if (thing !== void 0 && thing !== null && !isArray(thing)) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i2 = 0; i2 < gcLen; i2++) {
      delete data[gc[i2]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width2) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width2 !== 0 ? Math.max(width2 / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options, x2, y3) {
  drawPointLegend(ctx, options, x2, y3, null);
}
function drawPointLegend(ctx, options, x2, y3, w2) {
  let type, xOffset, yOffset, size, cornerRadius, width2, xOffsetW, yOffsetW;
  const style = options.pointStyle;
  const rotation = options.rotation;
  const radius2 = options.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x2, y3);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius2) || radius2 <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w2) {
        ctx.ellipse(x2, y3, w2 / 2, radius2, 0, 0, TAU);
      } else {
        ctx.arc(x2, y3, radius2, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width2 = w2 ? w2 / 2 : radius2;
      ctx.moveTo(x2 + Math.sin(rad) * width2, y3 - Math.cos(rad) * radius2);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x2 + Math.sin(rad) * width2, y3 - Math.cos(rad) * radius2);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x2 + Math.sin(rad) * width2, y3 - Math.cos(rad) * radius2);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius2 * 0.516;
      size = radius2 - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w2 ? w2 / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w2 ? w2 / 2 - cornerRadius : size);
      ctx.arc(x2 - xOffsetW, y3 - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x2 + yOffsetW, y3 - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x2 + xOffsetW, y3 + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x2 - yOffsetW, y3 + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius2;
        width2 = w2 ? w2 / 2 : size;
        ctx.rect(x2 - width2, y3 - size, 2 * width2, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius2);
      xOffset = Math.cos(rad) * radius2;
      yOffset = Math.sin(rad) * radius2;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius2);
      ctx.moveTo(x2 - xOffsetW, y3 - yOffset);
      ctx.lineTo(x2 + yOffsetW, y3 - xOffset);
      ctx.lineTo(x2 + xOffsetW, y3 + yOffset);
      ctx.lineTo(x2 - yOffsetW, y3 + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius2);
      xOffset = Math.cos(rad) * radius2;
      yOffset = Math.sin(rad) * radius2;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius2);
      ctx.moveTo(x2 - xOffsetW, y3 - yOffset);
      ctx.lineTo(x2 + xOffsetW, y3 + yOffset);
      ctx.moveTo(x2 + yOffsetW, y3 - xOffset);
      ctx.lineTo(x2 - yOffsetW, y3 + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius2);
      xOffset = Math.cos(rad) * radius2;
      yOffset = Math.sin(rad) * radius2;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius2);
      ctx.moveTo(x2 - xOffsetW, y3 - yOffset);
      ctx.lineTo(x2 + xOffsetW, y3 + yOffset);
      ctx.moveTo(x2 + yOffsetW, y3 - xOffset);
      ctx.lineTo(x2 - yOffsetW, y3 + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w2 ? w2 / 2 : radius2);
      xOffset = Math.cos(rad) * radius2;
      yOffset = Math.sin(rad) * radius2;
      yOffsetW = Math.sin(rad) * (w2 ? w2 / 2 : radius2);
      ctx.moveTo(x2 - xOffsetW, y3 - yOffset);
      ctx.lineTo(x2 + xOffsetW, y3 + yOffset);
      ctx.moveTo(x2 + yOffsetW, y3 - xOffset);
      ctx.lineTo(x2 - yOffsetW, y3 + xOffset);
      break;
    case "line":
      xOffset = w2 ? w2 / 2 : Math.cos(rad) * radius2;
      yOffset = Math.sin(rad) * radius2;
      ctx.moveTo(x2 - xOffset, y3 - yOffset);
      ctx.lineTo(x2 + xOffset, y3 + yOffset);
      break;
    case "dash":
      ctx.moveTo(x2, y3);
      ctx.lineTo(x2 + Math.cos(rad) * (w2 ? w2 / 2 : radius2), y3 + Math.sin(rad) * radius2);
      break;
    case false:
      ctx.closePath();
      break;
  }
  ctx.fill();
  if (options.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip2, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip2) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip2) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip2 ? previous.cp1x : previous.cp2x, flip2 ? previous.cp1y : previous.cp2y, flip2 ? target.cp2x : target.cp1x, flip2 ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x2, y3, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left2 = x2 - metrics.actualBoundingBoxLeft;
    const right2 = x2 + metrics.actualBoundingBoxRight;
    const top2 = y3 - metrics.actualBoundingBoxAscent;
    const bottom2 = y3 + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top2 + bottom2) / 2 : bottom2;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left2, yDecoration);
    ctx.lineTo(right2, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function renderText(ctx, text2, x2, y3, font, opts = {}) {
  const lines = isArray(text2) ? text2 : [
    text2
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i2, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i2 = 0; i2 < lines.length; ++i2) {
    line = lines[i2];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x2, y3, opts.maxWidth);
    }
    ctx.fillText(line, x2, y3, opts.maxWidth);
    decorateText(ctx, x2, y3, line, opts);
    y3 += Number(font.lineHeight);
  }
  ctx.restore();
}
function addRoundedRectPath(ctx, rect) {
  const { x: x2, y: y3, w: w2, h: h4, radius: radius2 } = rect;
  ctx.arc(x2 + radius2.topLeft, y3 + radius2.topLeft, radius2.topLeft, -HALF_PI, PI, true);
  ctx.lineTo(x2, y3 + h4 - radius2.bottomLeft);
  ctx.arc(x2 + radius2.bottomLeft, y3 + h4 - radius2.bottomLeft, radius2.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x2 + w2 - radius2.bottomRight, y3 + h4);
  ctx.arc(x2 + w2 - radius2.bottomRight, y3 + h4 - radius2.bottomRight, radius2.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x2 + w2, y3 + radius2.topRight);
  ctx.arc(x2 + w2 - radius2.topRight, y3 + radius2.topRight, radius2.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x2 + radius2.topLeft, y3);
}
const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
const numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read2 = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read2(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options, fallback) {
  options = options || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index2, info2) {
  let cacheable = true;
  let i2, ilen, value;
  for (i2 = 0, ilen = inputs.length; i2 < ilen; ++i2) {
    value = inputs[i2];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index2 !== void 0 && isArray(value)) {
      value = value[index2 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info2 && !cacheable) {
        info2.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min: min2, max: max2 } = minmax;
  const change = toDimension(grace, (max2 - min2) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min2, -Math.abs(change)),
    max: keepZero(max2, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes2, prefixes = [
  ""
], rootScopes, fallback, getTarget = () => scopes2[0]) {
  const finalRootScopes = rootScopes || scopes2;
  if (typeof fallback === "undefined") {
    fallback = _resolve("_fallback", scopes2);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes2,
    _rootScopes: finalRootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes2
    ], prefixes, finalRootScopes, fallback)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes2[0][prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes2, target));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes2[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
const needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop)) {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  let value = getValue(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (typeof _context.index !== "undefined" && isIndexable(prop)) {
    return value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes2 = _proxy._scopes.filter((s3) => s3 !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes2, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
const getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (typeof fallback !== "undefined" && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes2, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes2);
    if (typeof value !== "undefined") {
      return needsSubResolver(prop, value) ? createSubResolver(scopes2, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes2) {
  for (const scope of scopes2) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (typeof value !== "undefined") {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes2) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes2) {
    for (const key of Object.keys(scope).filter((k2) => !k2.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
function _parseObjectDataRadialScale(meta, data, start2, count) {
  const { iScale } = meta;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i2, ilen, index2, item;
  for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
    index2 = i2 + start2;
    item = data[index2];
    parsed[i2] = {
      r: iScale.parse(resolveObjectKey(item, key), index2)
    };
  }
  return parsed;
}
const EPSILON = Number.EPSILON || 1e-14;
const getPoint = (points, i2) => i2 < points.length && !points[i2].skip && points[i2];
const getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t2) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t2 * s01;
  const fb = t2 * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i2 = 0; i2 < pointsLen - 1; ++i2) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i2 + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i2], 0, EPSILON)) {
      mK[i2] = mK[i2 + 1] = 0;
      continue;
    }
    alphaK = mK[i2] / deltaK[i2];
    betaK = mK[i2 + 1] / deltaK[i2];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i2] = alphaK * tauK * deltaK[i2];
    mK[i2 + 1] = betaK * tauK * deltaK[i2];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i2 = 0; i2 < pointsLen; ++i2) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i2 + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i2];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i2];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i2, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i2 = 0; i2 < pointsLen; ++i2) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i2 + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i2] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i2] = !pointBefore ? deltaK[i2] : !pointAfter ? deltaK[i2 - 1] : sign(deltaK[i2 - 1]) !== sign(deltaK[i2]) ? 0 : (deltaK[i2 - 1] + deltaK[i2]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min2, max2) {
  return Math.max(Math.min(pt, max2), min2);
}
function capBezierPoints(points, area) {
  let i2, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i2 < ilen - 1 && _isPointInArea(points[i2 + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i2];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options, area, loop2, indexAxis) {
  let i2, ilen, point, controlPoints;
  if (options.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop2 ? points[points.length - 1] : points[0];
    for (i2 = 0, ilen = points.length; i2 < ilen; ++i2) {
      point = points[i2];
      controlPoints = splineCurve(prev, point, points[Math.min(i2 + 1, ilen - (loop2 ? 0 : 1)) % ilen], options.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
const getComputedStyle$1 = (element2) => element2.ownerDocument.defaultView.getComputedStyle(element2, null);
function getStyle(el, property) {
  return getComputedStyle$1(el).getPropertyValue(property);
}
const positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i2 = 0; i2 < 4; i2++) {
    const pos = positions[i2];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
const useOffsetPos = (x2, y3, target) => (x2 > 0 || y3 > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e2, canvas) {
  const touches = e2.touches;
  const source = touches && touches.length ? touches[0] : e2;
  const { offsetX, offsetY } = source;
  let box = false;
  let x2, y3;
  if (useOffsetPos(offsetX, offsetY, e2.target)) {
    x2 = offsetX;
    y3 = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x2 = source.clientX - rect.left;
    y3 = source.clientY - rect.top;
    box = true;
  }
  return {
    x: x2,
    y: y3,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle$1(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x: x2, y: y3, box } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width: width2, height } = chart;
  if (borderBox) {
    width2 -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x2 - xOffset) / width2 * canvas.width / currentDevicePixelRatio),
    y: Math.round((y3 - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width2, height) {
  let maxWidth, maxHeight;
  if (width2 === void 0 || height === void 0) {
    const container = _getParentNode(canvas);
    if (!container) {
      width2 = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle$1(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width2 = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width: width2,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
const round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle$1(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width: width2, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width2 -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width2 = Math.max(0, width2 - margins.width);
  height = Math.max(0, aspectRatio ? width2 / aspectRatio : height - margins.height);
  width2 = round1(Math.min(width2, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width2 && !height) {
    height = round1(width2 / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width2 = round1(Math.floor(height * aspectRatio));
  }
  return {
    width: width2,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
const supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    window.addEventListener("test", null, options);
    window.removeEventListener("test", null, options);
  } catch (e2) {
  }
  return passiveSupported;
}();
function readUsedSize(element2, property) {
  const value = getStyle(element2, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t2, mode) {
  return {
    x: p1.x + t2 * (p2.x - p1.x),
    y: p1.y + t2 * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t2, mode) {
  return {
    x: p1.x + t2 * (p2.x - p1.x),
    y: mode === "middle" ? t2 < 0.5 ? p1.y : p2.y : mode === "after" ? t2 < 1 ? p1.y : p2.y : t2 > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t2, mode) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p2.cp1x,
    y: p2.cp1y
  };
  const a3 = _pointInLine(p1, cp1, t2);
  const b2 = _pointInLine(cp1, cp2, t2);
  const c2 = _pointInLine(cp2, p2, t2);
  const d3 = _pointInLine(a3, b2, t2);
  const e2 = _pointInLine(b2, c2, t2);
  return _pointInLine(d3, e2, t2);
}
const getRightToLeftAdapter = function(rectX, width2) {
  return {
    x(x2) {
      return rectX + rectX + width2 - x2;
    },
    setWidth(w2) {
      width2 = w2;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x2, value) {
      return x2 - value;
    },
    leftForLtr(x2, itemWidth) {
      return x2 - itemWidth;
    }
  };
};
const getLeftToRightAdapter = function() {
  return {
    x(x2) {
      return x2;
    },
    setWidth(w2) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x2, value) {
      return x2 + value;
    },
    leftForLtr(x2, _itemWidth) {
      return x2;
    }
  };
};
function getRtlAdapter(rtl, rectX, width2) {
  return rtl ? getRightToLeftAdapter(rectX, width2) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a3, b2) => a3 - b2,
    normalize: (x2) => x2
  };
}
function normalizeSegment({ start: start2, end: end2, count, loop: loop2, style }) {
  return {
    start: start2 % count,
    end: end2 % count,
    loop: loop2 && (end2 - start2 + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize: normalize2 } = propertyFn(property);
  const count = points.length;
  let { start: start2, end: end2, loop: loop2 } = segment;
  let i2, ilen;
  if (loop2) {
    start2 += count;
    end2 += count;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      if (!between(normalize2(points[start2 % count][property]), startBound, endBound)) {
        break;
      }
      start2--;
      end2--;
    }
    start2 %= count;
    end2 %= count;
  }
  if (end2 < start2) {
    end2 += count;
  }
  return {
    start: start2,
    end: end2,
    loop: loop2,
    style: segment.style
  };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [
      segment
    ];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize: normalize2 } = propertyFn(property);
  const { start: start2, end: end2, loop: loop2, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i2 = start2, prev = start2; i2 <= end2; ++i2) {
    point = points[i2 % count];
    if (point.skip) {
      continue;
    }
    value = normalize2(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i2 : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({
        start: subStart,
        end: i2,
        loop: loop2,
        count,
        style
      }));
      subStart = null;
    }
    prev = i2;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({
      start: subStart,
      end: end2,
      loop: loop2,
      count,
      style
    }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i2 = 0; i2 < segments.length; i2++) {
    const sub = _boundSegment(segments[i2], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop2, spanGaps) {
  let start2 = 0;
  let end2 = count - 1;
  if (loop2 && !spanGaps) {
    while (start2 < count && !points[start2].skip) {
      start2++;
    }
  }
  while (start2 < count && points[start2].skip) {
    start2++;
  }
  start2 %= count;
  if (loop2) {
    end2 += start2;
  }
  while (end2 > start2 && points[end2 % count].skip) {
    end2--;
  }
  end2 %= count;
  return {
    start: start2,
    end: end2
  };
}
function solidSegments(points, start2, max2, loop2) {
  const count = points.length;
  const result = [];
  let last = start2;
  let prev = points[start2];
  let end2;
  for (end2 = start2 + 1; end2 <= max2; ++end2) {
    const cur = points[end2 % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop2 = false;
        result.push({
          start: start2 % count,
          end: (end2 - 1) % count,
          loop: loop2
        });
        start2 = last = cur.stop ? end2 : null;
      }
    } else {
      last = end2;
      if (prev.skip) {
        start2 = end2;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({
      start: start2 % count,
      end: last % count,
      loop: loop2
    });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop2 = !!line._loop;
  const { start: start2, end: end2 } = findStartAndEnd(points, count, loop2, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [
      {
        start: start2,
        end: end2,
        loop: loop2
      }
    ], points, segmentOptions);
  }
  const max2 = end2 < start2 ? end2 + count : end2;
  const completeLoop = !!line._fullLoop && start2 === 0 && end2 === count - 1;
  return splitByStyles(line, solidSegments(points, start2, max2, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start2 = segments[0].start;
  let i2 = start2;
  function addStyle(s3, e2, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s3 === e2) {
      return;
    }
    s3 += count;
    while (points[s3 % count].skip) {
      s3 -= dir;
    }
    while (points[e2 % count].skip) {
      e2 += dir;
    }
    if (s3 % count !== e2 % count) {
      result.push({
        start: s3 % count,
        end: e2 % count,
        loop: l,
        style: st
      });
      prevStyle = st;
      start2 = e2 % count;
    }
  }
  for (const segment of segments) {
    start2 = spanGaps ? start2 : segment.start;
    let prev = points[start2 % count];
    let style;
    for (i2 = start2 + 1; i2 <= segment.end; i2++) {
      const pt = points[i2 % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i2 - 1) % count,
        p1DataIndex: i2 % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start2, i2 - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start2 < i2 - 1) {
      addStyle(start2, i2 - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options) {
  return {
    backgroundColor: options.backgroundColor,
    borderCapStyle: options.borderCapStyle,
    borderDash: options.borderDash,
    borderDashOffset: options.borderDashOffset,
    borderJoinStyle: options.borderJoinStyle,
    borderWidth: options.borderWidth,
    borderColor: options.borderColor
  };
}
function styleChanged(style, prevStyle) {
  if (!prevStyle) {
    return false;
  }
  const cache = [];
  const replacer = function(key, value) {
    if (!isPatternOrGradient(value)) {
      return value;
    }
    if (!cache.includes(value)) {
      cache.push(value);
    }
    return cache.indexOf(value);
  };
  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}
/*!
 * Chart.js v4.3.0
 * https://www.chartjs.org
 * (c) 2023 Chart.js Contributors
 * Released under the MIT License
 */
class Animator {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn2) => fn2({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i2 = items.length - 1;
      let draw2 = false;
      let item;
      for (; i2 >= 0; --i2) {
        item = items[i2];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i2] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i2 = items.length - 1;
    for (; i2 >= 0; --i2) {
      items[i2].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
}
var animator = /* @__PURE__ */ new Animator();
const transparent = "transparent";
const interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
class Animation {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([
      cfg.to,
      to2,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to2
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop2 = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop2 || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop2 && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i2 = 0; i2 < promises.length; i2++) {
      promises[i2][method]();
    }
  }
}
class Animations {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options = resolveTargetOptions(target, newOptions);
    if (!options) {
      return [];
    }
    const animations = this._createAnimations(options, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i2;
    for (i2 = props.length - 1; i2 >= 0; --i2) {
      const prop = props[i2];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
}
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i2 = 0; i2 < keys.length; i2++) {
    const anim = animations[keys[i2]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options = target.options;
  if (!options) {
    target.options = newOptions;
    return;
  }
  if (options.$shared) {
    target.options = options = Object.assign({}, options, {
      $shared: false,
      $animations: {}
    });
  }
  return options;
}
function scaleClip(scale2, allowedOverflow) {
  const opts = scale2 && scale2.options || {};
  const reverse = opts.reverse;
  const min2 = opts.min === void 0 ? allowedOverflow : 0;
  const max2 = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max2 : min2,
    end: reverse ? min2 : max2
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x2 = scaleClip(xScale, allowedOverflow);
  const y3 = scaleClip(yScale, allowedOverflow);
  return {
    top: y3.end,
    right: x2.end,
    bottom: y3.start,
    left: x2.start
  };
}
function toClip(value) {
  let t2, r, b2, l;
  if (isObject(value)) {
    t2 = value.top;
    r = value.right;
    b2 = value.bottom;
    l = value.left;
  } else {
    t2 = r = b2 = l = value;
  }
  return {
    top: t2,
    right: r,
    bottom: b2,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i2, ilen;
  for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
    keys.push(metasets[i2].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options = {}) {
  const keys = stack.keys;
  const singleMode = options.mode === "single";
  let i2, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
    datasetIndex = +keys[i2];
    if (datasetIndex === dsIndex) {
      if (options.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  return value;
}
function convertObjectDataToArray(data) {
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i2, ilen, key;
  for (i2 = 0, ilen = keys.length; i2 < ilen; ++i2) {
    key = keys[i2];
    adata[i2] = {
      x: key,
      y: data[key]
    };
  }
  return adata;
}
function isStacked(scale2, meta) {
  const stacked = scale2 && scale2.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale2) {
  const { min: min2, max: max2, minDefined, maxDefined } = scale2.getUserBounds();
  return {
    min: minDefined ? min2 : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max2 : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i2 = 0; i2 < ilen; ++i2) {
    const item = parsed[i2];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index2) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index2,
    index: index2,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index2, element2) {
  return createContext(parent, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element: element2,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
const isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
class DatasetController {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x2, y3, r) => axis === "x" ? x2 : axis === "r" ? r : y3;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale2) {
    const meta = this._cachedMeta;
    return scale2 === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      this._data = convertObjectDataToArray(data);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes2 = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes2, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start2, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start2 === 0 && count === data.length ? true : meta._sorted;
    let prev = start2 > 0 && meta._parsed[start2 - 1];
    let i2, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start2])) {
        parsed = this.parseArrayData(meta, data, start2, count);
      } else if (isObject(data[start2])) {
        parsed = this.parseObjectData(meta, data, start2, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start2, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i2 = 0; i2 < count; ++i2) {
        meta._parsed[i2 + start2] = cur = parsed[i2];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start2, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i2, ilen, index2;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start2;
      parsed[i2] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start2, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i2, ilen, index2, item;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start2;
      item = data[index2];
      parsed[i2] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start2, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i2, ilen, index2, item;
    for (i2 = 0, ilen = count; i2 < ilen; ++i2) {
      index2 = i2 + start2;
      item = data[index2];
      parsed[i2] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale2, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale2.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale2.axis]._visualValues
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range, scale2, parsed, stack) {
    const parsedValue = parsed[scale2.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale2.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale2, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale2 === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale2);
    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i2, parsed;
    function _skip() {
      parsed = _parsed[i2];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale2.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i2 = 0; i2 < ilen; ++i2) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale2, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i2 = ilen - 1; i2 >= 0; --i2) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale2, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale2) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i2, ilen, value;
    for (i2 = 0, ilen = parsed.length; i2 < ilen; ++i2) {
      value = parsed[i2][scale2.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start2 = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start2;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i2;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start2, count);
    }
    for (i2 = start2; i2 < start2 + count; ++i2) {
      const element2 = elements2[i2];
      if (element2.hidden) {
        continue;
      }
      if (element2.active && drawActiveElementsOnTop) {
        active.push(element2);
      } else {
        element2.draw(ctx, area);
      }
    }
    for (i2 = 0; i2 < active.length; ++i2) {
      active[i2].draw(ctx, area);
    }
  }
  getStyle(index2, active) {
    const mode = active ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element2 = this._cachedMeta.data[index2];
      context = element2.$context || (element2.$context = createDataContext(this.getContext(), index2, element2));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes2 = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index2, active, mode);
    const values = config.resolveNamedOptions(scopes2, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index2, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes2 = config.getOptionScopes(this.getDataset(), scopeKeys);
      options = config.createResolver(scopes2, this.getContext(index2, active, transition));
    }
    const animations = new Animations(chart, options && options.animations);
    if (options && options._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options) {
    if (!options.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start2, mode) {
    const firstOpts = this.resolveDataElementOptions(start2, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element2, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element2, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element2, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element2, index2, mode, active) {
    element2.active = active;
    const options = this.getStyle(index2, active);
    this._resolveAnimations(index2, mode, active).update(element2, {
      options: !active && this.getSharedOptions(options) || options
    });
  }
  removeHoverStyle(element2, datasetIndex, index2) {
    this._setStyle(element2, index2, "active", false);
  }
  setHoverStyle(element2, datasetIndex, index2) {
    this._setStyle(element2, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element2 = this._cachedMeta.dataset;
    if (element2) {
      this._setStyle(element2, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element2 = this._cachedMeta.dataset;
    if (element2) {
      this._setStyle(element2, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start2, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end2 = start2 + count;
    let i2;
    const move = (arr) => {
      arr.length += count;
      for (i2 = arr.length - 1; i2 >= end2; i2--) {
        arr[i2] = arr[i2 - count];
      }
    };
    move(data);
    for (i2 = start2; i2 < end2; ++i2) {
      data[i2] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start2, count);
    if (resetNewElements) {
      this.updateElements(data, start2, count, "reset");
    }
  }
  updateElements(element2, start2, count, mode) {
  }
  _removeElements(start2, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start2, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start2, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start2, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start2,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start2,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getAllScaleValues(scale2, type) {
  if (!scale2._cache.$bar) {
    const visibleMetas = scale2.getMatchingVisibleMetas(type);
    let values = [];
    for (let i2 = 0, ilen = visibleMetas.length; i2 < ilen; i2++) {
      values = values.concat(visibleMetas[i2].controller.getAllParsedValues(scale2));
    }
    scale2._cache.$bar = _arrayUnique(values.sort((a3, b2) => a3 - b2));
  }
  return scale2._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale2 = meta.iScale;
  const values = getAllScaleValues(scale2, meta.type);
  let min2 = scale2._length;
  let i2, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min2 = Math.min(min2, Math.abs(curr - prev) || min2);
    }
    prev = curr;
  };
  for (i2 = 0, ilen = values.length; i2 < ilen; ++i2) {
    curr = scale2.getPixelForValue(values[i2]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i2 = 0, ilen = scale2.ticks.length; i2 < ilen; ++i2) {
    curr = scale2.getPixelForTick(i2);
    updateMinAndPrev();
  }
  return min2;
}
function computeFitCategoryTraits(index2, ruler, options, stackCount) {
  const thickness = options.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options.categoryPercentage;
    ratio = options.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index2] - size / 2
  };
}
function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent = options.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start2 = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options.barPercentage,
    start: start2
  };
}
function parseFloatBar(entry, item, vScale, i2) {
  const startValue = vScale.parse(entry[0], i2);
  const endValue = vScale.parse(entry[1], i2);
  const min2 = Math.min(startValue, endValue);
  const max2 = Math.max(startValue, endValue);
  let barStart = min2;
  let barEnd = max2;
  if (Math.abs(min2) > Math.abs(max2)) {
    barStart = max2;
    barEnd = min2;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min: min2,
    max: max2
  };
}
function parseValue(entry, item, vScale, i2) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i2);
  } else {
    item[vScale.axis] = vScale.parse(entry, i2);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start2, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i2, ilen, item, entry;
  for (i2 = start2, ilen = start2 + count; i2 < ilen; ++i2) {
    entry = data[i2];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i2], i2);
    parsed.push(parseValue(entry, item, vScale, i2));
  }
  return parsed;
}
function isFloatBar(custom) {
  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start2, end2, top2, bottom2;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start2 = "left";
    end2 = "right";
  } else {
    reverse = properties.base < properties.y;
    start2 = "bottom";
    end2 = "top";
  }
  if (reverse) {
    top2 = "end";
    bottom2 = "start";
  } else {
    top2 = "start";
    bottom2 = "end";
  }
  return {
    start: start2,
    end: end2,
    reverse,
    top: top2,
    bottom: bottom2
  };
}
function setBorderSkipped(properties, options, stack, index2) {
  let edge = options.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start: start2, end: end2, reverse, top: top2, bottom: bottom2 } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index2) {
      edge = top2;
    } else if ((stack._bottom || 0) === index2) {
      edge = bottom2;
    } else {
      res[parseEdge(bottom2, start2, end2, reverse)] = true;
      edge = top2;
    }
  }
  res[parseEdge(edge, start2, end2, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a3, b2, reverse) {
  if (reverse) {
    edge = swap(edge, a3, b2);
    edge = startEnd(edge, b2, a3);
  } else {
    edge = startEnd(edge, a3, b2);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start2, end2) {
  return v === "start" ? start2 : v === "end" ? end2 : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
class BarController extends DatasetController {
  parsePrimitiveData(meta, data, start2, count) {
    return parseArrayOrPrimitive(meta, data, start2, count);
  }
  parseArrayData(meta, data, start2, count) {
    return parseArrayOrPrimitive(meta, data, start2, count);
  }
  parseObjectData(meta, data, start2, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i2, ilen, item, obj;
    for (i2 = start2, ilen = start2 + count; i2 < ilen; ++i2) {
      obj = data[i2];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i2);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i2));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale2, parsed, stack) {
    super.updateRangeFromParsed(range, scale2, parsed, stack);
    const custom = parsed._custom;
    if (custom && scale2 === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom.min);
      range.max = Math.max(range.max, custom.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start2, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
    for (let i2 = start2; i2 < start2 + count; i2++) {
      const parsed = this.getParsed(i2);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i2);
      const ipixels = this._calculateBarIndexPixels(i2, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, bars[i2].active ? "active" : mode);
      }
      const options = properties.options || bars[i2].options;
      setBorderSkipped(properties, options, stack, index2);
      setInflateAmount(properties, options, ruler.ratio);
      this.updateElement(bars[i2], i2, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const skipNull = (meta) => {
      const parsed = meta.controller.getParsed(dataIndex);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i2, ilen;
    for (i2 = 0, ilen = meta.data.length; i2 < ilen; ++i2) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i2)[iScale.axis], i2));
    }
    const barThickness = opts.barThickness;
    const min2 = barThickness || computeMinSampleSize(meta);
    return {
      min: min2,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom = parsed._custom;
    const floating = isFloatBar(custom);
    let value = parsed[vScale.axis];
    let start2 = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start2 = length - value;
      length = value;
    }
    if (floating) {
      value = custom.barStart;
      length = custom.barEnd - custom.barStart;
      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
        start2 = 0;
      }
      start2 += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start2;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start2 + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min2 = Math.min(startPixel, endPixel);
      const max2 = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max2), min2);
      head = base + size;
      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
      }
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale2 = ruler.scale;
    const options = this.options;
    const skipNull = options.skipNull;
    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
    let center, size;
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale2.getPixelForValue(this.getParsed(index2)[scale2.axis], index2);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i2 = 0;
    for (; i2 < ilen; ++i2) {
      if (this.getParsed(i2)[vScale.axis] !== null) {
        rects[i2].draw(this._ctx);
      }
    }
  }
}
__publicField(BarController, "id", "bar");
__publicField(BarController, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
});
__publicField(BarController, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
class BubbleController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start2, count) {
    const parsed = super.parsePrimitiveData(meta, data, start2, count);
    for (let i2 = 0; i2 < parsed.length; i2++) {
      parsed[i2]._custom = this.resolveDataElementOptions(i2 + start2).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start2, count) {
    const parsed = super.parseArrayData(meta, data, start2, count);
    for (let i2 = 0; i2 < parsed.length; i2++) {
      const item = data[start2 + i2];
      parsed[i2]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i2 + start2).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start2, count) {
    const parsed = super.parseObjectData(meta, data, start2, count);
    for (let i2 = 0; i2 < parsed.length; i2++) {
      const item = data[start2 + i2];
      parsed[i2]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i2 + start2).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max2 = 0;
    for (let i2 = data.length - 1; i2 >= 0; --i2) {
      max2 = Math.max(max2, data[i2].size(this.resolveDataElementOptions(i2)) / 2);
    }
    return max2 > 0 && max2;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x2 = xScale.getLabelForValue(parsed.x);
    const y3 = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: labels[index2] || "",
      value: "(" + x2 + ", " + y3 + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start2, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i2 = start2; i2 < start2 + count; i2++) {
      const point = points[i2];
      const parsed = !reset && this.getParsed(i2);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i2, properties, mode);
    }
  }
  resolveDataElementOptions(index2, mode) {
    const parsed = this.getParsed(index2);
    let values = super.resolveDataElementOptions(index2, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {
        $shared: false
      });
    }
    const radius2 = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius2);
    return values;
  }
}
__publicField(BubbleController, "id", "bubble");
__publicField(BubbleController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
});
__publicField(BubbleController, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a3, b2) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a3, a3 * cutout, b2, b2 * cutout);
    const calcMin = (angle, a3, b2) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a3, a3 * cutout, b2, b2 * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
class DoughnutController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start2, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i3) => +data[i3];
      if (isObject(data[start2])) {
        const { key = "value" } = this._parsing;
        getter = (i3) => +resolveObjectKey(data[i3], key);
      }
      let i2, ilen;
      for (i2 = start2, ilen = start2 + count; i2 < ilen; ++i2) {
        meta._parsed[i2] = getter(i2);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min2 = TAU;
    let max2 = -TAU;
    for (let i2 = 0; i2 < this.chart.data.datasets.length; ++i2) {
      if (this.chart.isDatasetVisible(i2) && this.chart.getDatasetMeta(i2).type === this._type) {
        const controller = this.chart.getDatasetMeta(i2).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min2 = Math.min(min2, rotation);
        max2 = Math.max(max2, rotation + circumference);
      }
    }
    return {
      rotation: min2,
      circumference: max2 - min2
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i2, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i2) || meta._parsed[i2] === null || meta.data[i2].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i2] * circumference / TAU);
  }
  updateElements(arcs, start2, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
    let startAngle = this._getRotation();
    let i2;
    for (i2 = 0; i2 < start2; ++i2) {
      startAngle += this._circumference(i2, reset);
    }
    for (i2 = start2; i2 < start2 + count; ++i2) {
      const circumference = this._circumference(i2, reset);
      const arc = arcs[i2];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i2, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i2;
    for (i2 = 0; i2 < metaData.length; i2++) {
      const value = meta._parsed[i2];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i2) && !metaData[i2].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2], chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max2 = 0;
    const chart = this.chart;
    let i2, ilen, meta, controller, options;
    if (!arcs) {
      for (i2 = 0, ilen = chart.data.datasets.length; i2 < ilen; ++i2) {
        if (chart.isDatasetVisible(i2)) {
          meta = chart.getDatasetMeta(i2);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
      options = controller.resolveDataElementOptions(i2);
      if (options.borderAlign !== "inner") {
        max2 = Math.max(max2, options.borderWidth || 0, options.hoverBorderWidth || 0);
      }
    }
    return max2;
  }
  getMaxOffset(arcs) {
    let max2 = 0;
    for (let i2 = 0, ilen = arcs.length; i2 < ilen; ++i2) {
      const options = this.resolveDataElementOptions(i2);
      max2 = Math.max(max2, options.offset || 0, options.hoverOffset || 0);
    }
    return max2;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i2 = 0; i2 < datasetIndex; ++i2) {
      if (this.chart.isDatasetVisible(i2)) {
        ringWeightOffset += this._getRingWeight(i2);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(DoughnutController, "descriptors", {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
});
__publicField(DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i2) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i2);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i2),
                index: i2
              };
            });
          }
          return [];
        }
      },
      onClick(e2, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
class LineController extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start: start2, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start2;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start2 = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options.borderWidth = 0;
    }
    options.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options
    }, mode);
    this.updateElements(points, start2, count, mode);
  }
  updateElements(points, start2, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start2, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    const end2 = start2 + count;
    const pointsCount = points.length;
    let prevParsed = start2 > 0 && this.getParsed(start2 - 1);
    for (let i2 = 0; i2 < pointsCount; ++i2) {
      const point = points[i2];
      const properties = directUpdate ? point : {};
      if (i2 < start2 || i2 >= end2) {
        properties.skip = true;
        continue;
      }
      const parsed = this.getParsed(i2);
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i2];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i2, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
}
__publicField(LineController, "id", "line");
__publicField(LineController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
});
__publicField(LineController, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
class PolarAreaController extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  parseObjectData(meta, data, start2, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start2, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    meta.data.forEach((element2, index2) => {
      const parsed = this.getParsed(index2).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
        if (parsed < range.min) {
          range.min = parsed;
        }
        if (parsed > range.max) {
          range.max = parsed;
        }
      }
    });
    return range;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start2, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale2 = this._cachedMeta.rScale;
    const centerX = scale2.xCenter;
    const centerY = scale2.yCenter;
    const datasetStartAngle = scale2.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i2;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i2 = 0; i2 < start2; ++i2) {
      angle += this._computeAngle(i2, mode, defaultAngle);
    }
    for (i2 = start2; i2 < start2 + count; i2++) {
      const arc = arcs[i2];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i2, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i2) ? scale2.getDistanceFromCenterForValue(this.getParsed(i2).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i2, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i2, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element2, index2) => {
      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index2, mode, defaultAngle) {
    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
  }
}
__publicField(PolarAreaController, "id", "polarArea");
__publicField(PolarAreaController, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
});
__publicField(PolarAreaController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i2) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i2);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i2),
                index: i2
              };
            });
          }
          return [];
        }
      },
      onClick(e2, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
});
class PieController extends DoughnutController {
}
__publicField(PieController, "id", "pie");
__publicField(PieController, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
class RadarController extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start2, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start2, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start2, count, mode) {
    const scale2 = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i2 = start2; i2 < start2 + count; i2++) {
      const point = points[i2];
      const options = this.resolveDataElementOptions(i2, point.active ? "active" : mode);
      const pointPosition = scale2.getPointPositionForValue(i2, this.getParsed(i2).r);
      const x2 = reset ? scale2.xCenter : pointPosition.x;
      const y3 = reset ? scale2.yCenter : pointPosition.y;
      const properties = {
        x: x2,
        y: y3,
        angle: pointPosition.angle,
        skip: isNaN(x2) || isNaN(y3),
        options
      };
      this.updateElement(point, i2, properties, mode);
    }
  }
}
__publicField(RadarController, "id", "radar");
__publicField(RadarController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
});
__publicField(RadarController, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
class ScatterController extends DatasetController {
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x2 = xScale.getLabelForValue(parsed.x);
    const y3 = yScale.getLabelForValue(parsed.y);
    return {
      label: labels[index2] || "",
      value: "(" + x2 + ", " + y3 + ")"
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { data: points = [] } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start: start2, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start2;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start2 = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      const { dataset: line, _dataset } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
    }
    this.updateElements(points, start2, count, mode);
  }
  addElements() {
    const { showLine } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = this.chart.registry.getElement("line");
    }
    super.addElements();
  }
  updateElements(points, start2, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start2, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start2 > 0 && this.getParsed(start2 - 1);
    for (let i2 = start2; i2 < start2 + count; ++i2) {
      const point = points[i2];
      const parsed = this.getParsed(i2);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i2);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i2);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i2 > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i2];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i2, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i2, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];
    if (!this.options.showLine) {
      let max2 = 0;
      for (let i2 = data.length - 1; i2 >= 0; --i2) {
        max2 = Math.max(max2, data[i2].size(this.resolveDataElementOptions(i2)) / 2);
      }
      return max2 > 0 && max2;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
}
__publicField(ScatterController, "id", "scatter");
__publicField(ScatterController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  showLine: false,
  fill: false
});
__publicField(ScatterController, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PieController,
  PolarAreaController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class DateAdapterBase {
  constructor(options) {
    __publicField(this, "options");
    this.options = options || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(DateAdapterBase.prototype, members);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
}
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      return lookupMethod(data, axis, value);
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start2 = lookupMethod(data, axis, value - range);
        const end2 = lookupMethod(data, axis, value + range);
        return {
          lo: start2.lo,
          hi: end2.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
    const { index: index2, data } = metasets[i2];
    const { lo, hi } = binarySearch(metasets[i2], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element2 = data[j];
      if (!element2.skip) {
        handler(element2, index2, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element2, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element2, chart.chartArea, 0)) {
      return;
    }
    if (element2.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element: element2,
        datasetIndex,
        index: index2
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element2, datasetIndex, index2) {
    const { startAngle, endAngle } = element2.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element2, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element: element2,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element2, datasetIndex, index2) {
    const inRange2 = element2.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element2.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element: element2,
          datasetIndex,
          index: index2
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element: element2,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element2, datasetIndex, index2) => {
    if (element2[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element: element2,
        datasetIndex,
        index: index2
      });
      intersectsItem = intersectsItem || element2.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "x";
      const includeInvisible = options.includeInvisible || false;
      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index2 = items[0].index;
        const element2 = meta.data[index2];
        if (element2 && !element2.skip) {
          elements2.push({
            element: element2,
            datasetIndex: meta.index,
            index: index2
          });
        }
      });
      return elements2;
    },
    dataset(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i2 = 0; i2 < data.length; ++i2) {
          items.push({
            element: data[i2],
            datasetIndex,
            index: i2
          });
        }
      }
      return items;
    },
    point(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      const axis = options.axis || "xy";
      const includeInvisible = options.includeInvisible || false;
      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
    },
    y(chart, e2, options, useFinalPosition) {
      const position = getRelativePosition(e2, chart);
      return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
    }
  }
};
const STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a3, b2) => {
    const v0 = reverse ? b2 : a3;
    const v1 = reverse ? a3 : b2;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i2, ilen, box, pos, stack, stackWeight;
  for (i2 = 0, ilen = (boxes || []).length; i2 < ilen; ++i2) {
    box = boxes[i2];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i2,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i2, ilen, layout;
  for (i2 = 0, ilen = layouts2.length; i2 < ilen; ++i2) {
    layout = layouts2[i2];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left2 = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right2 = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top2 = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom2 = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left2.concat(top2),
    rightAndBottom: right2.concat(centerVertical).concat(bottom2).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left2.concat(right2).concat(centerVertical),
    horizontal: top2.concat(bottom2).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a3, b2) {
  return Math.max(maxPadding[a3], chartArea[a3]) + Math.max(maxPadding[b2], chartArea[b2]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i2, ilen, layout, box, refit, changed;
  for (i2 = 0, ilen = boxes.length, refit = 0; i2 < ilen; ++i2) {
    layout = boxes[i2];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left2, top2, width2, height) {
  box.top = top2;
  box.left = left2;
  box.right = left2 + width2;
  box.bottom = top2 + height;
  box.width = width2;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x: x2, y: y3 } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width2 = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y3 = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y3, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y3, width2, height);
      }
      stack.start = y3;
      stack.placed += width2;
      y3 = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width2 = stack.size || box.width;
      if (defined(stack.start)) {
        x2 = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x2, userPadding.top, width2, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x2, chartArea.top + stack.placed, width2, height);
      }
      stack.start = x2;
      stack.placed += height;
      x2 = box.right;
    }
  }
  chartArea.x = x2;
  chartArea.y = y3;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options) {
    item.fullSize = options.fullSize;
    item.position = options.position;
    item.weight = options.weight;
  },
  update(chart, width2, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width2 - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width2,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class BasePlatform {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element2, width2, height, aspectRatio) {
    width2 = Math.max(0, width2 || element2.width);
    height = height || element2.height;
    return {
      width: width2,
      height: Math.max(0, aspectRatio ? Math.floor(width2 / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
}
class BasicPlatform extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
}
const EXPANDO_KEY = "$chartjs";
const EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
const isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
const eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  node.addEventListener(type, listener, eventListenerOptions);
}
function removeListener(chart, type, listener) {
  chart.canvas.removeEventListener(type, listener, eventListenerOptions);
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x: x2, y: y3 } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x2 !== void 0 ? x2 : null,
    y: y3 !== void 0 ? y3 : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
const drpListeningCharts = /* @__PURE__ */ new Map();
let oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width2, height) => {
    const w2 = container.clientWidth;
    listener(width2, height);
    if (w2 < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width2 = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width2 === 0 && height === 0) {
      return;
    }
    resize(width2, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
class DomPlatform extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width2, height, aspectRatio) {
    return getMaximumSize(canvas, width2, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
}
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
let Element$1 = (_a = class {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "active", false);
    __publicField(this, "options");
    __publicField(this, "$animations");
  }
  tooltipPosition(useFinalPosition) {
    const { x: x2, y: y3 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x: x2,
      y: y3
    };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
}, __publicField(_a, "defaults", {}), __publicField(_a, "defaultRoutes"), _a);
function autoSkip(scale2, ticks) {
  const tickOpts = scale2.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale2);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i2, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i2 = 0, ilen = numMajorIndices - 1; i2 < ilen; i2++) {
      skip(ticks, newTicks, spacing, majorIndices[i2], majorIndices[i2 + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale2) {
  const offset2 = scale2.options.offset;
  const tickLength = scale2._tickSize();
  const maxScale = scale2._length / tickLength + (offset2 ? 0 : 1);
  const maxChart = scale2._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i2 = 0, ilen = factors.length - 1; i2 < ilen; i2++) {
    const factor = factors[i2];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i2, ilen;
  for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
    if (ticks[i2].major) {
      result.push(i2);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i2;
  spacing = Math.ceil(spacing);
  for (i2 = 0; i2 < ticks.length; i2++) {
    if (i2 === next) {
      newTicks.push(ticks[i2]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start2 = valueOrDefault(majorStart, 0);
  const end2 = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i2, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start2;
  while (next < 0) {
    count++;
    next = Math.round(start2 + count * spacing);
  }
  for (i2 = Math.max(start2, 0); i2 < end2; i2++) {
    if (i2 === next) {
      newTicks.push(ticks[i2]);
      count++;
      next = Math.round(start2 + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i2, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i2 = 1; i2 < len; ++i2) {
    if (arr[i2] - arr[i2 - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
const reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
const offsetFromEdge = (scale2, edge, offset2) => edge === "top" || edge === "left" ? scale2[edge] + offset2 : scale2[edge] - offset2;
const getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i2 = 0;
  for (; i2 < len; i2 += increment) {
    result.push(arr[Math.floor(i2)]);
  }
  return result;
}
function getPixelForGridLine(scale2, index2, offsetGridLines) {
  const length = scale2.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start2 = scale2._startPixel;
  const end2 = scale2._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale2.getPixelForTick(validIndex2);
  let offset2;
  if (offsetGridLines) {
    if (length === 1) {
      offset2 = Math.max(lineValue - start2, end2 - lineValue);
    } else if (index2 === 0) {
      offset2 = (scale2.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset2 = (lineValue - scale2.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset2 : -offset2;
    if (lineValue < start2 - epsilon || lineValue > end2 + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i2;
    if (gcLen > length) {
      for (i2 = 0; i2 < gcLen; ++i2) {
        delete cache.data[gc[i2]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options) {
  return options.drawTicks ? options.tickLength : 0;
}
function getTitleHeight(options, fallback) {
  if (!options.display) {
    return 0;
  }
  const font = toFont(options.font, fallback);
  const padding = toPadding(options.padding);
  const lines = isArray(options.text) ? options.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale2) {
  return createContext(parent, {
    scale: scale2,
    type: "scale"
  });
}
function createTickContext(parent, index2, tick) {
  return createContext(parent, {
    tick,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale2, offset2, position, align) {
  const { top: top2, left: left2, bottom: bottom2, right: right2, chart } = scale2;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom2 - top2;
  const width2 = right2 - left2;
  if (scale2.isHorizontal()) {
    titleX = _alignStartEnd(align, left2, right2);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset2;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset2;
    } else {
      titleY = offsetFromEdge(scale2, position, offset2);
    }
    maxWidth = right2 - left2;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width2 + offset2;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width2 + offset2;
    } else {
      titleX = offsetFromEdge(scale2, position, offset2);
    }
    titleY = _alignStartEnd(align, bottom2, top2);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
class Scale extends Element$1 {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options) {
    this.options = options.setContext(this.getContext());
    this.axis = options.axis;
    this._userMin = this.parse(options.min);
    this._userMax = this.parse(options.max);
    this._suggestedMin = this.parse(options.suggestedMin);
    this._suggestedMax = this.parse(options.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min: min2,
        max: max2
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      range = metas[i2].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min2 = Math.min(min2, range.min);
      }
      if (!maxDefined) {
        max2 = Math.max(max2, range.max);
      }
    }
    min2 = maxDefined && min2 > max2 ? max2 : min2;
    max2 = minDefined && min2 > max2 ? min2 : max2;
    return {
      min: finiteOrDefault(min2, finiteOrDefault(max2, min2)),
      max: finiteOrDefault(max2, finiteOrDefault(min2, max2))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i2, ilen, tick;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
      tick = ticks[i2];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i2,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options = this.options;
    const tickOpts = options.ticks;
    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i2, ilen;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; i2++) {
      if (isNullOrUndef(ticks[i2].label)) {
        ticks.splice(i2, 1);
        ilen--;
        i2--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length, maxTicksLimit) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i2, j, jlen, label, tickFont, fontString, cache, lineHeight, width2, height, nestedLabel;
    for (i2 = 0; i2 < length; i2 += increment) {
      label = ticks[i2].label;
      tickFont = this._resolveTickFontOptions(i2);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width2 = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width2 = _measureText(ctx, cache.data, cache.gc, width2, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width2 = _measureText(ctx, cache.data, cache.gc, width2, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width2);
      heights.push(height);
      widestLabelSize = Math.max(width2, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: min2, max: max2 } = this;
    return min2 < 0 && max2 < 0 ? max2 : min2 > 0 && max2 > 0 ? min2 : 0;
  }
  getContext(index2) {
    const ticks = this.ticks || [];
    if (index2 >= 0 && index2 < ticks.length) {
      const tick = ticks[index2];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w2 = labelSizes ? labelSizes.widest.width + padding : 0;
    const h4 = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h4 * cos > w2 * sin ? w2 / cos : h4 / sin : h4 * sin < w2 * cos ? h4 / cos : w2 / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options = this.options;
    const { grid: grid2, position, border } = options;
    const offset2 = grid2.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset2 ? 1 : 0);
    const tl = getTickMarkLength(grid2);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i2, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y22;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y22 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y22 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y22 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i2 = 0; i2 < ticksLength; i2 += step) {
      const context = this.getContext(i2);
      const optsAtIndex = grid2.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i2, offset2);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y22 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2: y22,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options = this.options;
    const { position, ticks: optionTicks } = options;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i2, ilen, tick, label, x2, y3, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y3 = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y3 = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x2 = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x2 = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y3 = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y3 = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x2 = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x2 = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
      tick = ticks[i2];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i2));
      pixel = this.getPixelForTick(i2) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i2);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x2 = pixel;
        if (textAlign === "inner") {
          if (i2 === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i2 === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x2 += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y3 = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i2];
        const width2 = labelSizes.widths[i2];
        let top2 = textOffset - labelPadding.top;
        let left2 = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top2 -= height / 2;
            break;
          case "bottom":
            top2 -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left2 -= width2 / 2;
            break;
          case "right":
            left2 -= width2;
            break;
        }
        backdrop = {
          left: left2,
          top: top2,
          width: width2 + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x2,
            y3
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x2;
    if (position === "left") {
      if (mirror) {
        x2 = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 += widest / 2;
        } else {
          textAlign = "right";
          x2 += widest;
        }
      } else {
        x2 = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 -= widest / 2;
        } else {
          textAlign = "left";
          x2 = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x2 = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 -= widest / 2;
        } else {
          textAlign = "left";
          x2 -= widest;
        }
      } else {
        x2 = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x2 += widest / 2;
        } else {
          textAlign = "right";
          x2 = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x: x2
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left: left2, top: top2, width: width2, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left2, top2, width2, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid2 = this.options.grid;
    if (!this._isVisible() || !grid2.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index2 = ticks.findIndex((t2) => t2.value === value);
    if (index2 >= 0) {
      const opts = grid2.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid2 = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i2, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid2.display) {
      for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
        const item = items[i2];
        if (grid2.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid2.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid: grid2 } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid2.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y22;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y22 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y22 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y22);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y3 = item.textOffset;
      renderText(ctx, label, 0, y3, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset2 = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset2 += padding.bottom;
      if (isArray(title.text)) {
        offset2 += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset2 += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset2, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i2, ilen;
    for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      const meta = metas[i2];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
}
class TypedRegistry {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
}
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
class Registry {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element$1, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i2 = 0; i2 < this._typedRegistries.length; i2++) {
      const reg = this._typedRegistries[i2];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
}
var registry = /* @__PURE__ */ new Registry();
class PluginService {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a3, b2) => a3.filter((x2) => !b2.some((y3) => x2.plugin.id === y3.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
}
function allPlugins(config) {
  const localIds = {};
  const plugins2 = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i2 = 0; i2 < keys.length; i2++) {
    plugins2.push(registry.getPlugin(keys[i2]));
  }
  const local = config.plugins || [];
  for (let i2 = 0; i2 < local.length; i2++) {
    const plugin = local[i2];
    if (plugins2.indexOf(plugin) === -1) {
      plugins2.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins: plugins2,
    localIds
  };
}
function getOpts(options, all) {
  if (!all && options === false) {
    return null;
  }
  if (options === true) {
    return {};
  }
  return options;
}
function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins2) {
    const id = plugin.id;
    const opts = getOpts(options[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes2 = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes2.push(plugin.defaults);
  }
  return config.createResolver(scopes2, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, ...scaleOptions) {
  if (idMatchesAxis(id)) {
    return id;
  }
  for (const opts of scaleOptions) {
    const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
    if (axis) {
      return axis;
    }
  }
  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
  if (dataset[axis + "AxisID"] === id) {
    return {
      axis
    };
  }
}
function retrieveAxisFromDatasets(id, config) {
  if (config.data && config.data.datasets) {
    const boundDs = config.data.datasets.filter((d3) => d3.xAxisID === id || d3.yAxisID === id);
    if (boundDs.length) {
      return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
    }
  }
  return {};
}
function mergeScaleConfig(config, options) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options);
  const scales2 = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales2[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale2 = scales2[key];
    mergeIf(scale2, [
      defaults.scales[scale2.type],
      defaults.scale
    ]);
  });
  return scales2;
}
function initOptions(config) {
  const options = config.options || (config.options = {});
  options.plugins = valueOrDefault(options.plugins, {});
  options.scales = mergeScaleConfig(config, options);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
const keyCache = /* @__PURE__ */ new Map();
const keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
const addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
class Config {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options) {
    this._config.options = options;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes2 = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes2.add(mainScope);
        keys.forEach((key) => addIfFound(scopes2, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes2, options, key));
      keys.forEach((key) => addIfFound(scopes2, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes2, defaults, key));
      keys.forEach((key) => addIfFound(scopes2, descriptors, key));
    });
    const array = Array.from(scopes2);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options, type } = this;
    return [
      options,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {
        type
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes2, names2, context, prefixes = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes2, prefixes);
    let options = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes2, context, subPrefixes);
      options = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options[prop];
    }
    return result;
  }
  createResolver(scopes2, context, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes2, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
}
function getResolver(resolverCache, scopes2, prefixes) {
  let cache = resolverCache.get(scopes2);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes2, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes2, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
const hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).reduce((acc, key) => acc || isFunction(value[key]), false);
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.3.0";
const KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a3, b2) {
    return a3[l1] === b2[l1] ? a3[l2] - b2[l2] : a3[l1] - b2[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
const instances = {};
const getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c2) => c2.canvas === canvas).pop();
};
function moveNumericKeys(obj, start2, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start2) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start2) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e2, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e2.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e2;
}
function getDatasetArea(meta) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: xScale.left,
      right: xScale.right,
      top: yScale.top,
      bottom: yScale.bottom
    };
  }
}
let Chart$1 = (_b = class {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width2 = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width2;
    this.height = height;
    this._options = options;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width: width2, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width2 / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options) {
    this.config.options = options;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width2, height) {
    if (!animator.running(this)) {
      this._resize(width2, height);
    } else {
      this._resizeBeforeDraw = {
        width: width2,
        height
      };
    }
  }
  _resize(width2, height) {
    const options = this.options;
    const canvas = this.canvas;
    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width2, height, aspectRatio);
    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options = this.options;
    const scalesOptions = options.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options = this.options;
    const scaleOpts = options.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale2 = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale2 = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale2 = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale2.id] = scale2;
      }
      scale2.init(scaleOptions, options);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each(scales2, (scale2) => {
      layouts.configure(this, scale2, scale2.options);
      layouts.addBox(this, scale2);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a3, b2) => a3.index - b2.index);
    if (numMeta > numData) {
      for (let i2 = numData; i2 < numMeta; ++i2) {
        this._destroyDatasetMeta(i2);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index2) => {
      if (datasets.filter((x2) => x2 === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i2, ilen;
    this._removeUnreferencedMetasets();
    for (i2 = 0, ilen = datasets.length; i2 < ilen; i2++) {
      const dataset = datasets[i2];
      let meta = this.getDatasetMeta(i2);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i2);
        meta = this.getDatasetMeta(i2);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i2;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i2);
      if (meta.controller) {
        meta.controller.updateIndex(i2);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i2);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; i2++) {
      const { controller } = this.getDatasetMeta(i2);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale2) => {
      layouts.removeBox(this, scale2);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start: start2, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start2, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c2) => c2[0] === idx).map((c2, i2) => i2 + "," + c2.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i2 = 1; i2 < datasetCount; i2++) {
      if (!setsEqual(changeSet, makeSet(i2))) {
        return;
      }
    }
    return Array.from(changeSet).map((c2) => c2.split(",")).map((a3) => ({
      method: a3[1],
      start: +a3[2],
      count: +a3[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this.getDatasetMeta(i2).controller.configure();
    }
    for (let i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this._updateDataset(i2, isFunction(mode) ? mode({
        datasetIndex: i2
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index2, mode) {
    const meta = this.getDatasetMeta(index2);
    const args = {
      meta,
      index: index2,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i2;
    if (this._resizeBeforeDraw) {
      const { width: width2, height } = this._resizeBeforeDraw;
      this._resize(width2, height);
      this._resizeBeforeDraw = null;
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i2 = 0; i2 < layers.length && layers[i2].z <= 0; ++i2) {
      layers[i2].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i2 < layers.length; ++i2) {
      layers[i2].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i2, ilen;
    for (i2 = 0, ilen = metasets.length; i2 < ilen; ++i2) {
      const meta = metasets[i2];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
      this._drawDataset(metasets[i2]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const clip = meta._clip;
    const useClip = !clip.disabled;
    const area = getDatasetArea(meta) || this.chartArea;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (useClip) {
      clipArea(ctx, {
        left: clip.left === false ? 0 : area.left - clip.left,
        right: clip.right === false ? this.width : area.right + clip.right,
        top: clip.top === false ? 0 : area.top - clip.top,
        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
      });
    }
    meta.controller.draw();
    if (useClip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e2, mode, options, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e2, options, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x2) => x2 && x2._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i2, ilen;
    this.stop();
    animator.remove(this);
    for (i2 = 0, ilen = this.data.datasets.length; i2 < ilen; ++i2) {
      this._destroyDatasetMeta(i2);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e2, x2, y3) => {
      e2.offsetX = x2;
      e2.offsetY = y3;
      this._eventHandler(e2);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width2, height) => {
      if (this.canvas) {
        this.resize(width2, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i2, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
      item = items[i2];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a3, b2) => a3.filter((x2) => !b2.some((y3) => x2.datasetIndex === y3.datasetIndex && x2.index === y3.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e2, replay) {
    const args = {
      event: e2,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e2)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e2.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e2, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e2, replay, inChartArea) {
    const { _active: lastActive = [], options } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e2, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e2);
    const lastEvent = determineLastEvent(e2, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options.onHover, [
        e2,
        active,
        this
      ], this);
      if (isClick) {
        callback(options.onClick, [
          e2,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e2, lastActive, inChartArea, useFinalPosition) {
    if (e2.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e2, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
}, __publicField(_b, "defaults", defaults), __publicField(_b, "instances", instances), __publicField(_b, "overrides", overrides), __publicField(_b, "registry", registry), __publicField(_b, "version", version), __publicField(_b, "getChart", getChart), _b);
function invalidatePlugins() {
  return each(Chart$1.instances, (chart) => chart._plugins.invalidate());
}
function clipArc(ctx, element2, endAngle) {
  const { startAngle, pixelMargin, x: x2, y: y3, outerRadius, innerRadius } = element2;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x2, y3, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x2, y3, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x2, y3, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x2, y3) {
  return {
    x: x2 + r * Math.cos(theta),
    y: y3 + r * Math.sin(theta)
  };
}
function pathArc(ctx, element2, offset2, spacing, end2, circular) {
  const { x: x2, y: y3, startAngle: start2, pixelMargin, innerRadius: innerR } = element2;
  const outerRadius = Math.max(element2.outerRadius + spacing + offset2 - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset2 + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end2 - start2;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset2 / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start2 + angleOffset + spacingOffset;
  const endAngle = end2 - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element2, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x2, y3, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x2, y3, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x2, y3);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x2, y3);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x2, y3);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x2, y3, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x2, y3, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x2, y3);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x2, y3);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x2, y3);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x2, y3);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x2;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y3;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x2;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y3;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element2, offset2, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element2;
  let endAngle = element2.endAngle;
  if (fullCircles) {
    pathArc(ctx, element2, offset2, spacing, endAngle, circular);
    for (let i2 = 0; i2 < fullCircles; ++i2) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx, element2, offset2, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawBorder(ctx, element2, offset2, spacing, circular) {
  const { fullCircles, startAngle, circumference, options } = element2;
  const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
  const inner = options.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  ctx.setLineDash(borderDash || []);
  ctx.lineDashOffset = borderDashOffset;
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element2.endAngle;
  if (fullCircles) {
    pathArc(ctx, element2, offset2, spacing, endAngle, circular);
    for (let i2 = 0; i2 < fullCircles; ++i2) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx, element2, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element2, offset2, spacing, endAngle, circular);
    ctx.stroke();
  }
}
class ArcElement extends Element$1 {
  constructor(cfg) {
    super();
    __publicField(this, "circumference");
    __publicField(this, "endAngle");
    __publicField(this, "fullCircles");
    __publicField(this, "innerRadius");
    __publicField(this, "outerRadius");
    __publicField(this, "pixelMargin");
    __publicField(this, "startAngle");
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x: x2, y: y3, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], useFinalPosition);
    const { offset: offset2, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset2) / 2;
    return {
      x: x2 + Math.cos(halfAngle) * halfRadius,
      y: y3 + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options, circumference } = this;
    const offset2 = (options.offset || 0) / 4;
    const spacing = (options.spacing || 0) / 2;
    const circular = options.circular;
    this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset2, Math.sin(halfAngle) * offset2);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset2 * fix;
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
}
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true
});
__publicField(ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
__publicField(ArcElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash"
});
function setStyle(ctx, options, style = options) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options) {
  if (options.stepped) {
    return _steppedLineTo;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start2 = Math.max(paramsStart, segmentStart);
  const end2 = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start: start2,
    loop: segment.loop,
    ilen: end2 < start2 && !outside ? count + end2 - start2 : end2 - start2
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options } = line;
  const { count, start: start2, loop: loop2, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options);
  let { move = true, reverse } = params || {};
  let i2, point, prev;
  for (i2 = 0; i2 <= ilen; ++i2) {
    point = points[(start2 + (reverse ? ilen - i2 : i2)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    prev = point;
  }
  if (loop2) {
    point = points[(start2 + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options.stepped);
  }
  return !!loop2;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start: start2, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i2, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start2 + (reverse ? ilen - index2 : index2)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i2 = 0; i2 <= ilen; ++i2) {
    point = points[pointIndex(i2)];
    if (point.skip) {
      continue;
    }
    const x2 = point.x;
    const y3 = point.y;
    const truncX = x2 | 0;
    if (truncX === prevX) {
      if (y3 < minY) {
        minY = y3;
      } else if (y3 > maxY) {
        maxY = y3;
      }
      avgX = (countX * avgX + x2) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x2, y3);
      prevX = truncX;
      countX = 0;
      minY = maxY = y3;
    }
    lastY = y3;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options) {
  if (options.stepped) {
    return _steppedInterpolation;
  }
  if (options.tension || options.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start2, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start2, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start2, count) {
  const { segments, options } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {
      start: start2,
      end: start2 + count - 1
    })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
const usePath2D = typeof Path2D === "function";
function draw(ctx, line, start2, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start2, count);
  } else {
    strokePathDirect(ctx, line, start2, count);
  }
}
class LineElement extends Element$1 {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options = this.options;
    if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
      const loop2 = options.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options, chartArea, loop2, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, {
      property,
      start: value,
      end: value
    });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options);
    let i2, ilen;
    for (i2 = 0, ilen = segments.length; i2 < ilen; ++i2) {
      const { start: start2, end: end2 } = segments[i2];
      const p1 = points[start2];
      const p2 = points[end2];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t2 = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t2, options.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start2, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop2 = this._loop;
    start2 = start2 || 0;
    count = count || this.points.length - start2;
    for (const segment of segments) {
      loop2 &= segmentMethod(ctx, this, segment, {
        start: start2,
        end: start2 + count - 1
      });
    }
    return !!loop2;
  }
  draw(ctx, chartArea, start2, count) {
    const options = this.options || {};
    const points = this.points || [];
    if (points.length && options.borderWidth) {
      ctx.save();
      draw(ctx, this, start2, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
}
__publicField(LineElement, "id", "line");
__publicField(LineElement, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
});
__publicField(LineElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
__publicField(LineElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
});
function inRange$1(el, pos, axis, useFinalPosition) {
  const options = el.options;
  const { [axis]: value } = el.getProps([
    axis
  ], useFinalPosition);
  return Math.abs(pos - value) < options.radius + options.hitRadius;
}
class PointElement extends Element$1 {
  constructor(cfg) {
    super();
    __publicField(this, "parsed");
    __publicField(this, "skip");
    __publicField(this, "stop");
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options = this.options;
    const { x: x2, y: y3 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return Math.pow(mouseX - x2, 2) + Math.pow(mouseY - y3, 2) < Math.pow(options.hitRadius + options.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x: x2, y: y3 } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x: x2,
      y: y3
    };
  }
  size(options) {
    options = options || this.options || {};
    let radius2 = options.radius || 0;
    radius2 = Math.max(radius2, radius2 && options.hoverRadius || 0);
    const borderWidth = radius2 && options.borderWidth || 0;
    return (radius2 + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options = this.options;
    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
      return;
    }
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.fillStyle = options.backgroundColor;
    drawPoint(ctx, options, this.x, this.y);
  }
  getRange() {
    const options = this.options || {};
    return options.radius + options.hitRadius;
  }
}
__publicField(PointElement, "id", "point");
/**
* @type {any}
*/
__publicField(PointElement, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
});
/**
* @type {any}
*/
__publicField(PointElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function getBarBounds(bar, useFinalPosition) {
  const { x: x2, y: y3, base, width: width2, height } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left2, right2, top2, bottom2, half;
  if (bar.horizontal) {
    half = height / 2;
    left2 = Math.min(x2, base);
    right2 = Math.max(x2, base);
    top2 = y3 - half;
    bottom2 = y3 + half;
  } else {
    half = width2 / 2;
    left2 = x2 - half;
    right2 = x2 + half;
    top2 = Math.min(y3, base);
    bottom2 = Math.max(y3, base);
  }
  return {
    left: left2,
    top: top2,
    right: right2,
    bottom: bottom2
  };
}
function skipOrLimit(skip2, value, min2, max2) {
  return skip2 ? 0 : _limitValue(value, min2, max2);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width2 = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width2 / 2, height / 2);
  const radius2 = parseBorderRadius(bar, width2 / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width2,
      h: height,
      radius: radius2
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width2 - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius2.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius2.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius2.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius2.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x2, y3, useFinalPosition) {
  const skipX = x2 === null;
  const skipY = y3 === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x2, bounds.left, bounds.right)) && (skipY || _isBetween(y3, bounds.top, bounds.bottom));
}
function hasRadius(radius2) {
  return radius2.topLeft || radius2.topRight || radius2.bottomLeft || radius2.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x2 = rect.x !== refRect.x ? -amount : 0;
  const y3 = rect.y !== refRect.y ? -amount : 0;
  const w2 = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x2;
  const h4 = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y3;
  return {
    x: rect.x + x2,
    y: rect.y + y3,
    w: rect.w + w2,
    h: rect.h + h4,
    radius: rect.radius
  };
}
class BarElement extends Element$1 {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x: x2, y: y3, base, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x2 + base) / 2 : x2,
      y: horizontal ? y3 : (y3 + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
}
__publicField(BarElement, "id", "bar");
__publicField(BarElement, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
});
__publicField(BarElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  BarElement,
  LineElement,
  PointElement
});
const BORDER_COLORS = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
];
const BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function getBorderColor(i2) {
  return BORDER_COLORS[i2 % BORDER_COLORS.length];
}
function getBackgroundColor(i2) {
  return BACKGROUND_COLORS[i2 % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i2) {
  dataset.borderColor = getBorderColor(i2);
  dataset.backgroundColor = getBackgroundColor(i2);
  return ++i2;
}
function colorizeDoughnutDataset(dataset, i2) {
  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i2++));
  return i2;
}
function colorizePolarAreaDataset(dataset, i2) {
  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i2++));
  return i2;
}
function getColorizer(chart) {
  let i2 = 0;
  return (dataset, datasetIndex) => {
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    if (controller instanceof DoughnutController) {
      i2 = colorizeDoughnutDataset(dataset, i2);
    } else if (controller instanceof PolarAreaController) {
      i2 = colorizePolarAreaDataset(dataset, i2);
    } else if (controller) {
      i2 = colorizeDefaultDataset(dataset, i2);
    }
  };
}
function containsColorsDefinitions(descriptors2) {
  let k2;
  for (k2 in descriptors2) {
    if (descriptors2[k2].borderColor || descriptors2[k2].backgroundColor) {
      return true;
    }
  }
  return false;
}
function containsColorsDefinition(descriptor) {
  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
var plugin_colors = {
  id: "colors",
  defaults: {
    enabled: true,
    forceOverride: false
  },
  beforeLayout(chart, _args, options) {
    if (!options.enabled) {
      return;
    }
    const { data: { datasets }, options: chartOptions } = chart.config;
    const { elements: elements2 } = chartOptions;
    if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2))) {
      return;
    }
    const colorizer = getColorizer(chart);
    datasets.forEach(colorizer);
  }
};
function lttbDecimation(data, start2, count, availableWidth, options) {
  const samples = options.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start2, start2 + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start2 + count - 1;
  let a3 = start2;
  let i2, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a3];
  for (i2 = 0; i2 < samples - 2; i2++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i2 + 1) * bucketWidth) + 1 + start2;
    const avgRangeEnd = Math.min(Math.floor((i2 + 2) * bucketWidth) + 1, count) + start2;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i2 * bucketWidth) + 1 + start2;
    const rangeTo = Math.min(Math.floor((i2 + 1) * bucketWidth) + 1, count) + start2;
    const { x: pointAx, y: pointAy } = data[a3];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a3 = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start2, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i2, point, x2, y3, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start2 + count - 1;
  const xMin = data[start2].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i2 = start2; i2 < start2 + count; ++i2) {
    point = data[i2];
    x2 = (point.x - xMin) / dx * availableWidth;
    y3 = point.y;
    const truncX = x2 | 0;
    if (truncX === prevX) {
      if (y3 < minY) {
        minY = y3;
        minIndex = i2;
      } else if (y3 > maxY) {
        maxY = y3;
        maxIndex = i2;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i2 - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i2 > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y3;
      minIndex = maxIndex = startIndex = i2;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: data
    });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start2 = 0;
  let count;
  const { iScale } = meta;
  const { min: min2, max: max2, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start2 = _limitValue(_lookupByKey(points, iScale.axis, min2).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max2).hi + 1, start2, pointCount) - start2;
  } else {
    count = pointCount - start2;
  }
  return {
    start: start2,
    count
  };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options) => {
    if (!options.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([
        indexAxis,
        chart.options.indexAxis
      ]) === "y") {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start: start2, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d3) {
            this._data = d3;
          }
        });
      }
      let decimated;
      switch (options.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start2, count, availableWidth, options);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start2, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start: start2, end: end2 } = segment;
    end2 = _findSegmentEnd(start2, end2, points);
    const bounds = _getBounds(property, points[start2], points[end2], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start2],
        end: points[end2]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property, first, last, loop2) {
  if (loop2) {
    return;
  }
  let start2 = first[property];
  let end2 = last[property];
  if (property === "angle") {
    start2 = _normalizeAngle(start2);
    end2 = _normalizeAngle(end2);
  }
  return {
    property,
    start: start2,
    end: end2
  };
}
function _pointsFromSegments(boundary, line) {
  const { x: x2 = null, y: y3 = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start: start2, end: end2 }) => {
    end2 = _findSegmentEnd(start2, end2, linePoints);
    const first = linePoints[start2];
    const last = linePoints[end2];
    if (y3 !== null) {
      points.push({
        x: first.x,
        y: y3
      });
      points.push({
        x: last.x,
        y: y3
      });
    } else if (x2 !== null) {
      points.push({
        x: x2,
        y: first.y
      });
      points.push({
        x: x2,
        y: last.y
      });
    }
  });
  return points;
}
function _findSegmentEnd(start2, end2, points) {
  for (; end2 > start2; end2--) {
    const point = points[end2];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end2;
}
function _getEdge(a3, b2, prop, fn2) {
  if (a3 && b2) {
    return fn2(a3[prop], b2[prop]);
  }
  return a3 ? a3[prop] : b2 ? b2[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {
      tension: 0
    },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index2, propagate) {
  const source = sources[index2];
  let fill2 = source.fill;
  const visited = [
    index2
  ];
  let target;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target = sources[fill2];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target.fill;
  }
  return false;
}
function _decodeFill(line, index2, count) {
  const fill2 = parseFillOption(line);
  if (isObject(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target = parseFloat(fill2);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill2[0], index2, target, count);
  }
  return [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index2, target, count) {
  if (firstCh === "-" || firstCh === "+") {
    target = index2 + target;
  }
  if (target === index2 || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill2, scale2) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale2.bottom;
  } else if (fill2 === "end") {
    pixel = scale2.top;
  } else if (isObject(fill2)) {
    pixel = scale2.getPixelForValue(fill2.value);
  } else if (scale2.getBasePixel) {
    pixel = scale2.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale2, startValue) {
  let value;
  if (fill2 === "start") {
    value = startValue;
  } else if (fill2 === "end") {
    value = scale2.options.reverse ? scale2.min : scale2.max;
  } else if (isObject(fill2)) {
    value = fill2.value;
  } else {
    value = scale2.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options = line.options;
  const fillOption = options.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source) {
  const { scale: scale2, index: index2, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale2, index2);
  linesBelow.push(_createBoundaryLine({
    x: null,
    y: scale2.bottom
  }, line));
  for (let i2 = 0; i2 < segments.length; i2++) {
    const segment = segments[i2];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({
    points,
    options: {}
  });
}
function getLinesBelow(scale2, index2) {
  const below = [];
  const metas = scale2.getMatchingVisibleMetas("line");
  for (let i2 = 0; i2 < metas.length; i2++) {
    const meta = metas[i2];
    if (meta.index === index2) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i2 = 0; i2 < segments.length; i2++) {
    const segment = segments[i2];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {
    first,
    last,
    point
  };
}
class simpleArc {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x: x2, y: y3, radius: radius2 } = this;
    bounds = bounds || {
      start: 0,
      end: TAU
    };
    ctx.arc(x2, y3, radius2, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x: x2, y: y3, radius: radius2 } = this;
    const angle = point.angle;
    return {
      x: x2 + Math.cos(angle) * radius2,
      y: y3 + Math.sin(angle) * radius2,
      angle
    };
  }
}
function _getTarget(source) {
  const { chart, fill: fill2, line } = source;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index2) {
  const meta = chart.getDatasetMeta(index2);
  const visible = meta && chart.isDatasetVisible(index2);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale2 = source.scale || {};
  if (scale2.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const { scale: scale2 = {}, fill: fill2 } = source;
  const pixel = _getTargetPixel(fill2, scale2);
  if (isNumberFinite(pixel)) {
    const horizontal = scale2.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const { scale: scale2, fill: fill2 } = source;
  const options = scale2.options;
  const length = scale2.getLabels().length;
  const start2 = options.reverse ? scale2.max : scale2.min;
  const value = _getTargetValue(fill2, scale2, start2);
  const target = [];
  if (options.grid.circular) {
    const center = scale2.getPointPositionForValue(0, start2);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale2.getDistanceFromCenterForValue(value)
    });
  }
  for (let i2 = 0; i2 < length; ++i2) {
    target.push(scale2.getPointPositionForValue(i2, value));
  }
  return target;
}
function _drawfill(ctx, source, area) {
  const target = _getTarget(source);
  const { line, scale: scale2, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, {
      line,
      target,
      above,
      below,
      area,
      scale: scale2,
      axis
    });
    unclipArea(ctx);
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale: scale2 } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  if (property === "x" && below !== above) {
    clipVertical(ctx, target, area.top);
    fill(ctx, {
      line,
      target,
      color: above,
      scale: scale2,
      property
    });
    ctx.restore();
    ctx.save();
    clipVertical(ctx, target, area.bottom);
  }
  fill(ctx, {
    line,
    target,
    color: below,
    scale: scale2,
    property
  });
  ctx.restore();
}
function clipVertical(ctx, target, clipY) {
  const { segments, points } = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const { start: start2, end: end2 } = segment;
    const firstPoint = points[start2];
    const lastPoint = points[_findSegmentEnd(start2, end2, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, {
      move: lineLoop
    });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function fill(ctx, cfg) {
  const { line, target, property, color: color2, scale: scale2 } = cfg;
  const segments = _segments(line, target, property);
  for (const { source: src, target: tgt, start: start2, end: end2 } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale2, notShape && _getBounds(property, start2, end2));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop2;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end2, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, {
        move: lineLoop,
        reverse: true
      });
      loop2 = lineLoop && targetLoop;
      if (!loop2) {
        interpolatedLineTo(ctx, target, start2, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop2 ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function clipBounds(ctx, scale2, bounds) {
  const { top: top2, bottom: bottom2 } = scale2.chart.chartArea;
  const { property, start: start2, end: end2 } = bounds || {};
  if (property === "x") {
    ctx.beginPath();
    ctx.rect(start2, top2, end2 - start2, bottom2 - top2);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i2, line, source;
    for (i2 = 0; i2 < count; ++i2) {
      meta = chart.getDatasetMeta(i2);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i2),
          index: i2,
          fill: _decodeFill(line, i2, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i2 = 0; i2 < count; ++i2) {
      source = sources[i2];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i2, options.propagate);
    }
  },
  beforeDraw(chart, _args, options) {
    const draw2 = options.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
      const source = metasets[i2].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2 && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options) {
    if (options.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i2 = metasets.length - 1; i2 >= 0; --i2) {
      const source = metasets[i2].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
const getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
const itemsEqual = (a3, b2) => a3 !== null && b2 !== null && a3.datasetIndex === b2.datasetIndex && a3.index === b2.index;
class Legend extends Element$1 {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a3, b2) => labelOpts.sort(a3, b2, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options, ctx } = this;
    if (!options.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width2, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width2 = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width2 = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width2, options.maxWidth || this.maxWidth);
    this.height = Math.min(height, options.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top2 = -lineHeight;
    this.legendItems.forEach((legendItem, i2) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i2 === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i2 > 0 ? 0 : 1)] = 0;
        top2 += lineHeight;
        row++;
      }
      hitboxes[i2] = {
        left: 0,
        top: top2,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left2 = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i2) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i2 > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left2 += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i2] = {
        left: left2,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left2 = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left2 = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left2), hitbox.width);
        left2 += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top2;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top2 += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x2, y3, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x2, boxWidth / 2);
        const centerY = y3 + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y3 + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x2, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x2, y3, legendItem) {
      renderText(ctx, legendItem.text, x2, y3 + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i2) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width2 = boxWidth + halfFontSize + textWidth;
      let x2 = cursor.x;
      let y3 = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i2 > 0 && x2 + width2 + padding > this.right) {
          y3 = cursor.y += lineHeight;
          cursor.line++;
          x2 = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i2 > 0 && y3 + lineHeight > this.bottom) {
        x2 = cursor.x = x2 + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y3 = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x2);
      drawLegendBox(realX, y3, legendItem);
      x2 = _textX(textAlign, x2 + boxWidth + halfFontSize, isHorizontal ? x2 + width2 : this.right, opts.rtl);
      fillText(rtlHelper.x(x2), y3, legendItem);
      if (isHorizontal) {
        cursor.x += width2 + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight);
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y3;
    let left2 = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y3 = this.top + topPaddingPlusHalfFontSize;
      left2 = _alignStartEnd(opts.align, left2, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y3 = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x2 = _alignStartEnd(position, left2, left2 + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x2, y3, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x2, y3) {
    let i2, hitBox, lh;
    if (_isBetween(x2, this.left, this.right) && _isBetween(y3, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i2 = 0; i2 < lh.length; ++i2) {
        hitBox = lh[i2];
        if (_isBetween(x2, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y3, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i2];
        }
      }
    }
    return null;
  }
  handleEvent(e2) {
    const opts = this.options;
    if (!isListened(e2.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e2.x, e2.y);
    if (e2.type === "mousemove" || e2.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e2,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e2,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e2,
        hoveredItem,
        this
      ], this);
    }
  }
}
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a3, b2) => a3.length > b2.length ? a3 : b2);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length + 0.5 : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, legend, options);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options);
    legend.options = options;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e2, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name)
    }
  }
};
class Title10 extends Element$1 {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset2) {
    const { top: top2, left: left2, bottom: bottom2, right: right2, options } = this;
    const align = options.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left2, right2);
      titleY = top2 + offset2;
      maxWidth = right2 - left2;
    } else {
      if (options.position === "left") {
        titleX = left2 + offset2;
        titleY = _alignStartEnd(align, bottom2, top2);
        rotation = PI * -0.5;
      } else {
        titleX = right2 - offset2;
        titleY = _alignStartEnd(align, top2, bottom2);
        rotation = PI * 0.5;
      }
      maxWidth = bottom2 - top2;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset2 = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset2);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
}
function createTitle(chart, titleOpts) {
  const title = new Title10({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title10,
  start(chart, _args, options) {
    createTitle(chart, options);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
const map = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options) {
    const title = new Title10({
      ctx: chart.ctx,
      options,
      chart
    });
    layouts.configure(chart, title, options);
    layouts.addBox(chart, title);
    map.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map.get(chart));
    map.delete(chart);
  },
  beforeUpdate(chart, _args, options) {
    const title = map.get(chart);
    layouts.configure(chart, title, options);
    title.options = options;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
const positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i2, len;
    let x2 = 0;
    let y3 = 0;
    let count = 0;
    for (i2 = 0, len = items.length; i2 < len; ++i2) {
      const el = items[i2].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        x2 += pos.x;
        y3 += pos.y;
        ++count;
      }
    }
    return {
      x: x2 / count,
      y: y3 / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x2 = eventPosition.x;
    let y3 = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i2, len, nearestElement;
    for (i2 = 0, len = items.length; i2 < len; ++i2) {
      const el = items[i2].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d3 = distanceBetweenPoints(eventPosition, center);
        if (d3 < minDistance) {
          minDistance = d3;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x2 = tp.x;
      y3 = tp.y;
    }
    return {
      x: x2,
      y: y3
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element: element2, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element: element2
  };
}
function getTooltipSize(tooltip2, options) {
  const ctx = tooltip2.chart.ctx;
  const { body, footer, title } = tooltip2;
  const { boxWidth, boxHeight } = options;
  const bodyFont = toFont(options.bodyFont);
  const titleFont = toFont(options.titleFont);
  const footerFont = toFont(options.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options.padding);
  let height = padding.height;
  let width2 = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip2.beforeBody.length + tooltip2.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
  }
  if (footerLineCount) {
    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width2 = Math.max(width2, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip2.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip2.beforeBody.concat(tooltip2.afterBody), maxLineWidth);
  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip2.footer, maxLineWidth);
  ctx.restore();
  width2 += padding.width;
  return {
    width: width2,
    height
  };
}
function determineYAlign(chart, size) {
  const { y: y3, height } = size;
  if (y3 < height / 2) {
    return "top";
  } else if (y3 > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options, size) {
  const { x: x2, width: width2 } = size;
  const caret = options.caretSize + options.caretPadding;
  if (xAlign === "left" && x2 + width2 + caret > chart.width) {
    return true;
  }
  if (xAlign === "right" && x2 - width2 - caret < 0) {
    return true;
  }
}
function determineXAlign(chart, options, size, yAlign) {
  const { x: x2, width: width2 } = size;
  const { width: chartWidth, chartArea: { left: left2, right: right2 } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x2 <= (left2 + right2) / 2 ? "left" : "right";
  } else if (x2 <= width2 / 2) {
    xAlign = "left";
  } else if (x2 >= chartWidth - width2 / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options, size) {
  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x: x2, width: width2 } = size;
  if (xAlign === "right") {
    x2 -= width2;
  } else if (xAlign === "center") {
    x2 -= width2 / 2;
  }
  return x2;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y: y3, height } = size;
  if (yAlign === "top") {
    y3 += paddingAndSize;
  } else if (yAlign === "bottom") {
    y3 -= height + paddingAndSize;
  } else {
    y3 -= height / 2;
  }
  return y3;
}
function getBackgroundPoint(options, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x2 = alignX(size, xAlign);
  const y3 = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x2 += paddingAndSize;
    } else if (xAlign === "right") {
      x2 -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x2 -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x2 += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x2, 0, chart.width - size.width),
    y: _limitValue(y3, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip2, align, options) {
  const padding = toPadding(options.padding);
  return align === "center" ? tooltip2.x + tooltip2.width / 2 : align === "right" ? tooltip2.x + tooltip2.width - padding.right : tooltip2.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip2, tooltipItems) {
  return createContext(parent, {
    tooltip: tooltip2,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
const defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options.borderColor,
      backgroundColor: options.backgroundColor,
      borderWidth: options.borderWidth,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options.pointStyle,
      rotation: options.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result = callbacks[name].call(ctx, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name].call(ctx, arg);
  }
  return result;
}
class Tooltip extends Element$1 {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options) {
    this.options = options;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options = this.options.setContext(this.getContext());
    const opts = options.enabled && chart.options.animation && options.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options) {
    const { callbacks } = options;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options) {
    const { callbacks } = options;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options) {
    const { callbacks } = options;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i2, len;
    for (i2 = 0, len = active.length; i2 < len; ++i2) {
      tooltipItems.push(createTooltipItem(this.chart, active[i2]));
    }
    if (options.filter) {
      tooltipItems = tooltipItems.filter((element2, index2, array) => options.filter(element2, index2, array, data));
    }
    if (options.itemSort) {
      tooltipItems = tooltipItems.sort((a3, b2) => options.itemSort(a3, b2, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options);
      this.title = this.getTitle(tooltipItems, options);
      this.beforeBody = this.getBeforeBody(tooltipItems, options);
      this.body = this.getBody(tooltipItems, options);
      this.afterBody = this.getAfterBody(tooltipItems, options);
      this.footer = this.getFooter(tooltipItems, options);
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options.external) {
      options.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width: width2, height } = size;
    let x1, x2, x3, y1, y22, y3;
    if (yAlign === "center") {
      y22 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y22 + caretSize;
        y3 = y22 - caretSize;
      } else {
        x1 = ptX + width2;
        x2 = x1 + caretSize;
        y1 = y22 - caretSize;
        y3 = y22 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width2 - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y22 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y22 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2: y22,
      y3
    };
  }
  drawTitle(pt, ctx, options) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i2;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.titleAlign, options);
      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options.titleFont);
      titleSpacing = options.titleSpacing;
      ctx.fillStyle = options.titleColor;
      ctx.font = titleFont.string;
      for (i2 = 0; i2 < length; ++i2) {
        ctx.fillText(title[i2], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i2 + 1 === length) {
          pt.y += options.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i2, rtlHelper, options) {
    const labelColor = this.labelColors[i2];
    const labelPointStyle = this.labelPointStyles[i2];
    const { boxHeight, boxWidth } = options;
    const bodyFont = toFont(options.bodyFont);
    const colorX = getAlignedX(this, "left", options);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options.multiKeyBackground;
      ctx.fillStyle = options.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColor.borderColor;
      ctx.fillStyle = labelColor.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
      ctx.strokeStyle = labelColor.borderColor;
      ctx.setLineDash(labelColor.borderDash || []);
      ctx.lineDashOffset = labelColor.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = toTRBLCorners(labelColor.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i2];
  }
  drawBody(pt, ctx, options) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
    const bodyFont = toFont(options.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i2, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options);
    ctx.fillStyle = options.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i2 = 0, ilen = body.length; i2 < ilen; ++i2) {
      bodyItem = body[i2];
      textColor = this.labelTextColors[i2];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i2, rtlHelper, options);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i2;
    if (length) {
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options.footerAlign, options);
      pt.y += options.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options.footerFont);
      ctx.fillStyle = options.footerColor;
      ctx.font = footerFont.string;
      for (i2 = 0; i2 < length; ++i2) {
        ctx.fillText(footer[i2], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options) {
    const { xAlign, yAlign } = this;
    const { x: x2, y: y3 } = pt;
    const { width: width2, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
    ctx.fillStyle = options.backgroundColor;
    ctx.strokeStyle = options.borderColor;
    ctx.lineWidth = options.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x2 + topLeft, y3);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2 + width2 - topRight, y3);
    ctx.quadraticCurveTo(x2 + width2, y3, x2 + width2, y3 + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2 + width2, y3 + height - bottomRight);
    ctx.quadraticCurveTo(x2 + width2, y3 + height, x2 + width2 - bottomRight, y3 + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2 + bottomLeft, y3 + height);
    ctx.quadraticCurveTo(x2, y3 + height, x2, y3 + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options);
    }
    ctx.lineTo(x2, y3 + topLeft);
    ctx.quadraticCurveTo(x2, y3, x2 + topLeft, y3);
    ctx.closePath();
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options, positionAndSize);
      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options);
      overrideTextDirection(ctx, options.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options);
      this.drawBody(pt, ctx, options);
      this.drawFooter(pt, ctx, options);
      restoreTextDirection(ctx, options.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e2, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e2, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e2);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options.enabled || options.external) {
        this._eventPosition = {
          x: e2.x,
          y: e2.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e2, lastActive, replay, inChartArea) {
    const options = this.options;
    if (e2.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const active = this.chart.getElementsAtEventForMode(e2, options.mode, options, replay);
    if (options.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e2) {
    const { caretX, caretY, options } = this;
    const position = positioners[options.position].call(this, active, e2);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
}
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options) {
    if (options) {
      chart.tooltip = new Tooltip({
        chart,
        options
      });
    }
  },
  beforeUpdate(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  reset(chart, _args, options) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options);
    }
  },
  afterDraw(chart) {
    const tooltip2 = chart.tooltip;
    if (tooltip2 && tooltip2._willRender()) {
      const args = {
        tooltip: tooltip2
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip2.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: plugin_colors,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
const addIfString = (labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({
      index: index2,
      label: raw
    });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
const validIndex = (index2, max2) => index2 === null ? null : _limitValue(Math.round(index2), 0, max2);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
class CategoryScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min: min2, max: max2 } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min2 = 0;
      }
      if (!maxDefined) {
        max2 = this.getLabels().length - 1;
      }
    }
    this.min = min2;
    this.max = max2;
  }
  buildTicks() {
    const min2 = this.min;
    const max2 = this.max;
    const offset2 = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min2 === 0 && max2 === labels.length - 1 ? labels : labels.slice(min2, max2 + 1);
    this._valueRange = Math.max(labels.length - (offset2 ? 0 : 1), 1);
    this._startValue = this.min - (offset2 ? 0.5 : 0);
    for (let value = min2; value <= max2; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min: min2, max: max2, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min2);
  const maxDefined = !isNullOrUndef(max2);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max2 - min2) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max2 - min2) / spacing, maxTicks));
    spacing = (max2 - min2) / numSpaces;
    niceMin = min2;
    niceMax = max2;
  } else if (countDefined) {
    niceMin = minDefined ? min2 : niceMin;
    niceMax = maxDefined ? max2 : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min2) {
      ticks.push({
        value: min2
      });
      if (niceMin < min2) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min2, relativeLabelSize(min2, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min2) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
    if (maxDefined && tickValue > max2) {
      break;
    }
    ticks.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max2) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max2, relativeLabelSize(max2, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max2;
    } else {
      ticks.push({
        value: max2
      });
    }
  } else if (!maxDefined || niceMax === max2) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
class LinearScaleBase extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min: min2, max: max2 } = this;
    const setMin = (v) => min2 = minDefined ? min2 : v;
    const setMax = (v) => max2 = maxDefined ? max2 : v;
    if (beginAtZero) {
      const minSign = sign(min2);
      const maxSign = sign(max2);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min2 === max2) {
      let offset2 = max2 === 0 ? 1 : Math.abs(max2 * 0.05);
      setMax(max2 + offset2);
      if (!beginAtZero) {
        setMin(min2 - offset2);
      }
    }
    this.min = min2;
    this.max = max2;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start2 = this.min;
    let end2 = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset2 = (end2 - start2) / Math.max(ticks.length - 1, 1) / 2;
      start2 -= offset2;
      end2 += offset2;
    }
    this._startValue = start2;
    this._endValue = end2;
    this._valueRange = end2 - start2;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
}
class LinearScale extends LinearScaleBase {
  determineDataLimits() {
    const { min: min2, max: max2 } = this.getMinMax(true);
    this.min = isNumberFinite(min2) ? min2 : 0;
    this.max = isNumberFinite(max2) ? max2 : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
}
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
const log10Floor = (v) => Math.floor(log10(v));
const changeExponent = (v, m3) => Math.pow(10, log10Floor(v) + m3);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min2, max2, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start2 = Math.floor(min2 / rangeStep);
  const end2 = Math.ceil(max2 / rangeStep);
  return end2 - start2;
}
function startExp(min2, max2) {
  const range = max2 - min2;
  let rangeExp = log10Floor(range);
  while (steps(min2, max2, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min2, max2, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min2));
}
function generateTicks(generationOptions, { min: min2, max: max2 }) {
  min2 = finiteOrDefault(generationOptions.min, min2);
  const ticks = [];
  const minExp = log10Floor(min2);
  let exp = startExp(min2, max2);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start2 = Math.round((min2 - base) * precision) / precision;
  const offset2 = Math.floor((min2 - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start2 - offset2) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset2 + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max2) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset2 + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
class LogarithmicScale extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index2
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min: min2, max: max2 } = this.getMinMax(true);
    this.min = isNumberFinite(min2) ? Math.max(0, min2) : null;
    this.max = isNumberFinite(max2) ? Math.max(0, max2) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min2 === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min2 = this.min;
    let max2 = this.max;
    const setMin = (v) => min2 = minDefined ? min2 : v;
    const setMax = (v) => max2 = maxDefined ? max2 : v;
    if (min2 === max2) {
      if (min2 <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min2, -1));
        setMax(changeExponent(max2, 1));
      }
    }
    if (min2 <= 0) {
      setMin(changeExponent(max2, -1));
    }
    if (max2 <= 0) {
      setMax(changeExponent(min2, 1));
    }
    this.min = min2;
    this.max = max2;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start2 = this.min;
    super.configure();
    this._startValue = log10(start2);
    this._valueRange = log10(this.max) - log10(start2);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
}
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min2, max2) {
  if (angle === min2 || angle === max2) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min2 || angle > max2) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale2) {
  const orig = {
    l: scale2.left + scale2._padding.left,
    r: scale2.right - scale2._padding.right,
    t: scale2.top + scale2._padding.top,
    b: scale2.bottom - scale2._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale2._pointLabels.length;
  const pointLabelOpts = scale2.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i2 = 0; i2 < valueCount; i2++) {
    const opts = pointLabelOpts.setContext(scale2.getPointLabelContext(i2));
    padding[i2] = opts.padding;
    const pointPosition = scale2.getPointPosition(i2, scale2.drawingArea + padding[i2], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale2.ctx, plFont, scale2._pointLabels[i2]);
    labelSizes[i2] = textSize;
    const angleRadians = _normalizeAngle(scale2.getIndexAngle(i2) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale2.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale2._pointLabelItems = buildPointLabelItems(scale2, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x2 = 0;
  let y3 = 0;
  if (hLimits.start < orig.l) {
    x2 = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x2);
  } else if (hLimits.end > orig.r) {
    x2 = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x2);
  }
  if (vLimits.start < orig.t) {
    y3 = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y3);
  } else if (vLimits.end > orig.b) {
    y3 = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y3);
  }
}
function createPointLabelItem(scale2, index2, itemOpts) {
  const outerDistance = scale2.drawingArea;
  const { extra, additionalAngle, padding, size } = itemOpts;
  const pointLabelPosition = scale2.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
  const y3 = yForAngle(pointLabelPosition.y, size.h, angle);
  const textAlign = getTextAlignForAngle(angle);
  const left2 = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
  return {
    visible: true,
    x: pointLabelPosition.x,
    y: y3,
    textAlign,
    left: left2,
    top: y3,
    right: left2 + size.w,
    bottom: y3 + size.h
  };
}
function isNotOverlapped(item, area) {
  if (!area) {
    return true;
  }
  const { left: left2, top: top2, right: right2, bottom: bottom2 } = item;
  const apexesInArea = _isPointInArea({
    x: left2,
    y: top2
  }, area) || _isPointInArea({
    x: left2,
    y: bottom2
  }, area) || _isPointInArea({
    x: right2,
    y: top2
  }, area) || _isPointInArea({
    x: right2,
    y: bottom2
  }, area);
  return !apexesInArea;
}
function buildPointLabelItems(scale2, labelSizes, padding) {
  const items = [];
  const valueCount = scale2._pointLabels.length;
  const opts = scale2.options;
  const { centerPointLabels, display } = opts.pointLabels;
  const itemOpts = {
    extra: getTickBackdropHeight(opts) / 2,
    additionalAngle: centerPointLabels ? PI / valueCount : 0
  };
  let area;
  for (let i2 = 0; i2 < valueCount; i2++) {
    itemOpts.padding = padding[i2];
    itemOpts.size = labelSizes[i2];
    const item = createPointLabelItem(scale2, i2, itemOpts);
    items.push(item);
    if (display === "auto") {
      item.visible = isNotOverlapped(item, area);
      if (item.visible) {
        area = item;
      }
    }
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x2, w2, align) {
  if (align === "right") {
    x2 -= w2;
  } else if (align === "center") {
    x2 -= w2 / 2;
  }
  return x2;
}
function yForAngle(y3, h4, angle) {
  if (angle === 90 || angle === 270) {
    y3 -= h4 / 2;
  } else if (angle > 270 || angle < 90) {
    y3 -= h4;
  }
  return y3;
}
function drawPointLabelBox(ctx, opts, item) {
  const { left: left2, top: top2, right: right2, bottom: bottom2 } = item;
  const { backdropColor } = opts;
  if (!isNullOrUndef(backdropColor)) {
    const borderRadius = toTRBLCorners(opts.borderRadius);
    const padding = toPadding(opts.backdropPadding);
    ctx.fillStyle = backdropColor;
    const backdropLeft = left2 - padding.left;
    const backdropTop = top2 - padding.top;
    const backdropWidth = right2 - left2 + padding.width;
    const backdropHeight = bottom2 - top2 + padding.height;
    if (Object.values(borderRadius).some((v) => v !== 0)) {
      ctx.beginPath();
      addRoundedRectPath(ctx, {
        x: backdropLeft,
        y: backdropTop,
        w: backdropWidth,
        h: backdropHeight,
        radius: borderRadius
      });
      ctx.fill();
    } else {
      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
  }
}
function drawPointLabels(scale2, labelCount) {
  const { ctx, options: { pointLabels } } = scale2;
  for (let i2 = labelCount - 1; i2 >= 0; i2--) {
    const item = scale2._pointLabelItems[i2];
    if (!item.visible) {
      continue;
    }
    const optsAtIndex = pointLabels.setContext(scale2.getPointLabelContext(i2));
    drawPointLabelBox(ctx, optsAtIndex, item);
    const plFont = toFont(optsAtIndex.font);
    const { x: x2, y: y3, textAlign } = item;
    renderText(ctx, scale2._pointLabels[i2], x2, y3 + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale2, radius2, circular, labelCount) {
  const { ctx } = scale2;
  if (circular) {
    ctx.arc(scale2.xCenter, scale2.yCenter, radius2, 0, TAU);
  } else {
    let pointPosition = scale2.getPointPosition(0, radius2);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i2 = 1; i2 < labelCount; i2++) {
      pointPosition = scale2.getPointPosition(i2, radius2);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale2, gridLineOpts, radius2, labelCount, borderOpts) {
  const ctx = scale2.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius2 < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale2, radius2, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index2, label) {
  return createContext(parent, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
class RadialLinearScale extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w2 = this.width = this.maxWidth - padding.width;
    const h4 = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w2 / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h4 / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w2, h4) / 2);
  }
  determineDataLimits() {
    const { min: min2, max: max2 } = this.getMinMax(false);
    this.min = isNumberFinite(min2) && !isNaN(min2) ? min2 : 0;
    this.max = isNumberFinite(max2) && !isNaN(max2) ? max2 : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index2) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index2
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v, i2) => this.chart.getDataVisibility(i2));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left: left2, top: top2, right: right2, bottom: bottom2 } = this._pointLabelItems[index2];
    return {
      left: left2,
      top: top2,
      right: right2,
      bottom: bottom2
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid: grid2, border } = opts;
    const labelCount = this._pointLabels.length;
    let i2, offset2, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid2.display) {
      this.ticks.forEach((tick, index2) => {
        if (index2 !== 0) {
          offset2 = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index2);
          const optsAtIndex = grid2.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset2, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i2 = labelCount - 1; i2 >= 0; i2--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i2));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset2 = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);
        position = this.getPointPosition(i2, offset2);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset2, width2;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index2) => {
      if (index2 === 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset2 = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width2 = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width2 / 2 - padding.left, -offset2 - tickFont.size / 2 - padding.top, width2 + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset2, tickFont, {
        color: optsAtIndex.color
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
}
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
const INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
const UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a3, b2) {
  return a3 - b2;
}
function parse$1(scale2, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale2._adapter;
  const { parser, round: round2, isoWeekday } = scale2._parseOpts;
  let value = input;
  if (typeof parser === "function") {
    value = parser(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min2, max2, capacity) {
  const ilen = UNITS.length;
  for (let i2 = UNITS.indexOf(minUnit); i2 < ilen - 1; ++i2) {
    const interval = INTERVALS[UNITS[i2]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max2 - min2) / (factor * interval.size)) <= capacity) {
      return UNITS[i2];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale2, numTicks, minUnit, min2, max2) {
  for (let i2 = UNITS.length - 1; i2 >= UNITS.indexOf(minUnit); i2--) {
    const unit = UNITS[i2];
    if (INTERVALS[unit].common && scale2._adapter.diff(max2, min2, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i2 = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i2 < ilen; ++i2) {
    if (INTERVALS[UNITS[i2]].common) {
      return UNITS[i2];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale2, ticks, map2, majorUnit) {
  const adapter = scale2._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map2[major];
    if (index2 >= 0) {
      ticks[index2].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale2, values, majorUnit) {
  const ticks = [];
  const map2 = {};
  const ilen = values.length;
  let i2, value;
  for (i2 = 0; i2 < ilen; ++i2) {
    value = values[i2];
    map2[value] = i2;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale2, ticks, map2, majorUnit);
}
class TimeScale extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse$1(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options = this.options;
    const adapter = this._adapter;
    const unit = options.time.unit || "day";
    let { min: min2, max: max2, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min2 = Math.min(min2, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max2 = Math.max(max2, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min2 = isNumberFinite(min2) && !isNaN(min2) ? min2 : +adapter.startOf(Date.now(), unit);
    max2 = isNumberFinite(max2) && !isNaN(max2) ? max2 : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min2, max2 - 1);
    this.max = Math.max(min2 + 1, max2);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min2 = Number.POSITIVE_INFINITY;
    let max2 = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min2 = arr[0];
      max2 = arr[arr.length - 1];
    }
    return {
      min: min2,
      max: max2
    };
  }
  buildTicks() {
    const options = this.options;
    const timeOpts = options.time;
    const tickOpts = options.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min2 = this.min;
    const max2 = this.max;
    const ticks = _filterBetween(timestamps, min2, max2);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min2)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start2 = 0;
    let end2 = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start2 = 1 - first;
      } else {
        start2 = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end2 = last;
      } else {
        end2 = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start2 = _limitValue(start2, 0, limit);
    end2 = _limitValue(end2, 0, limit);
    this._offsets = {
      start: start2,
      end: end2,
      factor: 1 / (start2 + 1 + end2)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min2 = this.min;
    const max2 = this.max;
    const options = this.options;
    const timeOpts = options.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min2, max2, this._getLabelCapacity(min2));
    const stepSize = valueOrDefault(options.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min2;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max2, min2, minor) > 1e5 * stepSize) {
      throw new Error(min2 + " and " + max2 + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max2; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max2 || options.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort((a3, b2) => a3 - b2).map((x2) => +x2);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format2) {
    const options = this.options;
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const fmt = format2 || formats[unit];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time, index2, ticks, format2) {
    const options = this.options;
    const formatter = options.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index2,
        ticks
      ], this);
    }
    const formats = options.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index2];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format2 || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i2, ilen, tick;
    for (i2 = 0, ilen = ticks.length; i2 < ilen; ++i2) {
      tick = ticks[i2];
      tick.label = this._tickFormatFunction(tick.value, i2, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format2 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format2);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i2, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i2 = 0, ilen = metas.length; i2 < ilen; ++i2) {
      timestamps = timestamps.concat(metas[i2].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i2, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i2 = 0, ilen = labels.length; i2 < ilen; ++i2) {
      timestamps.push(parse$1(this, labels[i2]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
}
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
class TimeSeriesScale extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate(table, this.min);
    this._tableRange = interpolate(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min: min2, max: max2 } = this;
    const items = [];
    const table = [];
    let i2, ilen, prev, curr, next;
    for (i2 = 0, ilen = timestamps.length; i2 < ilen; ++i2) {
      curr = timestamps[i2];
      if (curr >= min2 && curr <= max2) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min2,
          pos: 0
        },
        {
          time: max2,
          pos: 1
        }
      ];
    }
    for (i2 = 0, ilen = items.length; i2 < ilen; ++i2) {
      next = items[i2 + 1];
      prev = items[i2 - 1];
      curr = items[i2];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i2 / (ilen - 1)
        });
      }
    }
    return table;
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);
  }
}
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
const registerables = [
  controllers,
  elements,
  plugins,
  scales
];
const eventPrefix = /^on/;
const events = [];
Object.keys(globalThis).forEach((key) => {
  if (eventPrefix.test(key)) {
    events.push(key.replace(eventPrefix, ""));
  }
});
function useForwardEvents(getRef) {
  const component = current_component;
  const destructors = [];
  function forward(e2) {
    bubble(component, e2);
  }
  onMount(() => {
    const ref = getRef();
    events.forEach(ref instanceof Element ? (event) => destructors.push(listen(ref, event, forward)) : (event) => destructors.push(ref.$on(event, forward)));
  });
  onDestroy(() => {
    while (destructors.length) {
      destructors.pop()();
    }
  });
}
function create_fragment$e(ctx) {
  let canvas;
  let canvas_levels = [
    /*props*/
    ctx[1]
  ];
  let canvas_data = {};
  for (let i2 = 0; i2 < canvas_levels.length; i2 += 1) {
    canvas_data = assign$1(canvas_data, canvas_levels[i2]);
  }
  return {
    c() {
      canvas = element("canvas");
      this.h();
    },
    l(nodes) {
      canvas = claim_element(nodes, "CANVAS", {});
      children(canvas).forEach(detach);
      this.h();
    },
    h() {
      set_attributes(canvas, canvas_data);
    },
    m(target, anchor) {
      insert_hydration(target, canvas, anchor);
      ctx[8](canvas);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(canvas);
      }
      ctx[8](null);
    }
  };
}
function clean(props) {
  let { data, type, options, plugins: plugins2, children: children2, $$scope, $$slots, ...rest } = props;
  return rest;
}
function instance$c($$self, $$props, $$invalidate) {
  let { type } = $$props;
  let { data = { datasets: [] } } = $$props;
  let { options = {} } = $$props;
  let { plugins: plugins2 = [] } = $$props;
  let { updateMode = void 0 } = $$props;
  let { chart = null } = $$props;
  let canvasRef;
  let props = clean($$props);
  onMount(() => {
    $$invalidate(2, chart = new Chart$1(canvasRef, { type, data, options, plugins: plugins2 }));
  });
  afterUpdate(() => {
    if (!chart)
      return;
    $$invalidate(2, chart.data = data, chart);
    Object.assign(chart.options, options);
    chart.update(updateMode);
  });
  onDestroy(() => {
    if (chart)
      chart.destroy();
    $$invalidate(2, chart = null);
  });
  useForwardEvents(() => canvasRef);
  function canvas_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      canvasRef = $$value;
      $$invalidate(0, canvasRef);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(9, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    if ("type" in $$new_props)
      $$invalidate(3, type = $$new_props.type);
    if ("data" in $$new_props)
      $$invalidate(4, data = $$new_props.data);
    if ("options" in $$new_props)
      $$invalidate(5, options = $$new_props.options);
    if ("plugins" in $$new_props)
      $$invalidate(6, plugins2 = $$new_props.plugins);
    if ("updateMode" in $$new_props)
      $$invalidate(7, updateMode = $$new_props.updateMode);
    if ("chart" in $$new_props)
      $$invalidate(2, chart = $$new_props.chart);
  };
  $$props = exclude_internal_props($$props);
  return [
    canvasRef,
    props,
    chart,
    type,
    data,
    options,
    plugins2,
    updateMode,
    canvas_binding
  ];
}
class Chart extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$c, create_fragment$e, safe_not_equal, {
      type: 3,
      data: 4,
      options: 5,
      plugins: 6,
      updateMode: 7,
      chart: 2
    });
  }
}
Chart$1.register(...registerables);
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return /* @__PURE__ */ new Date(NaN);
  }
}
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}
function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  var dayOfMonth = date.getDate();
  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
var MILLISECONDS_IN_HOUR = 36e5;
function addHours(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR);
}
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function startOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}
var MILLISECONDS_IN_DAY$1 = 864e5;
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY$1);
}
var MILLISECONDS_IN_MINUTE = 6e4;
function addMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
}
function addQuarters(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var months = amount * 3;
  return addMonths(dirtyDate, months);
}
function addSeconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * 1e3);
}
function addWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var days = amount * 7;
  return addDays(dirtyDate, days);
}
function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}
function compareAsc(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
  } else {
    return diff;
  }
}
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}
function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() - dateRight.getFullYear();
}
function compareLocalAsc(dateLeft, dateRight) {
  var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
  } else {
    return diff;
  }
}
function differenceInDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign2 = compareLocalAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));
  dateLeft.setDate(dateLeft.getDate() - sign2 * difference);
  var isLastDayNotFull = Number(compareLocalAsc(dateLeft, dateRight) === -sign2);
  var result = sign2 * (difference - isLastDayNotFull);
  return result === 0 ? 0 : result;
}
function differenceInMilliseconds(dateLeft, dateRight) {
  requiredArgs(2, arguments);
  return toDate(dateLeft).getTime() - toDate(dateRight).getTime();
}
var roundingMap = {
  ceil: Math.ceil,
  round: Math.round,
  floor: Math.floor,
  trunc: function trunc(value) {
    return value < 0 ? Math.ceil(value) : Math.floor(value);
  }
  // Math.trunc is not supported by IE
};
var defaultRoundingMethod = "trunc";
function getRoundingMethod(method) {
  return method ? roundingMap[method] : roundingMap[defaultRoundingMethod];
}
function differenceInHours(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInHour;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
function differenceInMinutes(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInMinute;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
function endOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(23, 59, 59, 999);
  return date;
}
function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
function isLastDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return endOfDay(date).getTime() === endOfMonth(date).getTime();
}
function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign2 = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
  var result;
  if (difference < 1) {
    result = 0;
  } else {
    if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
      dateLeft.setDate(30);
    }
    dateLeft.setMonth(dateLeft.getMonth() - sign2 * difference);
    var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign2;
    if (isLastDayOfMonth(toDate(dirtyDateLeft)) && difference === 1 && compareAsc(dirtyDateLeft, dateRight) === 1) {
      isLastMonthNotFull = false;
    }
    result = sign2 * (difference - Number(isLastMonthNotFull));
  }
  return result === 0 ? 0 : result;
}
function differenceInQuarters(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInMonths(dateLeft, dateRight) / 3;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
function differenceInSeconds(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dateLeft, dateRight) / 1e3;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
function differenceInWeeks(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInDays(dateLeft, dateRight) / 7;
  return getRoundingMethod(options === null || options === void 0 ? void 0 : options.roundingMethod)(diff);
}
function differenceInYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign2 = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarYears(dateLeft, dateRight));
  dateLeft.setFullYear(1584);
  dateRight.setFullYear(1584);
  var isLastYearNotFull = compareAsc(dateLeft, dateRight) === -sign2;
  var result = sign2 * (difference - Number(isLastYearNotFull));
  return result === 0 ? 0 : result;
}
function startOfMinute(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setSeconds(0, 0);
  return date;
}
function startOfQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var currentMonth = date.getMonth();
  var month = currentMonth - currentMonth % 3;
  date.setMonth(month, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function endOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  date.setFullYear(year + 1, 0, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
function startOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var cleanDate = toDate(dirtyDate);
  var date = /* @__PURE__ */ new Date(0);
  date.setFullYear(cleanDate.getFullYear(), 0, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function endOfHour(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setMinutes(59, 59, 999);
  return date;
}
function endOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setDate(date.getDate() + diff);
  date.setHours(23, 59, 59, 999);
  return date;
}
function endOfMinute(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setSeconds(59, 999);
  return date;
}
function endOfQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var currentMonth = date.getMonth();
  var month = currentMonth - currentMonth % 3 + 3;
  date.setMonth(month, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
function endOfSecond(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setMilliseconds(999);
  return date;
}
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = /* @__PURE__ */ new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function addLeadingZeros(number, targetLength) {
  var sign2 = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign2 + output;
}
var formatters$2 = {
  // Year
  y: function y(date, token) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function d(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h: function h(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function H(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  // Minute
  m: function m(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function s(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
const formatters$3 = formatters$2;
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function G(date, token, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  // Year
  y: function y2(date, token, localize2) {
    if (token === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return formatters$3.y(date, token);
  },
  // Local week-numbering year
  Y: function Y(date, token, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function R(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function Q(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function q(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function M2(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return formatters$3.M(date, token);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone month
  L: function L(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Local week of year
  w: function w(date, token, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function I(date, token, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function d2(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return formatters$3.d(date, token);
  },
  // Day of year
  D: function D(date, token, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function E(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function e(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function c(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function i(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function a2(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function h3(date, token, localize2) {
    if (token === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return formatters$3.h(date, token);
  },
  // Hour [0-23]
  H: function H2(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return formatters$3.H(date, token);
  },
  // Hour [0-11]
  K: function K(date, token, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function k(date, token, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function m2(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return formatters$3.m(date, token);
  },
  // Second
  s: function s2(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return formatters$3.s(date, token);
  },
  // Fraction of second
  S: function S2(date, token) {
    return formatters$3.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset2, dirtyDelimiter) {
  var sign2 = offset2 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset2);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign2 + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign2 + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset2, dirtyDelimiter) {
  if (offset2 % 60 === 0) {
    var sign2 = offset2 > 0 ? "-" : "+";
    return sign2 + addLeadingZeros(Math.abs(offset2) / 60, 2);
  }
  return formatTimezone(offset2, dirtyDelimiter);
}
function formatTimezone(offset2, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign2 = offset2 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset2);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign2 + hours + delimiter + minutes;
}
const formatters$1 = formatters;
var dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
};
var timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
const longFormatters$1 = longFormatters;
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format2, input) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}
var formatDistanceLocale$1 = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance$2 = function formatDistance(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale$1[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
const formatDistance$3 = formatDistance$2;
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width2 = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width2] || args.formats[args.defaultWidth];
    return format2;
  };
}
var dateFormats$2 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats$2 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats$2 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong$4 = {
  date: buildFormatLongFn({
    formats: dateFormats$2,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$2,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$2,
    defaultWidth: "full"
  })
};
const formatLong$5 = formatLong$4;
var formatRelativeLocale$1 = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative$2 = function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale$1[token];
};
const formatRelative$3 = formatRelative$2;
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width2 = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width2] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index2];
  };
}
var eraValues$1 = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues$1 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues$1 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues$1 = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues$1 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber$1 = function ordinalNumber(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize$2 = {
  ordinalNumber: ordinalNumber$1,
  era: buildLocalizeFn({
    values: eraValues$1,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues$1,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues$1,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues$1,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues$1,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
const localize$3 = localize$2;
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width2 = options.width;
    var matchPattern = width2 && args.matchPatterns[width2] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width2 && args.parsePatterns[width2] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
var matchOrdinalNumberPattern$1 = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern$1 = /\d+/i;
var matchEraPatterns$1 = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns$1 = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns$1 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns$1 = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns$1 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns$1 = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns$1 = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns$1 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns$1 = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns$1 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match$2 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern$1,
    parsePattern: parseOrdinalNumberPattern$1,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns$1,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1,
    defaultParseWidth: "any"
  })
};
const match$3 = match$2;
var locale$3 = {
  code: "en-US",
  formatDistance: formatDistance$3,
  formatLong: formatLong$5,
  formatRelative: formatRelative$3,
  localize: localize$3,
  match: match$3,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const enUS = locale$3;
var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$1 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$1 = /''/g;
var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : enUS;
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp$1).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp$1).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString$1(substring);
    }
    var formatter = formatters$1[firstCharacter];
    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString$1(input) {
  var matched = input.match(escapedStringRegExp$1);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp$1, "'");
}
function assign(target, object) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      target[property] = object[property];
    }
  }
  return target;
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return {
        s: F,
        n: function n() {
          if (i2 >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i2++]
          };
        },
        e: function e2(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function s3() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e2(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = /* @__PURE__ */ function() {
  function Setter2() {
    _classCallCheck(this, Setter2);
    _defineProperty(this, "priority", void 0);
    _defineProperty(this, "subPriority", 0);
  }
  _createClass(Setter2, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);
  return Setter2;
}();
var ValueSetter = /* @__PURE__ */ function(_Setter) {
  _inherits(ValueSetter2, _Setter);
  var _super = _createSuper(ValueSetter2);
  function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
    var _this;
    _classCallCheck(this, ValueSetter2);
    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;
    if (subPriority) {
      _this.subPriority = subPriority;
    }
    return _this;
  }
  _createClass(ValueSetter2, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set2(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);
  return ValueSetter2;
}(Setter);
var DateToSystemTimezoneSetter = /* @__PURE__ */ function(_Setter2) {
  _inherits(DateToSystemTimezoneSetter2, _Setter2);
  var _super2 = _createSuper(DateToSystemTimezoneSetter2);
  function DateToSystemTimezoneSetter2() {
    var _this2;
    _classCallCheck(this, DateToSystemTimezoneSetter2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
    _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);
    return _this2;
  }
  _createClass(DateToSystemTimezoneSetter2, [{
    key: "set",
    value: function set2(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }
      var convertedDate = /* @__PURE__ */ new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);
  return DateToSystemTimezoneSetter2;
}(Setter);
var Parser = /* @__PURE__ */ function() {
  function Parser2() {
    _classCallCheck(this, Parser2);
    _defineProperty(this, "incompatibleTokens", void 0);
    _defineProperty(this, "priority", void 0);
    _defineProperty(this, "subPriority", void 0);
  }
  _createClass(Parser2, [{
    key: "run",
    value: function run(dateString, token, match2, options) {
      var result = this.parse(dateString, token, match2, options);
      if (!result) {
        return null;
      }
      return {
        setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);
  return Parser2;
}();
var EraParser = /* @__PURE__ */ function(_Parser) {
  _inherits(EraParser2, _Parser);
  var _super = _createSuper(EraParser2);
  function EraParser2() {
    var _this;
    _classCallCheck(this, EraParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 140);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
    return _this;
  }
  _createClass(EraParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "G":
        case "GG":
        case "GGG":
          return match2.era(dateString, {
            width: "abbreviated"
          }) || match2.era(dateString, {
            width: "narrow"
          });
        case "GGGGG":
          return match2.era(dateString, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return match2.era(dateString, {
            width: "wide"
          }) || match2.era(dateString, {
            width: "abbreviated"
          }) || match2.era(dateString, {
            width: "narrow"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return EraParser2;
}(Parser);
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign2 = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign2 * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex$1(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
var YearParser = /* @__PURE__ */ function(_Parser) {
  _inherits(YearParser2, _Parser);
  var _super = _createSuper(YearParser2);
  function YearParser2() {
    var _this;
    _classCallCheck(this, YearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(YearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback5 = function valueCallback6(year) {
        return {
          year,
          isTwoDigitYear: token === "yy"
        };
      };
      switch (token) {
        case "y":
          return mapValue(parseNDigits(4, dateString), valueCallback5);
        case "yo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback5);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback5);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return YearParser2;
}(Parser);
var LocalWeekYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits(LocalWeekYearParser2, _Parser);
  var _super = _createSuper(LocalWeekYearParser2);
  function LocalWeekYearParser2() {
    var _this;
    _classCallCheck(this, LocalWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass(LocalWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback5 = function valueCallback6(year) {
        return {
          year,
          isTwoDigitYear: token === "YY"
        };
      };
      switch (token) {
        case "Y":
          return mapValue(parseNDigits(4, dateString), valueCallback5);
        case "Yo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback5);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback5);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    }
  }]);
  return LocalWeekYearParser2;
}(Parser);
var ISOWeekYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ISOWeekYearParser2, _Parser);
  var _super = _createSuper(ISOWeekYearParser2);
  function ISOWeekYearParser2() {
    var _this;
    _classCallCheck(this, ISOWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ISOWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      if (token === "R") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      var firstWeekOfYear = /* @__PURE__ */ new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  }]);
  return ISOWeekYearParser2;
}(Parser);
var ExtendedYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ExtendedYearParser2, _Parser);
  var _super = _createSuper(ExtendedYearParser2);
  function ExtendedYearParser2() {
    var _this;
    _classCallCheck(this, ExtendedYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 130);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ExtendedYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      if (token === "u") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ExtendedYearParser2;
}(Parser);
var QuarterParser = /* @__PURE__ */ function(_Parser) {
  _inherits(QuarterParser2, _Parser);
  var _super = _createSuper(QuarterParser2);
  function QuarterParser2() {
    var _this;
    _classCallCheck(this, QuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 120);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(QuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "Q":
        case "QQ":
          return parseNDigits(token.length, dateString);
        case "Qo":
          return match2.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "QQQ":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return QuarterParser2;
}(Parser);
var StandAloneQuarterParser = /* @__PURE__ */ function(_Parser) {
  _inherits(StandAloneQuarterParser2, _Parser);
  var _super = _createSuper(StandAloneQuarterParser2);
  function StandAloneQuarterParser2() {
    var _this;
    _classCallCheck(this, StandAloneQuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 120);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(StandAloneQuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "q":
        case "qq":
          return parseNDigits(token.length, dateString);
        case "qo":
          return match2.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "qqq":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneQuarterParser2;
}(Parser);
var MonthParser = /* @__PURE__ */ function(_Parser) {
  _inherits(MonthParser2, _Parser);
  var _super = _createSuper(MonthParser2);
  function MonthParser2() {
    var _this;
    _classCallCheck(this, MonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
    _defineProperty(_assertThisInitialized(_this), "priority", 110);
    return _this;
  }
  _createClass(MonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback5 = function valueCallback6(value) {
        return value - 1;
      };
      switch (token) {
        case "M":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback5);
        case "MM":
          return mapValue(parseNDigits(2, dateString), valueCallback5);
        case "Mo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback5);
        case "MMM":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMMM":
          return match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return match2.month(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return MonthParser2;
}(Parser);
var StandAloneMonthParser = /* @__PURE__ */ function(_Parser) {
  _inherits(StandAloneMonthParser2, _Parser);
  var _super = _createSuper(StandAloneMonthParser2);
  function StandAloneMonthParser2() {
    var _this;
    _classCallCheck(this, StandAloneMonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 110);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(StandAloneMonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback5 = function valueCallback6(value) {
        return value - 1;
      };
      switch (token) {
        case "L":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback5);
        case "LL":
          return mapValue(parseNDigits(2, dateString), valueCallback5);
        case "Lo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback5);
        case "LLL":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLLL":
          return match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return match2.month(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneMonthParser2;
}(Parser);
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
var LocalWeekParser = /* @__PURE__ */ function(_Parser) {
  _inherits(LocalWeekParser2, _Parser);
  var _super = _createSuper(LocalWeekParser2);
  function LocalWeekParser2() {
    var _this;
    _classCallCheck(this, LocalWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 100);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass(LocalWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "w":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "wo":
          return match2.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    }
  }]);
  return LocalWeekParser2;
}(Parser);
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
var ISOWeekParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ISOWeekParser2, _Parser);
  var _super = _createSuper(ISOWeekParser2);
  function ISOWeekParser2() {
    var _this;
    _classCallCheck(this, ISOWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 100);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ISOWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "I":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "Io":
          return match2.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value));
    }
  }]);
  return ISOWeekParser2;
}(Parser);
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DateParser = /* @__PURE__ */ function(_Parser) {
  _inherits(DateParser2, _Parser);
  var _super = _createSuper(DateParser2);
  function DateParser2() {
    var _this;
    _classCallCheck(this, DateParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "subPriority", 1);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(DateParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "d":
          return parseNumericPattern(numericPatterns.date, dateString);
        case "do":
          return match2.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$1(year);
      var month = date.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DateParser2;
}(Parser);
var DayOfYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits(DayOfYearParser2, _Parser);
  var _super = _createSuper(DayOfYearParser2);
  function DayOfYearParser2() {
    var _this;
    _classCallCheck(this, DayOfYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "subpriority", 1);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(DayOfYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case "Do":
          return match2.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$1(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayOfYearParser2;
}(Parser);
function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var DayParser = /* @__PURE__ */ function(_Parser) {
  _inherits(DayParser2, _Parser);
  var _super = _createSuper(DayParser2);
  function DayParser2() {
    var _this;
    _classCallCheck(this, DayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(DayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "E":
        case "EE":
        case "EEE":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEE":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEE":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayParser2;
}(Parser);
var LocalDayParser = /* @__PURE__ */ function(_Parser) {
  _inherits(LocalDayParser2, _Parser);
  var _super = _createSuper(LocalDayParser2);
  function LocalDayParser2() {
    var _this;
    _classCallCheck(this, LocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
    return _this;
  }
  _createClass(LocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2, options) {
      var valueCallback5 = function valueCallback6(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "e":
        case "ee":
          return mapValue(parseNDigits(token.length, dateString), valueCallback5);
        case "eo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback5);
        case "eee":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeee":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeee":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return LocalDayParser2;
}(Parser);
var StandAloneLocalDayParser = /* @__PURE__ */ function(_Parser) {
  _inherits(StandAloneLocalDayParser2, _Parser);
  var _super = _createSuper(StandAloneLocalDayParser2);
  function StandAloneLocalDayParser2() {
    var _this;
    _classCallCheck(this, StandAloneLocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
    return _this;
  }
  _createClass(StandAloneLocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2, options) {
      var valueCallback5 = function valueCallback6(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "c":
        case "cc":
          return mapValue(parseNDigits(token.length, dateString), valueCallback5);
        case "co":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback5);
        case "ccc":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "ccccc":
          return match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccc":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneLocalDayParser2;
}(Parser);
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var ISODayParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ISODayParser2, _Parser);
  var _super = _createSuper(ISODayParser2);
  function ISODayParser2() {
    var _this;
    _classCallCheck(this, ISODayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 90);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass(ISODayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback5 = function valueCallback6(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        case "i":
        case "ii":
          return parseNDigits(token.length, dateString);
        case "io":
          return match2.ordinalNumber(dateString, {
            unit: "day"
          });
        case "iii":
          return mapValue(match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback5);
        case "iiiii":
          return mapValue(match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback5);
        case "iiiiii":
          return mapValue(match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback5);
        case "iiii":
        default:
          return mapValue(match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback5);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date = setUTCISODay(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ISODayParser2;
}(Parser);
var AMPMParser = /* @__PURE__ */ function(_Parser) {
  _inherits(AMPMParser2, _Parser);
  var _super = _createSuper(AMPMParser2);
  function AMPMParser2() {
    var _this;
    _classCallCheck(this, AMPMParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass(AMPMParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "a":
        case "aa":
        case "aaa":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMParser2;
}(Parser);
var AMPMMidnightParser = /* @__PURE__ */ function(_Parser) {
  _inherits(AMPMMidnightParser2, _Parser);
  var _super = _createSuper(AMPMMidnightParser2);
  function AMPMMidnightParser2() {
    var _this;
    _classCallCheck(this, AMPMMidnightParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass(AMPMMidnightParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "b":
        case "bb":
        case "bbb":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMMidnightParser2;
}(Parser);
var DayPeriodParser = /* @__PURE__ */ function(_Parser) {
  _inherits(DayPeriodParser2, _Parser);
  var _super = _createSuper(DayPeriodParser2);
  function DayPeriodParser2() {
    var _this;
    _classCallCheck(this, DayPeriodParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 80);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
    return _this;
  }
  _createClass(DayPeriodParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return DayPeriodParser2;
}(Parser);
var Hour1to12Parser = /* @__PURE__ */ function(_Parser) {
  _inherits(Hour1to12Parser2, _Parser);
  var _super = _createSuper(Hour1to12Parser2);
  function Hour1to12Parser2() {
    var _this;
    _classCallCheck(this, Hour1to12Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass(Hour1to12Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case "ho":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour1to12Parser2;
}(Parser);
var Hour0to23Parser = /* @__PURE__ */ function(_Parser) {
  _inherits(Hour0to23Parser2, _Parser);
  var _super = _createSuper(Hour0to23Parser2);
  function Hour0to23Parser2() {
    var _this;
    _classCallCheck(this, Hour0to23Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass(Hour0to23Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case "Ho":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);
  return Hour0to23Parser2;
}(Parser);
var Hour0To11Parser = /* @__PURE__ */ function(_Parser) {
  _inherits(Hour0To11Parser2, _Parser);
  var _super = _createSuper(Hour0To11Parser2);
  function Hour0To11Parser2() {
    var _this;
    _classCallCheck(this, Hour0To11Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass(Hour0To11Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case "Ko":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour0To11Parser2;
}(Parser);
var Hour1To24Parser = /* @__PURE__ */ function(_Parser) {
  _inherits(Hour1To24Parser2, _Parser);
  var _super = _createSuper(Hour1To24Parser2);
  function Hour1To24Parser2() {
    var _this;
    _classCallCheck(this, Hour1To24Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 70);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
    return _this;
  }
  _createClass(Hour1To24Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case "ko":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);
  return Hour1To24Parser2;
}(Parser);
var MinuteParser = /* @__PURE__ */ function(_Parser) {
  _inherits(MinuteParser2, _Parser);
  var _super = _createSuper(MinuteParser2);
  function MinuteParser2() {
    var _this;
    _classCallCheck(this, MinuteParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 60);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass(MinuteParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, dateString);
        case "mo":
          return match2.ordinalNumber(dateString, {
            unit: "minute"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);
  return MinuteParser2;
}(Parser);
var SecondParser = /* @__PURE__ */ function(_Parser) {
  _inherits(SecondParser2, _Parser);
  var _super = _createSuper(SecondParser2);
  function SecondParser2() {
    var _this;
    _classCallCheck(this, SecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 50);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass(SecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "s":
          return parseNumericPattern(numericPatterns.second, dateString);
        case "so":
          return match2.ordinalNumber(dateString, {
            unit: "second"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);
  return SecondParser2;
}(Parser);
var FractionOfSecondParser = /* @__PURE__ */ function(_Parser) {
  _inherits(FractionOfSecondParser2, _Parser);
  var _super = _createSuper(FractionOfSecondParser2);
  function FractionOfSecondParser2() {
    var _this;
    _classCallCheck(this, FractionOfSecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 30);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass(FractionOfSecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      var valueCallback5 = function valueCallback6(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };
      return mapValue(parseNDigits(token.length, dateString), valueCallback5);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);
  return FractionOfSecondParser2;
}(Parser);
var ISOTimezoneWithZParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ISOTimezoneWithZParser2, _Parser);
  var _super = _createSuper(ISOTimezoneWithZParser2);
  function ISOTimezoneWithZParser2() {
    var _this;
    _classCallCheck(this, ISOTimezoneWithZParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 10);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "x"]);
    return _this;
  }
  _createClass(ISOTimezoneWithZParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      switch (token) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneWithZParser2;
}(Parser);
var ISOTimezoneParser = /* @__PURE__ */ function(_Parser) {
  _inherits(ISOTimezoneParser2, _Parser);
  var _super = _createSuper(ISOTimezoneParser2);
  function ISOTimezoneParser2() {
    var _this;
    _classCallCheck(this, ISOTimezoneParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 10);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ["t", "T", "X"]);
    return _this;
  }
  _createClass(ISOTimezoneParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      switch (token) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneParser2;
}(Parser);
var TimestampSecondsParser = /* @__PURE__ */ function(_Parser) {
  _inherits(TimestampSecondsParser2, _Parser);
  var _super = _createSuper(TimestampSecondsParser2);
  function TimestampSecondsParser2() {
    var _this;
    _classCallCheck(this, TimestampSecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 40);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass(TimestampSecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value * 1e3), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampSecondsParser2;
}(Parser);
var TimestampMillisecondsParser = /* @__PURE__ */ function(_Parser) {
  _inherits(TimestampMillisecondsParser2, _Parser);
  var _super = _createSuper(TimestampMillisecondsParser2);
  function TimestampMillisecondsParser2() {
    var _this;
    _classCallCheck(this, TimestampMillisecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 20);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass(TimestampMillisecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampMillisecondsParser2;
}(Parser);
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : enUS;
  if (!locale2.match) {
    throw new RangeError("locale must contain match property");
  }
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate(dirtyReferenceDate);
    } else {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  var setters = [new DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter in longFormatters$1) {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp);
  var usedTokens = [];
  var _iterator = _createForOfIteratorHelper(tokens), _step;
  try {
    var _loop = function _loop2() {
      var token = _step.value;
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      var firstCharacter = token[0];
      var parser = parsers[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function(usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });
          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }
        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.run(dateString, token, locale2.match, subFnOptions);
        if (!parseResult) {
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
        }
        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        }
        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString(token);
        }
        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _ret = _loop();
      if (_typeof(_ret) === "object")
        return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a3, b2) {
    return b2 - a3;
  }).filter(function(priority, index2, array) {
    return array.indexOf(priority) === index2;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a3, b2) {
      return b2.subPriority - a3.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var setter = _step2.value;
      if (!setter.validate(utcDate, subFnOptions)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      var result = setter.set(utcDate, flags, subFnOptions);
      if (Array.isArray(result)) {
        utcDate = result[0];
        assign(flags, result[1]);
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return utcDate;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
function startOfHour(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setMinutes(0, 0, 0);
  return date;
}
function startOfSecond(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setMilliseconds(0);
  return date;
}
function parseISO(argument, options) {
  var _options$additionalDi;
  requiredArgs(1, arguments);
  var additionalDigits = toInteger((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var date;
  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date || isNaN(date.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var timestamp = date.getTime();
  var time = 0;
  var offset2;
  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset2 = parseTimezone(dateStrings.timezone);
    if (isNaN(offset2)) {
      return /* @__PURE__ */ new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time);
    var result = /* @__PURE__ */ new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }
  return new Date(timestamp + time + offset2);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString;
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }
  if (timeString) {
    var token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
  var captures = dateString.match(regex);
  if (!captures)
    return {
      year: NaN,
      restDateString: ""
    };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  if (year === null)
    return /* @__PURE__ */ new Date(NaN);
  var captures = dateString.match(dateRegex);
  if (!captures)
    return /* @__PURE__ */ new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date = /* @__PURE__ */ new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures)
    return NaN;
  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z")
    return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures)
    return 0;
  var sign2 = captures[1] === "+" ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }
  return sign2 * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date = /* @__PURE__ */ new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}
/*!
 * chartjs-adapter-date-fns v3.0.0
 * https://www.chartjs.org
 * (c) 2022 chartjs-adapter-date-fns Contributors
 * Released under the MIT license
 */
const FORMATS = {
  datetime: "MMM d, yyyy, h:mm:ss aaaa",
  millisecond: "h:mm:ss.SSS aaaa",
  second: "h:mm:ss aaaa",
  minute: "h:mm aaaa",
  hour: "ha",
  day: "MMM d",
  week: "PP",
  month: "MMM yyyy",
  quarter: "qqq - yyyy",
  year: "yyyy"
};
adapters._date.override({
  _id: "date-fns",
  // DEBUG
  formats: function() {
    return FORMATS;
  },
  parse: function(value, fmt) {
    if (value === null || typeof value === "undefined") {
      return null;
    }
    const type = typeof value;
    if (type === "number" || value instanceof Date) {
      value = toDate(value);
    } else if (type === "string") {
      if (typeof fmt === "string") {
        value = parse(value, fmt, /* @__PURE__ */ new Date(), this.options);
      } else {
        value = parseISO(value, this.options);
      }
    }
    return isValid(value) ? value.getTime() : null;
  },
  format: function(time, fmt) {
    return format(time, fmt, this.options);
  },
  add: function(time, amount, unit) {
    switch (unit) {
      case "millisecond":
        return addMilliseconds(time, amount);
      case "second":
        return addSeconds(time, amount);
      case "minute":
        return addMinutes(time, amount);
      case "hour":
        return addHours(time, amount);
      case "day":
        return addDays(time, amount);
      case "week":
        return addWeeks(time, amount);
      case "month":
        return addMonths(time, amount);
      case "quarter":
        return addQuarters(time, amount);
      case "year":
        return addYears(time, amount);
      default:
        return time;
    }
  },
  diff: function(max2, min2, unit) {
    switch (unit) {
      case "millisecond":
        return differenceInMilliseconds(max2, min2);
      case "second":
        return differenceInSeconds(max2, min2);
      case "minute":
        return differenceInMinutes(max2, min2);
      case "hour":
        return differenceInHours(max2, min2);
      case "day":
        return differenceInDays(max2, min2);
      case "week":
        return differenceInWeeks(max2, min2);
      case "month":
        return differenceInMonths(max2, min2);
      case "quarter":
        return differenceInQuarters(max2, min2);
      case "year":
        return differenceInYears(max2, min2);
      default:
        return 0;
    }
  },
  startOf: function(time, unit, weekday) {
    switch (unit) {
      case "second":
        return startOfSecond(time);
      case "minute":
        return startOfMinute(time);
      case "hour":
        return startOfHour(time);
      case "day":
        return startOfDay(time);
      case "week":
        return startOfWeek(time);
      case "isoWeek":
        return startOfWeek(time, { weekStartsOn: +weekday });
      case "month":
        return startOfMonth(time);
      case "quarter":
        return startOfQuarter(time);
      case "year":
        return startOfYear(time);
      default:
        return time;
    }
  },
  endOf: function(time, unit) {
    switch (unit) {
      case "second":
        return endOfSecond(time);
      case "minute":
        return endOfMinute(time);
      case "hour":
        return endOfHour(time);
      case "day":
        return endOfDay(time);
      case "week":
        return endOfWeek(time);
      case "month":
        return endOfMonth(time);
      case "quarter":
        return endOfQuarter(time);
      case "year":
        return endOfYear(time);
      default:
        return time;
    }
  }
});
var dateFormats$1 = {
  full: "EEEE, d MMMM yyyy",
  long: "d MMMM yyyy",
  medium: "d MMM yyyy",
  short: "dd/MM/yyyy"
};
var timeFormats$1 = {
  full: "HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats$1 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong$2 = {
  date: buildFormatLongFn({
    formats: dateFormats$1,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats$1,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats$1,
    defaultWidth: "full"
  })
};
const formatLong$3 = formatLong$2;
var locale$2 = {
  code: "en-GB",
  formatDistance: formatDistance$3,
  formatLong: formatLong$3,
  formatRelative: formatRelative$3,
  localize: localize$3,
  match: match$3,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const enGB = locale$2;
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "mindre enn ett sekund",
    other: "mindre enn {{count}} sekunder"
  },
  xSeconds: {
    one: "ett sekund",
    other: "{{count}} sekunder"
  },
  halfAMinute: "et halvt minutt",
  lessThanXMinutes: {
    one: "mindre enn ett minutt",
    other: "mindre enn {{count}} minutter"
  },
  xMinutes: {
    one: "ett minutt",
    other: "{{count}} minutter"
  },
  aboutXHours: {
    one: "omtrent en time",
    other: "omtrent {{count}} timer"
  },
  xHours: {
    one: "en time",
    other: "{{count}} timer"
  },
  xDays: {
    one: "en dag",
    other: "{{count}} dager"
  },
  aboutXWeeks: {
    one: "omtrent en uke",
    other: "omtrent {{count}} uker"
  },
  xWeeks: {
    one: "en uke",
    other: "{{count}} uker"
  },
  aboutXMonths: {
    one: "omtrent en måned",
    other: "omtrent {{count}} måneder"
  },
  xMonths: {
    one: "en måned",
    other: "{{count}} måneder"
  },
  aboutXYears: {
    one: "omtrent ett år",
    other: "omtrent {{count}} år"
  },
  xYears: {
    one: "ett år",
    other: "{{count}} år"
  },
  overXYears: {
    one: "over ett år",
    other: "over {{count}} år"
  },
  almostXYears: {
    one: "nesten ett år",
    other: "nesten {{count}} år"
  }
};
var formatDistance2 = function formatDistance3(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "om " + result;
    } else {
      return result + " siden";
    }
  }
  return result;
};
const formatDistance$1 = formatDistance2;
var dateFormats = {
  full: "EEEE d. MMMM y",
  long: "d. MMMM y",
  medium: "d. MMM y",
  short: "dd.MM.y"
};
var timeFormats = {
  full: "'kl'. HH:mm:ss zzzz",
  long: "HH:mm:ss z",
  medium: "HH:mm:ss",
  short: "HH:mm"
};
var dateTimeFormats = {
  full: "{{date}} 'kl.' {{time}}",
  long: "{{date}} 'kl.' {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
const formatLong$1 = formatLong;
var formatRelativeLocale = {
  lastWeek: "'forrige' eeee 'kl.' p",
  yesterday: "'i går kl.' p",
  today: "'i dag kl.' p",
  tomorrow: "'i morgen kl.' p",
  nextWeek: "EEEE 'kl.' p",
  other: "P"
};
var formatRelative2 = function formatRelative3(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};
const formatRelative$1 = formatRelative2;
var eraValues = {
  narrow: ["f.Kr.", "e.Kr."],
  abbreviated: ["f.Kr.", "e.Kr."],
  wide: ["før Kristus", "etter Kristus"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1. kvartal", "2. kvartal", "3. kvartal", "4. kvartal"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["jan.", "feb.", "mars", "apr.", "mai", "juni", "juli", "aug.", "sep.", "okt.", "nov.", "des."],
  wide: ["januar", "februar", "mars", "april", "mai", "juni", "juli", "august", "september", "oktober", "november", "desember"]
};
var dayValues = {
  narrow: ["S", "M", "T", "O", "T", "F", "L"],
  short: ["sø", "ma", "ti", "on", "to", "fr", "lø"],
  abbreviated: ["søn", "man", "tir", "ons", "tor", "fre", "lør"],
  wide: ["søndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lørdag"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "midnatt",
    noon: "middag",
    morning: "på morg.",
    afternoon: "på etterm.",
    evening: "på kvelden",
    night: "på natten"
  },
  abbreviated: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "på morg.",
    afternoon: "på etterm.",
    evening: "på kvelden",
    night: "på natten"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnatt",
    noon: "middag",
    morning: "på morgenen",
    afternoon: "på ettermiddagen",
    evening: "på kvelden",
    night: "på natten"
  }
};
var ordinalNumber2 = function ordinalNumber3(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  return number + ".";
};
var localize = {
  ordinalNumber: ordinalNumber2,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback2(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide"
  })
};
const localize$1 = localize;
var matchOrdinalNumberPattern = /^(\d+)\.?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
  abbreviated: /^(f\.? ?Kr\.?|fvt\.?|e\.? ?Kr\.?|evt\.?)/i,
  wide: /^(før Kristus|før vår tid|etter Kristus|vår tid)/i
};
var parseEraPatterns = {
  any: [/^f/i, /^e/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](\.)? kvartal/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mars?|apr|mai|juni?|juli?|aug|sep|okt|nov|des)\.?/i,
  wide: /^(januar|februar|mars|april|mai|juni|juli|august|september|oktober|november|desember)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^mai/i, /^jun/i, /^jul/i, /^aug/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtofl]/i,
  short: /^(sø|ma|ti|on|to|fr|lø)/i,
  abbreviated: /^(søn|man|tir|ons|tor|fre|lør)/i,
  wide: /^(søndag|mandag|tirsdag|onsdag|torsdag|fredag|lørdag)/i
};
var parseDayPatterns = {
  any: [/^s/i, /^m/i, /^ti/i, /^o/i, /^to/i, /^f/i, /^l/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(midnatt|middag|(på) (morgenen|ettermiddagen|kvelden|natten)|[ap])/i,
  any: /^([ap]\.?\s?m\.?|midnatt|middag|(på) (morgenen|ettermiddagen|kvelden|natten))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a(\.?\s?m\.?)?$/i,
    pm: /^p(\.?\s?m\.?)?$/i,
    midnight: /^midn/i,
    noon: /^midd/i,
    morning: /morgen/i,
    afternoon: /ettermiddag/i,
    evening: /kveld/i,
    night: /natt/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback3(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback4(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const match$1 = match;
var locale$1 = {
  code: "nb",
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const noNB = locale$1;
const locale = writable(navigator.language);
const dateFnsLocale = derived(
  locale,
  (l) => {
    switch (l) {
      case "en-US":
        return enUS;
      case "nb":
        return noNB;
      case "en-GB":
      default:
        return enGB;
    }
  },
  enGB
);
function create_else_block$2(ctx) {
  let div2;
  let chart_1;
  let updating_chart;
  let current;
  function chart_1_chart_binding(value) {
    ctx[6](value);
  }
  let chart_1_props = {
    type: "line",
    data: (
      /*data*/
      ctx[2]
    ),
    options: (
      /*options*/
      ctx[3]
    )
  };
  if (
    /*chart*/
    ctx[1] !== void 0
  ) {
    chart_1_props.chart = /*chart*/
    ctx[1];
  }
  chart_1 = new Chart({ props: chart_1_props });
  binding_callbacks.push(() => bind(chart_1, "chart", chart_1_chart_binding));
  return {
    c() {
      div2 = element("div");
      create_component(chart_1.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      claim_component(chart_1.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "w-full h-full");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(chart_1, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const chart_1_changes = {};
      if (dirty & /*data*/
      4)
        chart_1_changes.data = /*data*/
        ctx2[2];
      if (dirty & /*options*/
      8)
        chart_1_changes.options = /*options*/
        ctx2[3];
      if (!updating_chart && dirty & /*chart*/
      2) {
        updating_chart = true;
        chart_1_changes.chart = /*chart*/
        ctx2[1];
        add_flush_callback(() => updating_chart = false);
      }
      chart_1.$set(chart_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(chart_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chart_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(chart_1);
    }
  };
}
function create_if_block$9(ctx) {
  let span;
  let textContent = "No series selected";
  return {
    c() {
      span = element("span");
      span.textContent = textContent;
    },
    l(nodes) {
      span = claim_element(nodes, "SPAN", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-1eghp73")
        span.textContent = textContent;
    },
    m(target, anchor) {
      insert_hydration(target, span, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$d(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$9, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*series*/
      ctx2[0] === void 0 || /*series*/
      ctx2[0].length === 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function resample(entries, aggregation, sampleRate) {
  if (aggregation === void 0 || aggregation === "none" || entries.step / 1e3 >= sampleRate) {
    return entries.values.map((entry) => ({
      x: new Date(entry.t).getTime(),
      y: entry.v
    }));
  } else {
    const buckets = entries.values.reduce(
      (timeBuckets, entry) => {
        const time = new Date(entry.t);
        const value = entry.v;
        const timeOfDay = time.getHours() * 3600 + time.getMinutes() * 60 + time.getSeconds();
        const timestamp = time.getTime() - timeOfDay % sampleRate * 1e3;
        const bucket = timeBuckets[timestamp] = timeBuckets[timestamp] ?? [];
        bucket.push(value);
        return timeBuckets;
      },
      {}
    );
    const result = Object.keys(buckets).map((timestamp) => {
      const values = buckets[timestamp];
      switch (aggregation) {
        case "min":
          return {
            x: Number(timestamp),
            y: Math.min(...values)
          };
        case "max":
          return {
            x: Number(timestamp),
            y: Math.max(...values)
          };
        case "sum":
          return {
            x: Number(timestamp),
            y: values.reduce((a3, b2) => a3 + b2, 0)
          };
        case "avg":
          return {
            x: Number(timestamp),
            y: values.reduce((a3, b2) => a3 + b2, 0) / values.length
          };
        case "first":
          return { x: Number(timestamp), y: values[0] };
        case "last":
          return {
            x: Number(timestamp),
            y: values[values.length - 1]
          };
      }
    });
    return result;
  }
}
function instance$b($$self, $$props, $$invalidate) {
  let $devices;
  let $homey;
  let $insights;
  let $dateFnsLocale;
  component_subscribe($$self, devices, ($$value) => $$invalidate(10, $devices = $$value));
  component_subscribe($$self, homey, ($$value) => $$invalidate(11, $homey = $$value));
  component_subscribe($$self, insights, ($$value) => $$invalidate(5, $insights = $$value));
  component_subscribe($$self, dateFnsLocale, ($$value) => $$invalidate(12, $dateFnsLocale = $$value));
  const colors2 = ["#36a2eb", "#ff6384", "#4bc0c0", "#ff9f40", "#9966ff"];
  let { settings } = $$props;
  let resolution;
  let series;
  let timeout;
  let chart;
  let data = { datasets: [] };
  let options = {
    plugins: {
      legend: {
        display: true,
        labels: { boxWidth: 10, boxHeight: 2 }
      }
    },
    elements: { point: { radius: 0 } },
    scales: {
      x: {
        type: "timeseries",
        adapters: { date: { locale: $dateFnsLocale } }
      }
    },
    responsive: true,
    maintainAspectRatio: false,
    animation: false
  };
  onDestroy(() => {
    if (timeout !== void 0) {
      clearTimeout(timeout);
    }
  });
  async function onSettings(s3) {
    let load = false;
    if (resolution === void 0 || resolution !== s3.resolution) {
      resolution = s3.resolution ?? "today";
      load = true;
    }
    if (series === void 0 || series.length != s3.series.length || JSON.stringify(series) !== JSON.stringify(s3.series)) {
      if ((s3 == null ? void 0 : s3.series) !== void 0) {
        $$invalidate(0, series = [...s3.series]);
        load = true;
      }
    }
    if (load) {
      reload();
    }
  }
  function onInsights(logs) {
    reload();
  }
  function reload() {
    if (timeout !== void 0) {
      clearTimeout(timeout);
    }
    getEntries();
  }
  async function getEntries() {
    if (series === void 0 || series.length === 0) {
      return;
    }
    const units = series.map((s3) => $insights[s3.insightId]).filter((l) => l !== void 0).map((l) => l.units).filter((value, index2, array) => array.indexOf(value) === index2);
    for (var unit of units) {
      const axis = "y" + unit;
      if (!Object.hasOwn(options.scales, axis)) {
        $$invalidate(
          3,
          options.scales[axis] = {
            title: { text: unit, display: true },
            type: "linear",
            display: "auto"
          },
          options
        );
      }
    }
    let timeoutMs = 999999999;
    for (var i2 = 0; i2 < series.length; i2++) {
      const t2 = await getTimeSeries(series[i2], i2);
      if (t2 > 0 && t2 < timeoutMs) {
        timeoutMs = t2;
      }
    }
    if (data.datasets.length > series.length) {
      data.datasets.splice(series.length);
    }
    timeout = setTimeout(
      () => {
        getEntries();
      },
      timeoutMs
    );
    if (chart) {
      chart.update();
    }
  }
  async function getTimeSeries(series2, index2) {
    if (series2.insightId === void 0) {
      return -1;
    }
    const log = $insights[series2.insightId];
    if (log === void 0) {
      return -1;
    }
    const aggregation = series2.aggregation ?? "none";
    const sampleRate = series2.sampleRate ?? 60;
    const entries = await $homey.insights.getLogEntries({ id: log.id, uri: log.uri, resolution });
    const timeSeries = resample(entries, aggregation, sampleRate);
    $$invalidate(
      2,
      data.datasets[index2] = {
        label: getOwnerName(log.ownerUri) + " - " + log.title,
        type: "line",
        borderColor: colors2[index2],
        data: timeSeries,
        tension: 0.5,
        yAxisID: "y" + log.units
      },
      data
    );
    return entries.step - entries.updatesIn;
  }
  function getOwnerName(uri) {
    if (uri.startsWith("homey:device:")) {
      const prefix = "homey:device:";
      const id = uri.slice(prefix.length);
      return $devices[id].name;
    } else if (uri.startsWith("homey:manager:apps")) {
      return "Homey Apps";
    } else if (uri.startsWith("homey:manager:system")) {
      return "Homey System";
    } else if (uri.startsWith("homey:manager:weather")) {
      return "Homey Weather";
    } else if (uri.startsWith("homey:manager:logic")) {
      return "Homey Logic";
    } else {
      return uri;
    }
  }
  function chart_1_chart_binding(value) {
    chart = value;
    $$invalidate(1, chart);
  }
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(4, settings = $$props2.settings);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*settings*/
    16) {
      onSettings(settings);
    }
    if ($$self.$$.dirty & /*$insights*/
    32) {
      onInsights();
    }
  };
  return [series, chart, data, options, settings, $insights, chart_1_chart_binding];
}
class InsightWidget extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$b, create_fragment$d, safe_not_equal, { settings: 4 });
  }
}
function get_each_context$6(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i2];
  return child_ctx;
}
function create_else_block$1(ctx) {
  let t2;
  return {
    c() {
      t2 = text(
        /*placeholder*/
        ctx[1]
      );
    },
    l(nodes) {
      t2 = claim_text(
        nodes,
        /*placeholder*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*placeholder*/
      2)
        set_data(
          t2,
          /*placeholder*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_2$2(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Capability not found");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Capability not found");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_if_block_1$6(ctx) {
  let t0_value = (
    /*getOwnerName*/
    ctx[7](
      /*selected*/
      ctx[5].ownerUri
    ) + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*selected*/
    ctx[5].title + ""
  );
  let t2;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(" - ");
      t2 = text(t2_value);
    },
    l(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_text(nodes, " - ");
      t2 = claim_text(nodes, t2_value);
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*selected*/
      32 && t0_value !== (t0_value = /*getOwnerName*/
      ctx2[7](
        /*selected*/
        ctx2[5].ownerUri
      ) + ""))
        set_data(t0, t0_value);
      if (dirty & /*selected*/
      32 && t2_value !== (t2_value = /*selected*/
      ctx2[5].title + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_default_slot_5$1(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*selected*/
      ctx2[5] !== void 0
    )
      return create_if_block_1$6;
    if (
      /*logId*/
      ctx2[0] !== void 0
    )
      return create_if_block_2$2;
    return create_else_block$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_if_block$8(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      handleClose: (
        /*func*/
        ctx[13]
      ),
      $$slots: { content: [create_content_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    l(nodes) {
      claim_component(modal.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & /*open*/
      8)
        modal_changes.handleClose = /*func*/
        ctx2[13];
      if (dirty & /*$$scope, filtered, search*/
      1048596) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_default_slot_4$2(ctx) {
  let t0_value = (
    /*item*/
    ctx[17].ownerName + ""
  );
  let t0;
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = space();
    },
    l(nodes) {
      t0 = claim_text(nodes, t0_value);
      t1 = claim_space(nodes);
    },
    m(target, anchor) {
      insert_hydration(target, t0, anchor);
      insert_hydration(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*filtered*/
      16 && t0_value !== (t0_value = /*item*/
      ctx2[17].ownerName + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_title_slot$1(ctx) {
  let list_item_content_title;
  let current;
  list_item_content_title = new List$1.Item.Content.Title({
    props: {
      slot: "title",
      $$slots: { default: [create_default_slot_4$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list_item_content_title.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item_content_title.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item_content_title, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_item_content_title_changes = {};
      if (dirty & /*$$scope, filtered*/
      1048592) {
        list_item_content_title_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list_item_content_title.$set(list_item_content_title_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item_content_title.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item_content_title.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item_content_title, detaching);
    }
  };
}
function create_default_slot_3$4(ctx) {
  let span0;
  let t0_value = (
    /*item*/
    ctx[17].log.title + ""
  );
  let t0;
  let t1;
  let span1;
  let t2_value = (
    /*item*/
    ctx[17].log.lastValue + ""
  );
  let t2;
  let t3;
  let t4_value = (
    /*item*/
    ctx[17].log.units + ""
  );
  let t4;
  let t5;
  return {
    c() {
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
    },
    l(nodes) {
      span0 = claim_element(nodes, "SPAN", {});
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, t0_value);
      span0_nodes.forEach(detach);
      t1 = claim_space(nodes);
      span1 = claim_element(nodes, "SPAN", {});
      var span1_nodes = children(span1);
      t2 = claim_text(span1_nodes, t2_value);
      t3 = claim_space(span1_nodes);
      t4 = claim_text(span1_nodes, t4_value);
      span1_nodes.forEach(detach);
      t5 = claim_space(nodes);
    },
    m(target, anchor) {
      insert_hydration(target, span0, anchor);
      append_hydration(span0, t0);
      insert_hydration(target, t1, anchor);
      insert_hydration(target, span1, anchor);
      append_hydration(span1, t2);
      append_hydration(span1, t3);
      append_hydration(span1, t4);
      insert_hydration(target, t5, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*filtered*/
      16 && t0_value !== (t0_value = /*item*/
      ctx2[17].log.title + ""))
        set_data(t0, t0_value);
      if (dirty & /*filtered*/
      16 && t2_value !== (t2_value = /*item*/
      ctx2[17].log.lastValue + ""))
        set_data(t2, t2_value);
      if (dirty & /*filtered*/
      16 && t4_value !== (t4_value = /*item*/
      ctx2[17].log.units + ""))
        set_data(t4, t4_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span0);
        detach(t1);
        detach(span1);
        detach(t5);
      }
    }
  };
}
function create_description_slot(ctx) {
  let list_item_content_description;
  let current;
  list_item_content_description = new List$1.Item.Content.Description({
    props: {
      slot: "description",
      class: "w-full flex justify-between",
      $$slots: { default: [create_default_slot_3$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list_item_content_description.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item_content_description.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item_content_description, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_item_content_description_changes = {};
      if (dirty & /*$$scope, filtered*/
      1048592) {
        list_item_content_description_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list_item_content_description.$set(list_item_content_description_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item_content_description.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item_content_description.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item_content_description, detaching);
    }
  };
}
function create_content_slot_1(ctx) {
  let list_item_content;
  let current;
  list_item_content = new List$1.Item.Content({
    props: {
      slot: "content",
      $$slots: {
        description: [create_description_slot],
        title: [create_title_slot$1]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list_item_content.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item_content.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item_content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_item_content_changes = {};
      if (dirty & /*$$scope, filtered*/
      1048592) {
        list_item_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list_item_content.$set(list_item_content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item_content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item_content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item_content, detaching);
    }
  };
}
function create_each_block$6(ctx) {
  let list_item;
  let current;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[12](
        /*item*/
        ctx[17]
      )
    );
  }
  list_item = new List$1.Item({
    props: {
      class: "cursor-pointer",
      $$slots: { content: [create_content_slot_1] },
      $$scope: { ctx }
    }
  });
  list_item.$on("click", click_handler_1);
  return {
    c() {
      create_component(list_item.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const list_item_changes = {};
      if (dirty & /*$$scope, filtered*/
      1048592) {
        list_item_changes.$$scope = { dirty, ctx };
      }
      list_item.$set(list_item_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item, detaching);
    }
  };
}
function create_default_slot_2$5(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*filtered*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$6(get_each_context$6(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*onLog, filtered*/
      80) {
        each_value = ensure_array_like(
          /*filtered*/
          ctx2[4]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$6(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$6(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_1$6(ctx) {
  let div0;
  let input;
  let updating_value;
  let t2;
  let div1;
  let list;
  let current;
  function input_value_binding(value) {
    ctx[11](value);
  }
  let input_props = { name: "search", placeholder: "Search" };
  if (
    /*search*/
    ctx[2] !== void 0
  ) {
    input_props.value = /*search*/
    ctx[2];
  }
  input = new Input({ props: input_props });
  binding_callbacks.push(() => bind(input, "value", input_value_binding));
  list = new List$1({
    props: {
      $$slots: { default: [create_default_slot_2$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div0 = element("div");
      create_component(input.$$.fragment);
      t2 = space();
      div1 = element("div");
      create_component(list.$$.fragment);
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", {});
      var div0_nodes = children(div0);
      claim_component(input.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t2 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(list.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div1, "class", "flex-grow overflow-auto");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      mount_component(input, div0, null);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, div1, anchor);
      mount_component(list, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const input_changes = {};
      if (!updating_value && dirty & /*search*/
      4) {
        updating_value = true;
        input_changes.value = /*search*/
        ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      input.$set(input_changes);
      const list_changes = {};
      if (dirty & /*$$scope, filtered*/
      1048592) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(input.$$.fragment, local);
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(input.$$.fragment, local);
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t2);
        detach(div1);
      }
      destroy_component(input);
      destroy_component(list);
    }
  };
}
function create_body_slot$2(ctx) {
  let modal_content_body;
  let current;
  modal_content_body = new Modal.Content.Body({
    props: {
      slot: "body",
      class: "h-full",
      $$slots: { default: [create_default_slot_1$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal_content_body.$$.fragment);
    },
    l(nodes) {
      claim_component(modal_content_body.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal_content_body, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_content_body_changes = {};
      if (dirty & /*$$scope, filtered, search*/
      1048596) {
        modal_content_body_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal_content_body.$set(modal_content_body_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal_content_body.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal_content_body.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal_content_body, detaching);
    }
  };
}
function create_content_slot$3(ctx) {
  let modal_content;
  let current;
  modal_content = new Modal.Content({
    props: {
      slot: "content",
      $$slots: { body: [create_body_slot$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal_content.$$.fragment);
    },
    l(nodes) {
      claim_component(modal_content.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal_content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_content_changes = {};
      if (dirty & /*$$scope, filtered, search*/
      1048596) {
        modal_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal_content.$set(modal_content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal_content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal_content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal_content, detaching);
    }
  };
}
function create_default_slot$8(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*open*/
    ctx[3] && create_if_block$8(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*open*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$c(ctx) {
  let button;
  let t2;
  let portal;
  let current;
  button = new Button$1({
    props: {
      class: "w-full justify-start",
      $$slots: { default: [create_default_slot_5$1] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler*/
    ctx[10]
  );
  portal = new Portal({
    props: {
      $$slots: { default: [create_default_slot$8] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(button.$$.fragment);
      t2 = space();
      create_component(portal.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(portal.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      insert_hydration(target, t2, anchor);
      mount_component(portal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const button_changes = {};
      if (dirty & /*$$scope, selected, logId, placeholder*/
      1048611) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      const portal_changes = {};
      if (dirty & /*$$scope, open, filtered, search*/
      1048604) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal.$set(portal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      transition_in(portal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      transition_out(portal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(button, detaching);
      destroy_component(portal, detaching);
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let sorted;
  let $devices;
  component_subscribe($$self, devices, ($$value) => $$invalidate(14, $devices = $$value));
  let { logId } = $$props;
  let { logs = [] } = $$props;
  let { placeholder = "Select log" } = $$props;
  const dispatch = createEventDispatcher();
  let open = false;
  let search = "";
  let filtered = [];
  let selected;
  function filterCapabilities(value, s3) {
    const normalized = value.toLowerCase();
    if (value.length > 0) {
      $$invalidate(4, filtered = sorted.filter((d3) => d3.searchString.includes(normalized)));
    } else {
      $$invalidate(4, filtered = sorted);
    }
  }
  function onLog(log) {
    $$invalidate(0, logId = log.id);
    $$invalidate(3, open = false);
    dispatch("logId", logId);
  }
  function getOwnerName(uri) {
    if (uri.startsWith("homey:device:")) {
      const prefix = "homey:device:";
      const id = uri.slice(prefix.length);
      return $devices[id].name;
    } else if (uri.startsWith("homey:manager:apps")) {
      return "Homey Apps";
    } else if (uri.startsWith("homey:manager:system")) {
      return "Homey System";
    } else if (uri.startsWith("homey:manager:weather")) {
      return "Homey Weather";
    } else if (uri.startsWith("homey:manager:logic")) {
      return "Homey Logic";
    } else {
      return uri;
    }
  }
  const click_handler = () => $$invalidate(3, open = true);
  function input_value_binding(value) {
    search = value;
    $$invalidate(2, search);
  }
  const click_handler_1 = (item) => onLog(item.log);
  const func = () => $$invalidate(3, open = false);
  $$self.$$set = ($$props2) => {
    if ("logId" in $$props2)
      $$invalidate(0, logId = $$props2.logId);
    if ("logs" in $$props2)
      $$invalidate(8, logs = $$props2.logs);
    if ("placeholder" in $$props2)
      $$invalidate(1, placeholder = $$props2.placeholder);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*logs*/
    256) {
      $$invalidate(9, sorted = (logs ?? []).map((log) => {
        const ownerName = getOwnerName(log.ownerUri);
        return {
          log,
          ownerName,
          searchString: `${ownerName} ${log.title}`.toLowerCase()
        };
      }).sort((a3, b2) => {
        if (a3.searchString === b2.searchString)
          return 0;
        if (a3.searchString < b2.searchString)
          return -1;
        return 1;
      }));
    }
    if ($$self.$$.dirty & /*logId, logs*/
    257) {
      $$invalidate(5, selected = logId !== void 0 ? logs.find((d3) => d3.id === logId) : void 0);
    }
    if ($$self.$$.dirty & /*search, sorted*/
    516) {
      filterCapabilities(search);
    }
  };
  return [
    logId,
    placeholder,
    search,
    open,
    filtered,
    selected,
    onLog,
    getOwnerName,
    logs,
    sorted,
    click_handler,
    input_value_binding,
    click_handler_1,
    func
  ];
}
class InsightPicker extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$a, create_fragment$c, safe_not_equal, { logId: 0, logs: 8, placeholder: 1 });
  }
}
function get_each_context$5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  return child_ctx;
}
function get_each_context_1$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[13] = list[i2];
  return child_ctx;
}
function create_each_block_1$1(ctx) {
  let select_options_option;
  let current;
  select_options_option = new Select2.Options.Option({ props: { option: (
    /*option*/
    ctx[13]
  ) } });
  return {
    c() {
      create_component(select_options_option.$$.fragment);
    },
    l(nodes) {
      claim_component(select_options_option.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select_options_option, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(select_options_option.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_options_option.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_options_option, detaching);
    }
  };
}
function create_default_slot_1$5(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*aggregations*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*aggregations*/
      8) {
        each_value_1 = ensure_array_like(
          /*aggregations*/
          ctx2[3]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_options_slot_1(ctx) {
  let select_options_1;
  let current;
  select_options_1 = new Select2.Options({
    props: {
      slot: "options",
      class: "max-h-96 overflow-auto",
      $$slots: { default: [create_default_slot_1$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select_options_1.$$.fragment);
    },
    l(nodes) {
      claim_component(select_options_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select_options_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_options_1_changes = {};
      if (dirty & /*$$scope*/
      262144) {
        select_options_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select_options_1.$set(select_options_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select_options_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_options_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_options_1, detaching);
    }
  };
}
function create_if_block$7(ctx) {
  let select;
  let updating_value;
  let current;
  function select_value_binding_1(value) {
    ctx[7](value);
  }
  let select_props = {
    placeholder: "Sample rate",
    name: "sampleRate",
    $$slots: { options: [create_options_slot$2] },
    $$scope: { ctx }
  };
  if (
    /*sampleRate*/
    ctx[2] !== void 0
  ) {
    select_props.value = /*sampleRate*/
    ctx[2];
  }
  select = new Select2({ props: select_props });
  binding_callbacks.push(() => bind(select, "value", select_value_binding_1));
  return {
    c() {
      create_component(select.$$.fragment);
    },
    l(nodes) {
      claim_component(select.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_changes = {};
      if (dirty & /*$$scope*/
      262144) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty & /*sampleRate*/
      4) {
        updating_value = true;
        select_changes.value = /*sampleRate*/
        ctx2[2];
        add_flush_callback(() => updating_value = false);
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select, detaching);
    }
  };
}
function create_each_block$5(ctx) {
  let select_options_option;
  let current;
  select_options_option = new Select2.Options.Option({ props: { option: (
    /*option*/
    ctx[13]
  ) } });
  return {
    c() {
      create_component(select_options_option.$$.fragment);
    },
    l(nodes) {
      claim_component(select_options_option.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select_options_option, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(select_options_option.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_options_option.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_options_option, detaching);
    }
  };
}
function create_default_slot$7(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*sampleRates*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$5(get_each_context$5(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*sampleRates*/
      16) {
        each_value = ensure_array_like(
          /*sampleRates*/
          ctx2[4]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$5(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$5(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_options_slot$2(ctx) {
  let select_options_1;
  let current;
  select_options_1 = new Select2.Options({
    props: {
      slot: "options",
      class: "max-h-96 overflow-auto",
      $$slots: { default: [create_default_slot$7] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select_options_1.$$.fragment);
    },
    l(nodes) {
      claim_component(select_options_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select_options_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_options_1_changes = {};
      if (dirty & /*$$scope*/
      262144) {
        select_options_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select_options_1.$set(select_options_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select_options_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_options_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_options_1, detaching);
    }
  };
}
function create_fragment$b(ctx) {
  let div2;
  let select;
  let updating_value;
  let t2;
  let current;
  function select_value_binding(value) {
    ctx[6](value);
  }
  let select_props = {
    placeholder: "Aggregation",
    name: "aggregation",
    $$slots: { options: [create_options_slot_1] },
    $$scope: { ctx }
  };
  if (
    /*aggregation*/
    ctx[1] !== void 0
  ) {
    select_props.value = /*aggregation*/
    ctx[1];
  }
  select = new Select2({ props: select_props });
  binding_callbacks.push(() => bind(select, "value", select_value_binding));
  let if_block = (
    /*series*/
    ctx[0].aggregation !== void 0 && /*series*/
    ctx[0].aggregation !== "none" && create_if_block$7(ctx)
  );
  return {
    c() {
      div2 = element("div");
      create_component(select.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div_nodes = children(div2);
      claim_component(select.$$.fragment, div_nodes);
      t2 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(select, div2, null);
      append_hydration(div2, t2);
      if (if_block)
        if_block.m(div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const select_changes = {};
      if (dirty & /*$$scope*/
      262144) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty & /*aggregation*/
      2) {
        updating_value = true;
        select_changes.value = /*aggregation*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      select.$set(select_changes);
      if (
        /*series*/
        ctx2[0].aggregation !== void 0 && /*series*/
        ctx2[0].aggregation !== "none"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*series*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(select.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(select);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let { series } = $$props;
  const dispatch = createEventDispatcher();
  const aggregations = [
    { value: "none", label: "No aggregation" },
    { value: "min", label: "Min" },
    { value: "max", label: "Max" },
    { value: "sum", label: "Sum" },
    { value: "avg", label: "Avg" },
    { value: "first", label: "First" },
    { value: "last", label: "Last" }
  ];
  const sampleRates = [
    { value: "10", label: "10 seconds" },
    { value: "20", label: "20 seconds" },
    { value: "30", label: "30 seconds" },
    { value: "60", label: "1 min" },
    { value: "300", label: "5 min" },
    { value: "600", label: "10 min" },
    { value: "900", label: "15 min" },
    { value: "1200", label: "20 min" },
    { value: "1800", label: "30 min" },
    { value: "3600", label: "1 hour" },
    { value: "7200", label: "2 hours" },
    { value: "10800", label: "3 hours" },
    { value: "21600", label: "6 hours" },
    { value: "43200", label: "12 hours" },
    { value: "86400", label: "24 hours" }
  ];
  let insightId;
  let aggregation;
  let sampleRate;
  function onSeries(s3) {
    $$invalidate(5, insightId = series == null ? void 0 : series.insightId);
    $$invalidate(1, aggregation = aggregations.find((a3) => a3.value === ((series == null ? void 0 : series.aggregation) ?? "none")));
    $$invalidate(2, sampleRate = sampleRates.find((s22) => s22.value === "" + ((series == null ? void 0 : series.sampleRate) ?? 60)));
  }
  function onInsight(value) {
    if (value == void 0 || value === series.insightId) {
      return;
    }
    dispatch("series", { ...series, insightId });
  }
  function onAggregation(option) {
    if (option == void 0 || option.value === series.aggregation) {
      return;
    }
    dispatch("series", { ...series, aggregation: option.value });
  }
  function onSampleRate(option) {
    if (option == void 0 || Number(option.value) === series.sampleRate) {
      return;
    }
    dispatch("series", {
      ...series,
      sampleRate: Number(option.value)
    });
  }
  function select_value_binding(value) {
    aggregation = value;
    $$invalidate(1, aggregation);
  }
  function select_value_binding_1(value) {
    sampleRate = value;
    $$invalidate(2, sampleRate);
  }
  $$self.$$set = ($$props2) => {
    if ("series" in $$props2)
      $$invalidate(0, series = $$props2.series);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*series*/
    1) {
      onSeries();
    }
    if ($$self.$$.dirty & /*insightId*/
    32) {
      onInsight(insightId);
    }
    if ($$self.$$.dirty & /*aggregation*/
    2) {
      onAggregation(aggregation);
    }
    if ($$self.$$.dirty & /*sampleRate*/
    4) {
      onSampleRate(sampleRate);
    }
  };
  return [
    series,
    aggregation,
    sampleRate,
    aggregations,
    sampleRates,
    insightId,
    select_value_binding,
    select_value_binding_1
  ];
}
class InsightEditorSeries extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$9, create_fragment$b, safe_not_equal, { series: 0 });
  }
}
function get_each_context$4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i2];
  child_ctx[24] = i2;
  return child_ctx;
}
function get_each_context_1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i2];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let select_options_option;
  let current;
  select_options_option = new Select2.Options.Option({ props: { option: (
    /*option*/
    ctx[25]
  ) } });
  return {
    c() {
      create_component(select_options_option.$$.fragment);
    },
    l(nodes) {
      claim_component(select_options_option.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select_options_option, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(select_options_option.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_options_option.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_options_option, detaching);
    }
  };
}
function create_default_slot_3$3(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*resolutions*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1(get_each_context_1(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*resolutions*/
      32) {
        each_value_1 = ensure_array_like(
          /*resolutions*/
          ctx2[5]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_options_slot$1(ctx) {
  let select_options_1;
  let current;
  select_options_1 = new Select2.Options({
    props: {
      slot: "options",
      class: "max-h-96 overflow-auto",
      $$slots: { default: [create_default_slot_3$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select_options_1.$$.fragment);
    },
    l(nodes) {
      claim_component(select_options_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select_options_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_options_1_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        select_options_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select_options_1.$set(select_options_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select_options_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_options_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_options_1, detaching);
    }
  };
}
function create_icon_slot$1(ctx) {
  let button_icon;
  let current;
  button_icon = new Button$1.Icon({ props: { slot: "icon", data: mdiDelete } });
  return {
    c() {
      create_component(button_icon.$$.fragment);
    },
    l(nodes) {
      claim_component(button_icon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button_icon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(button_icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button_icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button_icon, detaching);
    }
  };
}
function create_default_slot_2$4(ctx) {
  let div2;
  let button;
  let t0;
  let span;
  let t1_value = (
    /*getLogName*/
    ctx[8](
      /*s*/
      ctx[22].insightId
    ) + ""
  );
  let t1;
  let t2;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[15](
        /*i*/
        ctx[24]
      )
    );
  }
  button = new Button$1({
    props: {
      class: "mr-4",
      $$slots: { icon: [create_icon_slot$1] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler);
  return {
    c() {
      div2 = element("div");
      create_component(button.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div_nodes = children(div2);
      claim_component(button.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      span = claim_element(div_nodes, "SPAN", {});
      var span_nodes = children(span);
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach);
      div_nodes.forEach(detach);
      t2 = claim_space(nodes);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(button, div2, null);
      append_hydration(div2, t0);
      append_hydration(div2, span);
      append_hydration(span, t1);
      insert_hydration(target, t2, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
      if ((!current || dirty & /*series*/
      4) && t1_value !== (t1_value = /*getLogName*/
      ctx[8](
        /*s*/
        ctx[22].insightId
      ) + ""))
        set_data(t1, t1_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t2);
      }
      destroy_component(button);
    }
  };
}
function create_title_slot(ctx) {
  let accordion_item_title;
  let current;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[16](
        /*s*/
        ctx[22]
      )
    );
  }
  accordion_item_title = new Accordion2.Item.Title({
    props: {
      slot: "title",
      $$slots: { default: [create_default_slot_2$4] },
      $$scope: { ctx }
    }
  });
  accordion_item_title.$on("click", click_handler_1);
  return {
    c() {
      create_component(accordion_item_title.$$.fragment);
    },
    l(nodes) {
      claim_component(accordion_item_title.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(accordion_item_title, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const accordion_item_title_changes = {};
      if (dirty & /*$$scope, series*/
      268435460) {
        accordion_item_title_changes.$$scope = { dirty, ctx };
      }
      accordion_item_title.$set(accordion_item_title_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordion_item_title.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordion_item_title.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accordion_item_title, detaching);
    }
  };
}
function create_default_slot_1$4(ctx) {
  let insighteditorseries;
  let t2;
  let current;
  function series_handler(...args) {
    return (
      /*series_handler*/
      ctx[14](
        /*i*/
        ctx[24],
        ...args
      )
    );
  }
  insighteditorseries = new InsightEditorSeries({ props: { series: (
    /*s*/
    ctx[22]
  ) } });
  insighteditorseries.$on("series", series_handler);
  return {
    c() {
      create_component(insighteditorseries.$$.fragment);
      t2 = space();
    },
    l(nodes) {
      claim_component(insighteditorseries.$$.fragment, nodes);
      t2 = claim_space(nodes);
    },
    m(target, anchor) {
      mount_component(insighteditorseries, target, anchor);
      insert_hydration(target, t2, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const insighteditorseries_changes = {};
      if (dirty & /*series*/
      4)
        insighteditorseries_changes.series = /*s*/
        ctx[22];
      insighteditorseries.$set(insighteditorseries_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(insighteditorseries.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(insighteditorseries.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(insighteditorseries, detaching);
    }
  };
}
function create_content_slot$2(ctx) {
  let accordion_item_content;
  let current;
  accordion_item_content = new Accordion2.Item.Content({
    props: {
      slot: "content",
      class: "p-4",
      $$slots: { default: [create_default_slot_1$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(accordion_item_content.$$.fragment);
    },
    l(nodes) {
      claim_component(accordion_item_content.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(accordion_item_content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const accordion_item_content_changes = {};
      if (dirty & /*$$scope, series*/
      268435460) {
        accordion_item_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion_item_content.$set(accordion_item_content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordion_item_content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordion_item_content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accordion_item_content, detaching);
    }
  };
}
function create_each_block$4(ctx) {
  let accordion_item;
  let current;
  accordion_item = new Accordion2.Item({
    props: {
      open: (
        /*openInsightId*/
        ctx[1] === /*s*/
        ctx[22].insightId
      ),
      class: "overflow-visible",
      $$slots: {
        content: [create_content_slot$2],
        title: [create_title_slot]
      },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(accordion_item.$$.fragment);
    },
    l(nodes) {
      claim_component(accordion_item.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(accordion_item, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const accordion_item_changes = {};
      if (dirty & /*openInsightId, series*/
      6)
        accordion_item_changes.open = /*openInsightId*/
        ctx2[1] === /*s*/
        ctx2[22].insightId;
      if (dirty & /*$$scope, series, openInsightId*/
      268435462) {
        accordion_item_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion_item.$set(accordion_item_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(accordion_item.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(accordion_item.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(accordion_item, detaching);
    }
  };
}
function create_default_slot$6(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*series*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$4(get_each_context$4(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*openInsightId, series, onSeries, getLogName, removeInsight, mdiDelete*/
      902) {
        each_value = ensure_array_like(
          /*series*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$4(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$4(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment$a(ctx) {
  let insightpicker;
  let updating_logId;
  let t0;
  let select;
  let updating_value;
  let t1;
  let accordion;
  let current;
  function insightpicker_logId_binding(value) {
    ctx[11](value);
  }
  let insightpicker_props = {
    logs: Object.values(
      /*$insights*/
      ctx[4]
    ),
    placeholder: "Add insight"
  };
  if (
    /*selectedLogId*/
    ctx[3] !== void 0
  ) {
    insightpicker_props.logId = /*selectedLogId*/
    ctx[3];
  }
  insightpicker = new InsightPicker({ props: insightpicker_props });
  binding_callbacks.push(() => bind(insightpicker, "logId", insightpicker_logId_binding));
  insightpicker.$on(
    "logId",
    /*logId_handler*/
    ctx[12]
  );
  function select_value_binding(value) {
    ctx[13](value);
  }
  let select_props = {
    placeholder: "Resolution",
    name: "resolution",
    class: "mt-4",
    $$slots: { options: [create_options_slot$1] },
    $$scope: { ctx }
  };
  if (
    /*resolution*/
    ctx[0] !== void 0
  ) {
    select_props.value = /*resolution*/
    ctx[0];
  }
  select = new Select2({ props: select_props });
  binding_callbacks.push(() => bind(select, "value", select_value_binding));
  accordion = new Accordion2({
    props: {
      class: "mt-4",
      $$slots: { default: [create_default_slot$6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(insightpicker.$$.fragment);
      t0 = space();
      create_component(select.$$.fragment);
      t1 = space();
      create_component(accordion.$$.fragment);
    },
    l(nodes) {
      claim_component(insightpicker.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(select.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(accordion.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(insightpicker, target, anchor);
      insert_hydration(target, t0, anchor);
      mount_component(select, target, anchor);
      insert_hydration(target, t1, anchor);
      mount_component(accordion, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const insightpicker_changes = {};
      if (dirty & /*$insights*/
      16)
        insightpicker_changes.logs = Object.values(
          /*$insights*/
          ctx2[4]
        );
      if (!updating_logId && dirty & /*selectedLogId*/
      8) {
        updating_logId = true;
        insightpicker_changes.logId = /*selectedLogId*/
        ctx2[3];
        add_flush_callback(() => updating_logId = false);
      }
      insightpicker.$set(insightpicker_changes);
      const select_changes = {};
      if (dirty & /*$$scope*/
      268435456) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value && dirty & /*resolution*/
      1) {
        updating_value = true;
        select_changes.value = /*resolution*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      select.$set(select_changes);
      const accordion_changes = {};
      if (dirty & /*$$scope, series, openInsightId*/
      268435462) {
        accordion_changes.$$scope = { dirty, ctx: ctx2 };
      }
      accordion.$set(accordion_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(insightpicker.$$.fragment, local);
      transition_in(select.$$.fragment, local);
      transition_in(accordion.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(insightpicker.$$.fragment, local);
      transition_out(select.$$.fragment, local);
      transition_out(accordion.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(insightpicker, detaching);
      destroy_component(select, detaching);
      destroy_component(accordion, detaching);
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let $devices;
  let $insights;
  component_subscribe($$self, devices, ($$value) => $$invalidate(17, $devices = $$value));
  component_subscribe($$self, insights, ($$value) => $$invalidate(4, $insights = $$value));
  const dispatch = createEventDispatcher();
  const resolutions = [
    { value: "lastHour", label: "Last hour" },
    {
      value: "last6Hours",
      label: "Last 6 hours"
    },
    {
      value: "last24Hours",
      label: "Last 24 hours"
    },
    { value: "last7Days", label: "Last 7 days" },
    {
      value: "last14Days",
      label: "Last 14 days"
    },
    {
      value: "last31Days",
      label: "Last 31 days"
    },
    { value: "today", label: "Today" },
    { value: "thisWeek", label: "This week" },
    { value: "thisMonth", label: "This month" },
    { value: "thisYear", label: "This year" },
    { value: "yesterday", label: "Yesterday" },
    { value: "lastWeek", label: "Last week" },
    { value: "lastMonth", label: "Last month" },
    { value: "lastYear", label: "Last year" },
    {
      value: "last2Years",
      label: "Last 2 years"
    }
  ];
  let { settings } = $$props;
  let openInsightId;
  let resolution;
  let series = [];
  let selectedLogId;
  function onSettings(s3) {
    $$invalidate(0, resolution = resolutions.find((r) => r.value === (settings.resolution ?? "today")));
    $$invalidate(2, series = [...(settings == null ? void 0 : settings.series) ?? []]);
  }
  function onResolution(option) {
    if (option.value === settings.resolution) {
      return;
    }
    dispatch("settings", { ...settings, resolution: option.value });
  }
  function onLog(logId) {
    const updatedSeries = [...series, { insightId: logId }];
    $$invalidate(3, selectedLogId = void 0);
    dispatch("settings", { ...settings, series: updatedSeries });
  }
  function onSeries(index2, s3) {
    const updatedSeries = [...series];
    updatedSeries[index2] = s3;
    dispatch("settings", { ...settings, series: updatedSeries });
  }
  function getLogName(logId) {
    if (logId !== void 0) {
      const log = $insights[logId];
      return getOwnerName(log.ownerUri) + " - " + log.title;
    }
    return "Unknown";
  }
  function getOwnerName(uri) {
    if (uri.startsWith("homey:device:")) {
      const prefix = "homey:device:";
      const id = uri.slice(prefix.length);
      return $devices[id].name;
    } else if (uri.startsWith("homey:manager:apps")) {
      return "Homey Apps";
    } else if (uri.startsWith("homey:manager:system")) {
      return "Homey System";
    } else if (uri.startsWith("homey:manager:weather")) {
      return "Homey Weather";
    } else if (uri.startsWith("homey:manager:logic")) {
      return "Homey Logic";
    } else {
      return uri;
    }
  }
  function removeInsight(index2) {
    const updatedSeries = [...series.filter((s3, i2) => i2 !== index2)];
    dispatch("settings", { ...settings, series: updatedSeries });
  }
  function insightpicker_logId_binding(value) {
    selectedLogId = value;
    $$invalidate(3, selectedLogId);
  }
  const logId_handler = (e2) => onLog(e2.detail);
  function select_value_binding(value) {
    resolution = value;
    $$invalidate(0, resolution);
  }
  const series_handler = (i2, e2) => onSeries(i2, e2.detail);
  const click_handler = (i2) => removeInsight(i2);
  const click_handler_1 = (s3) => $$invalidate(1, openInsightId = s3.insightId);
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(10, settings = $$props2.settings);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*settings*/
    1024) {
      onSettings();
    }
    if ($$self.$$.dirty & /*resolution*/
    1) {
      onResolution(resolution);
    }
  };
  return [
    resolution,
    openInsightId,
    series,
    selectedLogId,
    $insights,
    resolutions,
    onLog,
    onSeries,
    getLogName,
    removeInsight,
    settings,
    insightpicker_logId_binding,
    logId_handler,
    select_value_binding,
    series_handler,
    click_handler,
    click_handler_1
  ];
}
class InsightEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$8, create_fragment$a, safe_not_equal, { settings: 10 });
  }
}
function create() {
  return {
    id: v4(),
    type: "insight",
    version: 3
  };
}
function migrate(settings) {
  switch (settings.version) {
    case 3:
      return settings;
    case 2:
      return migrate_v2_v3(settings);
    case 1:
    default:
      return migrate(migrate_v1_v2(settings));
  }
}
function migrate_v2_v3(v2) {
  const settings = {
    id: v2.id,
    type: v2.type,
    version: 3,
    resolution: v2.resolution,
    series: [{ insightId: v2.insightId, aggregation: v2.aggregation, sampleRate: v2.sampleRate }]
  };
  return settings;
}
function migrate_v1_v2(v1) {
  var _a2;
  const settings = {
    id: v1.id,
    type: v1.type,
    version: 2,
    insightId: ((_a2 = v1.insightId) == null ? void 0 : _a2.startsWith("homey:")) ? v1.insightId : "homey:device:" + v1.deviceId + ":" + v1.insightId,
    resolution: v1.resolution,
    aggregation: "none",
    sampleRate: void 0
  };
  return settings;
}
function get_each_context$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  return child_ctx;
}
function create_each_block$3(ctx) {
  let select_options_option;
  let current;
  select_options_option = new Select2.Options.Option({ props: { option: (
    /*option*/
    ctx[9]
  ) } });
  return {
    c() {
      create_component(select_options_option.$$.fragment);
    },
    l(nodes) {
      claim_component(select_options_option.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select_options_option, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(select_options_option.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_options_option.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_options_option, detaching);
    }
  };
}
function create_default_slot$5(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*sizes*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$3(get_each_context$3(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*sizes*/
      4) {
        each_value = ensure_array_like(
          /*sizes*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$3(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$3(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_options_slot(ctx) {
  let select_options_1;
  let current;
  select_options_1 = new Select2.Options({
    props: {
      slot: "options",
      $$slots: { default: [create_default_slot$5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(select_options_1.$$.fragment);
    },
    l(nodes) {
      claim_component(select_options_1.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(select_options_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const select_options_1_changes = {};
      if (dirty & /*$$scope*/
      4096) {
        select_options_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      select_options_1.$set(select_options_1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(select_options_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select_options_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(select_options_1, detaching);
    }
  };
}
function create_fragment$9(ctx) {
  let div2;
  let textarea;
  let updating_value;
  let t2;
  let select;
  let updating_value_1;
  let current;
  function textarea_value_binding(value) {
    ctx[4](value);
  }
  let textarea_props = {
    name: "text",
    placeholder: "Text",
    class: "w-full"
  };
  if (
    /*text*/
    ctx[0] !== void 0
  ) {
    textarea_props.value = /*text*/
    ctx[0];
  }
  textarea = new TextArea2({ props: textarea_props });
  binding_callbacks.push(() => bind(textarea, "value", textarea_value_binding));
  function select_value_binding(value) {
    ctx[5](value);
  }
  let select_props = {
    placeholder: "Font size",
    name: "size",
    $$slots: { options: [create_options_slot] },
    $$scope: { ctx }
  };
  if (
    /*size*/
    ctx[1] !== void 0
  ) {
    select_props.value = /*size*/
    ctx[1];
  }
  select = new Select2({ props: select_props });
  binding_callbacks.push(() => bind(select, "value", select_value_binding));
  return {
    c() {
      div2 = element("div");
      create_component(textarea.$$.fragment);
      t2 = space();
      create_component(select.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { style: true });
      var div_nodes = children(div2);
      claim_component(textarea.$$.fragment, div_nodes);
      t2 = claim_space(div_nodes);
      claim_component(select.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      set_style(div2, "margin-top", "20px");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(textarea, div2, null);
      append_hydration(div2, t2);
      mount_component(select, div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const textarea_changes = {};
      if (!updating_value && dirty & /*text*/
      1) {
        updating_value = true;
        textarea_changes.value = /*text*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      textarea.$set(textarea_changes);
      const select_changes = {};
      if (dirty & /*$$scope*/
      4096) {
        select_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_value_1 && dirty & /*size*/
      2) {
        updating_value_1 = true;
        select_changes.value = /*size*/
        ctx2[1];
        add_flush_callback(() => updating_value_1 = false);
      }
      select.$set(select_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(textarea.$$.fragment, local);
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(textarea.$$.fragment, local);
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(textarea);
      destroy_component(select);
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let { settings } = $$props;
  const dispatch = createEventDispatcher();
  let text2 = "";
  let size;
  const sizes = [
    { value: "", label: "Text" },
    ...[...Array(6).keys()].map((key) => ({
      value: "" + (key + 1),
      label: "" + (key + 1)
    }))
  ];
  onMount(() => {
    $$invalidate(0, text2 = (settings == null ? void 0 : settings.text) ?? "");
    $$invalidate(1, size = sizes.find((s3) => s3.value === ""));
  });
  function onText(value) {
    if (value === void 0 || value === settings.text) {
      return;
    }
    dispatch("settings", { ...settings, text: value });
  }
  function onSize(option) {
    if (option === void 0 || Number(option.value) === settings.size) {
      return;
    }
    dispatch("settings", { ...settings, size: Number(option.value) });
  }
  function textarea_value_binding(value) {
    text2 = value;
    $$invalidate(0, text2);
  }
  function select_value_binding(value) {
    size = value;
    $$invalidate(1, size);
  }
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(3, settings = $$props2.settings);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*text*/
    1) {
      onText(text2);
    }
    if ($$self.$$.dirty & /*size*/
    2) {
      onSize(size);
    }
  };
  return [text2, size, sizes, settings, textarea_value_binding, select_value_binding];
}
class TextEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$7, create_fragment$9, safe_not_equal, { settings: 3 });
  }
}
const TextWidget_svelte_svelte_type_style_lang = "";
function create_else_block(ctx) {
  let div2;
  let t2;
  return {
    c() {
      div2 = element("div");
      t2 = text(
        /*text*/
        ctx[1]
      );
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", {});
      var div_nodes = children(div2);
      t2 = claim_text(
        div_nodes,
        /*text*/
        ctx[1]
      );
      div_nodes.forEach(detach);
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      append_hydration(div2, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*text*/
      2)
        set_data(
          t2,
          /*text*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_if_block_5(ctx) {
  let h6;
  let t2;
  return {
    c() {
      h6 = element("h6");
      t2 = text(
        /*text*/
        ctx[1]
      );
      this.h();
    },
    l(nodes) {
      h6 = claim_element(nodes, "H6", { class: true });
      var h6_nodes = children(h6);
      t2 = claim_text(
        h6_nodes,
        /*text*/
        ctx[1]
      );
      h6_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(h6, "class", "no-margin svelte-1gow1pa");
    },
    m(target, anchor) {
      insert_hydration(target, h6, anchor);
      append_hydration(h6, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*text*/
      2)
        set_data(
          t2,
          /*text*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(h6);
      }
    }
  };
}
function create_if_block_4(ctx) {
  let h5;
  let t2;
  return {
    c() {
      h5 = element("h5");
      t2 = text(
        /*text*/
        ctx[1]
      );
      this.h();
    },
    l(nodes) {
      h5 = claim_element(nodes, "H5", { class: true });
      var h5_nodes = children(h5);
      t2 = claim_text(
        h5_nodes,
        /*text*/
        ctx[1]
      );
      h5_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(h5, "class", "no-margin svelte-1gow1pa");
    },
    m(target, anchor) {
      insert_hydration(target, h5, anchor);
      append_hydration(h5, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*text*/
      2)
        set_data(
          t2,
          /*text*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(h5);
      }
    }
  };
}
function create_if_block_3$1(ctx) {
  let h4;
  let t2;
  return {
    c() {
      h4 = element("h4");
      t2 = text(
        /*text*/
        ctx[1]
      );
      this.h();
    },
    l(nodes) {
      h4 = claim_element(nodes, "H4", { class: true });
      var h4_nodes = children(h4);
      t2 = claim_text(
        h4_nodes,
        /*text*/
        ctx[1]
      );
      h4_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(h4, "class", "no-margin svelte-1gow1pa");
    },
    m(target, anchor) {
      insert_hydration(target, h4, anchor);
      append_hydration(h4, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*text*/
      2)
        set_data(
          t2,
          /*text*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(h4);
      }
    }
  };
}
function create_if_block_2$1(ctx) {
  let h32;
  let t2;
  return {
    c() {
      h32 = element("h3");
      t2 = text(
        /*text*/
        ctx[1]
      );
      this.h();
    },
    l(nodes) {
      h32 = claim_element(nodes, "H3", { class: true });
      var h3_nodes = children(h32);
      t2 = claim_text(
        h3_nodes,
        /*text*/
        ctx[1]
      );
      h3_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(h32, "class", "no-margin svelte-1gow1pa");
    },
    m(target, anchor) {
      insert_hydration(target, h32, anchor);
      append_hydration(h32, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*text*/
      2)
        set_data(
          t2,
          /*text*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(h32);
      }
    }
  };
}
function create_if_block_1$5(ctx) {
  let h22;
  let t2;
  return {
    c() {
      h22 = element("h2");
      t2 = text(
        /*text*/
        ctx[1]
      );
      this.h();
    },
    l(nodes) {
      h22 = claim_element(nodes, "H2", { class: true });
      var h2_nodes = children(h22);
      t2 = claim_text(
        h2_nodes,
        /*text*/
        ctx[1]
      );
      h2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(h22, "class", "no-margin svelte-1gow1pa");
    },
    m(target, anchor) {
      insert_hydration(target, h22, anchor);
      append_hydration(h22, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*text*/
      2)
        set_data(
          t2,
          /*text*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(h22);
      }
    }
  };
}
function create_if_block$6(ctx) {
  let h12;
  let t2;
  return {
    c() {
      h12 = element("h1");
      t2 = text(
        /*text*/
        ctx[1]
      );
      this.h();
    },
    l(nodes) {
      h12 = claim_element(nodes, "H1", { class: true });
      var h1_nodes = children(h12);
      t2 = claim_text(
        h1_nodes,
        /*text*/
        ctx[1]
      );
      h1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(h12, "class", "no-margin svelte-1gow1pa");
    },
    m(target, anchor) {
      insert_hydration(target, h12, anchor);
      append_hydration(h12, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*text*/
      2)
        set_data(
          t2,
          /*text*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(h12);
      }
    }
  };
}
function create_fragment$8(ctx) {
  let div2;
  function select_block_type(ctx2, dirty) {
    if (
      /*size*/
      ctx2[0] == 1
    )
      return create_if_block$6;
    if (
      /*size*/
      ctx2[0] == 2
    )
      return create_if_block_1$5;
    if (
      /*size*/
      ctx2[0] == 3
    )
      return create_if_block_2$1;
    if (
      /*size*/
      ctx2[0] == 4
    )
      return create_if_block_3$1;
    if (
      /*size*/
      ctx2[0] == 5
    )
      return create_if_block_4;
    if (
      /*size*/
      ctx2[0] == 6
    )
      return create_if_block_5;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      div2 = element("div");
      if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "align-center svelte-1gow1pa");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if_block.m(div2, null);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div2, null);
        }
      }
    },
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if_block.d();
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  let text2;
  let size;
  let { settings } = $$props;
  $$self.$$set = ($$props2) => {
    if ("settings" in $$props2)
      $$invalidate(2, settings = $$props2.settings);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*settings*/
    4) {
      $$invalidate(1, text2 = (settings == null ? void 0 : settings.text) ?? "");
    }
    if ($$self.$$.dirty & /*settings*/
    4) {
      $$invalidate(0, size = settings == null ? void 0 : settings.size);
    }
  };
  return [size, text2, settings];
}
class TextWidget extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, create_fragment$8, safe_not_equal, { settings: 2 });
  }
}
function create_fragment$7(ctx) {
  let div2;
  let textContent = "Unknown widget type";
  return {
    c() {
      div2 = element("div");
      div2.textContent = textContent;
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(div2) !== "svelte-17e4zkc")
        div2.textContent = textContent;
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
class UnknownWidget extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$7, safe_not_equal, {});
  }
}
function create_fragment$6(ctx) {
  let div2;
  let textContent = "Unknown widget type";
  return {
    c() {
      div2 = element("div");
      div2.textContent = textContent;
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(div2) !== "svelte-17e4zkc")
        div2.textContent = textContent;
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
class UnknownEditor extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment$6, safe_not_equal, {});
  }
}
const widgets = [
  {
    type: "capability",
    label: "Capability",
    icon: mdiTune,
    widget: CapabilityWidget,
    editor: CapabilityEditor,
    view: void 0,
    scopes: [
      { oneOf: ["homey", "homey.device", "homey.device.readonly", "homey.device.control"] }
    ],
    create: create$1,
    migration: migrate$1
  },
  {
    type: "flow",
    label: "Flow",
    icon: mdiPlay,
    widget: FlowWidget,
    editor: FlowEditor,
    view: void 0,
    scopes: [
      { oneOf: ["homey", "homey.flow", "homey.flow.start"] }
    ],
    create: () => ({ id: v4(), type: "flow", version: 1 }),
    migration: (e2) => e2
  },
  {
    type: "image",
    label: "Image",
    icon: mdiImage,
    widget: ImageWidget,
    editor: ImageEditor,
    view: ImageWidget,
    scopes: [
      { oneOf: ["homey", "homey.device", "homey.device.readonly", "homey.device.control"] }
    ],
    create: () => ({ id: v4(), type: "image", version: 1 }),
    migration: (e2) => e2
  },
  {
    type: "insight",
    label: "Insight",
    icon: mdiChartLine,
    widget: InsightWidget,
    editor: InsightEditor,
    view: void 0,
    scopes: [
      { oneOf: ["homey", "homey.device", "homey.device.readonly", "homey.device.control"] },
      { oneOf: ["homey", "homey.insights.readonly"] }
    ],
    create,
    migration: migrate
  },
  {
    type: "text",
    label: "Text",
    icon: mdiTextBoxEdit,
    widget: TextWidget,
    editor: TextEditor,
    view: void 0,
    scopes: [],
    create: () => ({ id: v4(), type: "text", version: 1 }),
    migration: (e2) => e2
  }
];
function findWidget(type) {
  var _a2;
  const component = (_a2 = widgets.find((widget) => widget.type === type)) == null ? void 0 : _a2.widget;
  if (component != void 0) {
    return component;
  }
  return UnknownWidget;
}
function findEditor(type) {
  var _a2;
  const editor = (_a2 = widgets.find((widget) => widget.type === type)) == null ? void 0 : _a2.editor;
  if (editor != void 0) {
    return editor;
  }
  return UnknownEditor;
}
function findView(type) {
  var _a2;
  const view = (_a2 = widgets.find((widget) => widget.type === type)) == null ? void 0 : _a2.view;
  return view;
}
function findMigration(type) {
  var _a2;
  const migration = (_a2 = widgets.find((widget) => widget.type === type)) == null ? void 0 : _a2.migration;
  return migration;
}
function findCreate(type) {
  var _a2;
  const create2 = (_a2 = widgets.find((widget) => widget.type === type)) == null ? void 0 : _a2.create;
  return create2;
}
function hasRequiredScopes(type, scopes2) {
  var _a2;
  const requirements = (_a2 = widgets.find((widget) => widget.type === type)) == null ? void 0 : _a2.scopes;
  if (requirements === void 0 || requirements.length === 0) {
    return true;
  }
  return requirements.every((requirement) => requirement.oneOf.some((r) => scopes2.includes(r)));
}
function get_each_context$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i2];
  return child_ctx;
}
function create_if_block$5(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      handleClose: (
        /*onCancel*/
        ctx[3]
      ),
      $$slots: { content: [create_content_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    l(nodes) {
      claim_component(modal.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & /*$$scope, $scopes*/
      514) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_if_block_1$4(ctx) {
  let list_item;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[4](
        /*widget*/
        ctx[6]
      )
    );
  }
  list_item = new List$1.Item({
    props: {
      class: "cursor-pointer",
      $$slots: { default: [create_default_slot_3$2] },
      $$scope: { ctx }
    }
  });
  list_item.$on("click", click_handler);
  return {
    c() {
      create_component(list_item.$$.fragment);
    },
    l(nodes) {
      claim_component(list_item.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list_item, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const list_item_changes = {};
      if (dirty & /*$$scope*/
      512) {
        list_item_changes.$$scope = { dirty, ctx };
      }
      list_item.$set(list_item_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list_item.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list_item.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list_item, detaching);
    }
  };
}
function create_default_slot_3$2(ctx) {
  let t_value = (
    /*widget*/
    ctx[6].label + ""
  );
  let t2;
  return {
    c() {
      t2 = text(t_value);
    },
    l(nodes) {
      t2 = claim_text(nodes, t_value);
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_each_block$2(ctx) {
  let show_if = hasRequiredScopes(
    /*widget*/
    ctx[6].type,
    /*$scopes*/
    ctx[1]
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block_1$4(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*$scopes*/
      2)
        show_if = hasRequiredScopes(
          /*widget*/
          ctx2[6].type,
          /*$scopes*/
          ctx2[1]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$scopes*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_default_slot_2$3(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(widgets);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$2(get_each_context$2(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*onSelect, widgets, hasRequiredScopes, $scopes*/
      6) {
        each_value = ensure_array_like(widgets);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$2(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_default_slot_1$3(ctx) {
  let list;
  let current;
  list = new List$1({
    props: {
      $$slots: { default: [create_default_slot_2$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(list.$$.fragment);
    },
    l(nodes) {
      claim_component(list.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(list, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const list_changes = {};
      if (dirty & /*$$scope, $scopes*/
      514) {
        list_changes.$$scope = { dirty, ctx: ctx2 };
      }
      list.$set(list_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(list.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(list.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(list, detaching);
    }
  };
}
function create_body_slot$1(ctx) {
  let modal_content_body;
  let current;
  modal_content_body = new Modal.Content.Body({
    props: {
      slot: "body",
      $$slots: { default: [create_default_slot_1$3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal_content_body.$$.fragment);
    },
    l(nodes) {
      claim_component(modal_content_body.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal_content_body, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_content_body_changes = {};
      if (dirty & /*$$scope, $scopes*/
      514) {
        modal_content_body_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal_content_body.$set(modal_content_body_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal_content_body.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal_content_body.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal_content_body, detaching);
    }
  };
}
function create_content_slot$1(ctx) {
  let modal_content;
  let current;
  modal_content = new Modal.Content({
    props: {
      slot: "content",
      $$slots: { body: [create_body_slot$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal_content.$$.fragment);
    },
    l(nodes) {
      claim_component(modal_content.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal_content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_content_changes = {};
      if (dirty & /*$$scope, $scopes*/
      514) {
        modal_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal_content.$set(modal_content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal_content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal_content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal_content, detaching);
    }
  };
}
function create_default_slot$4(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*open*/
    ctx[0] && create_if_block$5(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$5(ctx) {
  let portal;
  let current;
  portal = new Portal({
    props: {
      $$slots: { default: [create_default_slot$4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(portal.$$.fragment);
    },
    l(nodes) {
      claim_component(portal.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(portal, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const portal_changes = {};
      if (dirty & /*$$scope, $scopes, open*/
      515) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal.$set(portal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(portal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(portal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(portal, detaching);
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let $scopes;
  component_subscribe($$self, scopes, ($$value) => $$invalidate(1, $scopes = $$value));
  let { open } = $$props;
  const dispatch = createEventDispatcher();
  function onSelect(selected) {
    dispatch("selected", selected);
    $$invalidate(0, open = false);
    dispatch("open", open);
  }
  function onCancel() {
    $$invalidate(0, open = false);
    dispatch("open", open);
  }
  const click_handler = (widget) => onSelect(widget.type);
  $$self.$$set = ($$props2) => {
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
  };
  return [open, $scopes, onSelect, onCancel, click_handler];
}
class AddWidgetDialog extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$5, create_fragment$5, safe_not_equal, { open: 0 });
  }
}
function create_if_block$4(ctx) {
  let drawer;
  let updating_open;
  let current;
  function drawer_open_binding(value) {
    ctx[6](value);
  }
  let drawer_props = {
    position: "right",
    size: "md",
    $$slots: { default: [create_default_slot$3] },
    $$scope: { ctx }
  };
  if (
    /*open*/
    ctx[0] !== void 0
  ) {
    drawer_props.open = /*open*/
    ctx[0];
  }
  drawer = new Drawer$2({ props: drawer_props });
  binding_callbacks.push(() => bind(drawer, "open", drawer_open_binding));
  return {
    c() {
      create_component(drawer.$$.fragment);
    },
    l(nodes) {
      claim_component(drawer.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(drawer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const drawer_changes = {};
      if (dirty & /*$$scope, item, localSettings*/
      518) {
        drawer_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty & /*open*/
      1) {
        updating_open = true;
        drawer_changes.open = /*open*/
        ctx2[0];
        add_flush_callback(() => updating_open = false);
      }
      drawer.$set(drawer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(drawer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(drawer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(drawer, detaching);
    }
  };
}
function create_if_block_1$3(ctx) {
  let div0;
  let button0;
  let t0;
  let button1;
  let t1;
  let divider0;
  let t2;
  let div1;
  let switch_instance0;
  let t3;
  let divider1;
  let t4;
  let div2;
  let switch_instance1;
  let current;
  button0 = new Button$1({
    props: {
      type: "primary",
      $$slots: { default: [create_default_slot_4$1] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*save*/
    ctx[4]
  );
  button1 = new Button$1({
    props: {
      $$slots: { default: [create_default_slot_3$1] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*cancel*/
    ctx[3]
  );
  divider0 = new Divider$2({
    props: {
      $$slots: { label: [create_label_slot_1] },
      $$scope: { ctx }
    }
  });
  var switch_value = findWidget(
    /*item*/
    ctx[1].settings.type
  );
  function switch_props(ctx2) {
    return {
      props: { settings: (
        /*localSettings*/
        ctx2[2]
      ) }
    };
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx));
  }
  divider1 = new Divider$2({
    props: {
      $$slots: { label: [create_label_slot] },
      $$scope: { ctx }
    }
  });
  var switch_value_1 = findEditor(
    /*item*/
    ctx[1].settings.type
  );
  function switch_props_1(ctx2) {
    return {
      props: { settings: (
        /*localSettings*/
        ctx2[2]
      ) }
    };
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx));
    switch_instance1.$on(
      "settings",
      /*settings_handler*/
      ctx[5]
    );
  }
  return {
    c() {
      div0 = element("div");
      create_component(button0.$$.fragment);
      t0 = space();
      create_component(button1.$$.fragment);
      t1 = space();
      create_component(divider0.$$.fragment);
      t2 = space();
      div1 = element("div");
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t3 = space();
      create_component(divider1.$$.fragment);
      t4 = space();
      div2 = element("div");
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", {});
      var div0_nodes = children(div0);
      claim_component(button0.$$.fragment, div0_nodes);
      t0 = claim_space(div0_nodes);
      claim_component(button1.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach);
      t1 = claim_space(nodes);
      claim_component(divider0.$$.fragment, nodes);
      t2 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (switch_instance0)
        claim_component(switch_instance0.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      t3 = claim_space(nodes);
      claim_component(divider1.$$.fragment, nodes);
      t4 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (switch_instance1)
        claim_component(switch_instance1.$$.fragment, div2_nodes);
      div2_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div1, "class", "w-full");
      attr(div2, "class", "mt-5");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      mount_component(button0, div0, null);
      append_hydration(div0, t0);
      mount_component(button1, div0, null);
      insert_hydration(target, t1, anchor);
      mount_component(divider0, target, anchor);
      insert_hydration(target, t2, anchor);
      insert_hydration(target, div1, anchor);
      if (switch_instance0)
        mount_component(switch_instance0, div1, null);
      insert_hydration(target, t3, anchor);
      mount_component(divider1, target, anchor);
      insert_hydration(target, t4, anchor);
      insert_hydration(target, div2, anchor);
      if (switch_instance1)
        mount_component(switch_instance1, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty & /*$$scope*/
      512) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & /*$$scope*/
      512) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const divider0_changes = {};
      if (dirty & /*$$scope*/
      512) {
        divider0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      divider0.$set(divider0_changes);
      const switch_instance0_changes = {};
      if (dirty & /*localSettings*/
      4)
        switch_instance0_changes.settings = /*localSettings*/
        ctx2[2];
      if (dirty & /*item*/
      2 && switch_value !== (switch_value = findWidget(
        /*item*/
        ctx2[1].settings.type
      ))) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, div1, null);
        } else {
          switch_instance0 = null;
        }
      } else if (switch_value) {
        switch_instance0.$set(switch_instance0_changes);
      }
      const divider1_changes = {};
      if (dirty & /*$$scope*/
      512) {
        divider1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      divider1.$set(divider1_changes);
      const switch_instance1_changes = {};
      if (dirty & /*localSettings*/
      4)
        switch_instance1_changes.settings = /*localSettings*/
        ctx2[2];
      if (dirty & /*item*/
      2 && switch_value_1 !== (switch_value_1 = findEditor(
        /*item*/
        ctx2[1].settings.type
      ))) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component(switch_value_1, switch_props_1(ctx2));
          switch_instance1.$on(
            "settings",
            /*settings_handler*/
            ctx2[5]
          );
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, div2, null);
        } else {
          switch_instance1 = null;
        }
      } else if (switch_value_1) {
        switch_instance1.$set(switch_instance1_changes);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(divider0.$$.fragment, local);
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      transition_in(divider1.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(divider0.$$.fragment, local);
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      transition_out(divider1.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t1);
        detach(t2);
        detach(div1);
        detach(t3);
        detach(t4);
        detach(div2);
      }
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(divider0, detaching);
      if (switch_instance0)
        destroy_component(switch_instance0);
      destroy_component(divider1, detaching);
      if (switch_instance1)
        destroy_component(switch_instance1);
    }
  };
}
function create_default_slot_4$1(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Save");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Save");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_3$1(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Cancel");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Cancel");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_2$2(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Preview");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Preview");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_label_slot_1(ctx) {
  let divider_label;
  let current;
  divider_label = new Divider$2.Label({
    props: {
      slot: "label",
      $$slots: { default: [create_default_slot_2$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(divider_label.$$.fragment);
    },
    l(nodes) {
      claim_component(divider_label.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(divider_label, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const divider_label_changes = {};
      if (dirty & /*$$scope*/
      512) {
        divider_label_changes.$$scope = { dirty, ctx: ctx2 };
      }
      divider_label.$set(divider_label_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(divider_label.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(divider_label.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(divider_label, detaching);
    }
  };
}
function create_default_slot_1$2(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Settings");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Settings");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_label_slot(ctx) {
  let divider_label;
  let current;
  divider_label = new Divider$2.Label({
    props: {
      slot: "label",
      $$slots: { default: [create_default_slot_1$2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(divider_label.$$.fragment);
    },
    l(nodes) {
      claim_component(divider_label.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(divider_label, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const divider_label_changes = {};
      if (dirty & /*$$scope*/
      512) {
        divider_label_changes.$$scope = { dirty, ctx: ctx2 };
      }
      divider_label.$set(divider_label_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(divider_label.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(divider_label.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(divider_label, detaching);
    }
  };
}
function create_default_slot$3(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*item*/
    ctx[1] !== void 0 && /*localSettings*/
    ctx[2] !== void 0 && create_if_block_1$3(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*item*/
        ctx2[1] !== void 0 && /*localSettings*/
        ctx2[2] !== void 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*item, localSettings*/
          6) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment$4(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*open*/
    ctx[0] && create_if_block$4(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*open*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*open*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let { open = false } = $$props;
  let { item } = $$props;
  const dispatch = createEventDispatcher();
  let localSettings;
  function onItem(i2) {
    if (item === void 0) {
      $$invalidate(2, localSettings = void 0);
    } else {
      $$invalidate(2, localSettings = { ...item == null ? void 0 : item.settings });
    }
  }
  function cancel() {
    if (item !== void 0) {
      $$invalidate(2, localSettings = { ...item.settings });
    }
    dispatch("settings", localSettings);
  }
  function save() {
    dispatch("settings", localSettings);
  }
  const settings_handler = (e2) => $$invalidate(2, localSettings = e2.detail);
  function drawer_open_binding(value) {
    open = value;
    $$invalidate(0, open);
  }
  $$self.$$set = ($$props2) => {
    if ("open" in $$props2)
      $$invalidate(0, open = $$props2.open);
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    2) {
      onItem();
    }
  };
  return [open, item, localSettings, cancel, save, settings_handler, drawer_open_binding];
}
class EditWidgetView extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$4, create_fragment$4, safe_not_equal, { open: 0, item: 1 });
  }
}
function throttle(func, timeFrame) {
  let lastTime = 0;
  return function(...args) {
    let now2 = /* @__PURE__ */ new Date();
    if (now2 - lastTime >= timeFrame) {
      func(...args);
      lastTime = now2;
    }
  };
}
function getRowsCount(items, cols) {
  const getItemsMaxHeight = items.map((val) => {
    const item = val[cols];
    return (item && item.y) + (item && item.h) || 0;
  });
  return Math.max(...getItemsMaxHeight, 1);
}
const getColumn = (containerWidth, columns) => {
  const sortColumns = columns.slice().sort((a3, b2) => a3[0] - b2[0]);
  const breakpoint = sortColumns.find((value) => {
    const [width2] = value;
    return containerWidth <= width2;
  });
  if (breakpoint) {
    return breakpoint[1];
  } else {
    return sortColumns[sortColumns.length - 1][1];
  }
};
function getContainerHeight(items, yPerPx, cols) {
  return getRowsCount(items, cols) * yPerPx;
}
const makeMatrix = (rows, cols) => Array.from(Array(rows), () => new Array(cols));
function makeMatrixFromItems(items, _row, _col) {
  let matrix = makeMatrix(_row, _col);
  for (var i2 = 0; i2 < items.length; i2++) {
    const value = items[i2][_col];
    if (value) {
      const { x: x2, y: y3, h: h4 } = value;
      const id = items[i2].id;
      const w2 = Math.min(_col, value.w);
      for (var j = y3; j < y3 + h4; j++) {
        const row = matrix[j];
        for (var k2 = x2; k2 < x2 + w2; k2++) {
          row[k2] = { ...value, id };
        }
      }
    }
  }
  return matrix;
}
function findCloseBlocks(items, matrix, curObject) {
  const { h: h4, x: x2, y: y3 } = curObject;
  const w2 = Math.min(matrix[0].length, curObject.w);
  const tempR = matrix.slice(y3, y3 + h4);
  let result = [];
  for (var i2 = 0; i2 < tempR.length; i2++) {
    let tempA = tempR[i2].slice(x2, x2 + w2);
    result = [...result, ...tempA.map((val) => val.id && val.id !== curObject.id && val.id).filter(Boolean)];
  }
  return [...new Set(result)];
}
function makeMatrixFromItemsIgnore(items, ignoreList, _row, _col) {
  let matrix = makeMatrix(_row, _col);
  for (var i2 = 0; i2 < items.length; i2++) {
    const value = items[i2][_col];
    const id = items[i2].id;
    const { x: x2, y: y3, h: h4 } = value;
    const w2 = Math.min(_col, value.w);
    if (ignoreList.indexOf(id) === -1) {
      for (var j = y3; j < y3 + h4; j++) {
        const row = matrix[j];
        if (row) {
          for (var k2 = x2; k2 < x2 + w2; k2++) {
            row[k2] = { ...value, id };
          }
        }
      }
    }
  }
  return matrix;
}
function findItemsById(closeBlocks, items) {
  return items.filter((value) => closeBlocks.indexOf(value.id) !== -1);
}
function getItemById(id, items) {
  return items.find((value) => value.id === id);
}
function findFreeSpaceForItem(matrix, item) {
  const cols = matrix[0].length;
  const w2 = Math.min(cols, item.w);
  let xNtime = cols - w2;
  let getMatrixRows = matrix.length;
  for (var i2 = 0; i2 < getMatrixRows; i2++) {
    const row = matrix[i2];
    for (var j = 0; j < xNtime + 1; j++) {
      const sliceA = row.slice(j, j + w2);
      const empty2 = sliceA.every((val) => val === void 0);
      if (empty2) {
        const isEmpty = matrix.slice(i2, i2 + item.h).every((a3) => a3.slice(j, j + w2).every((n) => n === void 0));
        if (isEmpty) {
          return { y: i2, x: j };
        }
      }
    }
  }
  return {
    y: getMatrixRows,
    x: 0
  };
}
const getItem = (item, col) => {
  return { ...item[col], id: item.id };
};
const updateItem = (elements2, active, position, col) => {
  return elements2.map((value) => {
    if (value.id === active.id) {
      return { ...value, [col]: { ...value[col], ...position } };
    }
    return value;
  });
};
function moveItemsAroundItem(active, items, cols, original) {
  const activeItem = getItem(active, cols);
  const ids = items.map((value) => value.id).filter((value) => value !== activeItem.id);
  const els = items.filter((value) => value.id !== activeItem.id);
  let newItems = updateItem(items, active, activeItem, cols);
  let matrix = makeMatrixFromItemsIgnore(newItems, ids, getRowsCount(newItems, cols), cols);
  let tempItems = newItems;
  let exclude2 = [];
  els.forEach((item) => {
    let position = findFreeSpaceForItem(matrix, item[cols]);
    exclude2.push(item.id);
    tempItems = updateItem(tempItems, item, position, cols);
    let getIgnoreItems = ids.filter((value) => exclude2.indexOf(value) === -1);
    matrix = makeMatrixFromItemsIgnore(tempItems, getIgnoreItems, getRowsCount(tempItems, cols), cols);
  });
  return tempItems;
}
function moveItem(active, items, cols, original) {
  const item = getItem(active, cols);
  let matrix = makeMatrixFromItemsIgnore(items, [item.id], getRowsCount(items, cols), cols);
  const closeBlocks = findCloseBlocks(items, matrix, item);
  let closeObj = findItemsById(closeBlocks, items);
  const fixed = closeObj.find((value) => value[cols].fixed);
  if (fixed)
    return items;
  items = updateItem(items, active, item, cols);
  matrix = makeMatrixFromItemsIgnore(items, closeBlocks, getRowsCount(items, cols), cols);
  let tempItems = items;
  let tempCloseBlocks = closeBlocks;
  let exclude2 = [];
  closeObj.forEach((item2) => {
    let position = findFreeSpaceForItem(matrix, item2[cols]);
    exclude2.push(item2.id);
    tempItems = updateItem(tempItems, item2, position, cols);
    let getIgnoreItems = tempCloseBlocks.filter((value) => exclude2.indexOf(value) === -1);
    matrix = makeMatrixFromItemsIgnore(tempItems, getIgnoreItems, getRowsCount(tempItems, cols), cols);
  });
  return tempItems;
}
function normalize(items, col) {
  let result = items.slice();
  result.forEach((value) => {
    const getItem2 = value[col];
    if (!getItem2.static) {
      result = moveItem(getItem2, result, col, { ...getItem2 });
    }
  });
  return result;
}
function adjust(items, col) {
  let matrix = makeMatrix(getRowsCount(items, col), col);
  const order2 = items.toSorted((a3, b2) => {
    const aItem = a3[col];
    const bItem = b2[col];
    return aItem.x - bItem.x || aItem.y - bItem.y;
  });
  return order2.reduce((acc, item) => {
    let position = findFreeSpaceForItem(matrix, item[col]);
    acc.push({
      ...item,
      [col]: {
        ...item[col],
        ...position
      }
    });
    matrix = makeMatrixFromItems(acc, getRowsCount(acc, col), col);
    return acc;
  }, []);
}
function getUndefinedItems(items, col, breakpoints) {
  return items.map((value) => {
    if (!value[col]) {
      return value.id;
    }
  }).filter(Boolean);
}
function getClosestColumn(items, item, col, breakpoints) {
  return breakpoints.map(([_, column]) => item[column] && column).filter(Boolean).reduce(function(acc, value) {
    const isLower = Math.abs(value - col) < Math.abs(acc - col);
    return isLower ? value : acc;
  });
}
function specifyUndefinedColumns(items, col, breakpoints) {
  let matrix = makeMatrixFromItems(items, getRowsCount(items, col), col);
  const getUndefinedElements = getUndefinedItems(items, col);
  let newItems = [...items];
  getUndefinedElements.forEach((elementId) => {
    const getElement = items.find((item) => item.id === elementId);
    const closestColumn = getClosestColumn(items, getElement, col, breakpoints);
    const position = findFreeSpaceForItem(matrix, getElement[closestColumn]);
    const newItem = {
      ...getElement,
      [col]: {
        ...getElement[closestColumn],
        ...position
      }
    };
    newItems = newItems.map((value) => value.id === elementId ? newItem : value);
    matrix = makeMatrixFromItems(newItems, getRowsCount(newItems, col), col);
  });
  return newItems;
}
const index_svelte_svelte_type_style_lang$1 = "";
const get_default_slot_changes$1 = (dirty) => ({});
const get_default_slot_context$1 = (ctx) => ({
  movePointerDown: (
    /*pointerdown*/
    ctx[18]
  ),
  resizePointerDown: (
    /*resizePointerDown*/
    ctx[19]
  )
});
function create_if_block_1$2(ctx) {
  let div2;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      children(div2).forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "svlt-grid-resizer svelte-1iyj4z4");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (!mounted) {
        dispose = listen(
          div2,
          "pointerdown",
          /*resizePointerDown*/
          ctx[19]
        );
        mounted = true;
      }
    },
    p: noop$1,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$3(ctx) {
  let div2;
  return {
    c() {
      div2 = element("div");
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      children(div2).forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "svlt-grid-shadow shadow-active svelte-1iyj4z4");
      set_style(
        div2,
        "width",
        /*shadow*/
        ctx[12].w * /*xPerPx*/
        ctx[6] - /*gapX*/
        ctx[8] * 2 + "px"
      );
      set_style(
        div2,
        "height",
        /*shadow*/
        ctx[12].h * /*yPerPx*/
        ctx[7] - /*gapY*/
        ctx[9] * 2 + "px"
      );
      set_style(div2, "transform", "translate(" + /*shadow*/
      (ctx[12].x * /*xPerPx*/
      ctx[6] + /*gapX*/
      ctx[8]) + "px, " + /*shadow*/
      (ctx[12].y * /*yPerPx*/
      ctx[7] + /*gapY*/
      ctx[9]) + "px)");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      ctx[29](div2);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*shadow, xPerPx, gapX*/
      4416) {
        set_style(
          div2,
          "width",
          /*shadow*/
          ctx2[12].w * /*xPerPx*/
          ctx2[6] - /*gapX*/
          ctx2[8] * 2 + "px"
        );
      }
      if (dirty[0] & /*shadow, yPerPx, gapY*/
      4736) {
        set_style(
          div2,
          "height",
          /*shadow*/
          ctx2[12].h * /*yPerPx*/
          ctx2[7] - /*gapY*/
          ctx2[9] * 2 + "px"
        );
      }
      if (dirty[0] & /*shadow, xPerPx, gapX, yPerPx, gapY*/
      5056) {
        set_style(div2, "transform", "translate(" + /*shadow*/
        (ctx2[12].x * /*xPerPx*/
        ctx2[6] + /*gapX*/
        ctx2[8]) + "px, " + /*shadow*/
        (ctx2[12].y * /*yPerPx*/
        ctx2[7] + /*gapY*/
        ctx2[9]) + "px)");
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      ctx[29](null);
    }
  };
}
function create_fragment$3(ctx) {
  let div2;
  let t0;
  let div_style_value;
  let t1;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[28].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[27],
    get_default_slot_context$1
  );
  let if_block0 = (
    /*resizable*/
    ctx[4] && !/*item*/
    ctx[10].customResizer && create_if_block_1$2(ctx)
  );
  let if_block1 = (
    /*active*/
    (ctx[13] || /*trans*/
    ctx[16]) && create_if_block$3(ctx)
  );
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", {
        draggable: true,
        class: true,
        style: true
      });
      var div_nodes = children(div2);
      if (default_slot)
        default_slot.l(div_nodes);
      t0 = claim_space(div_nodes);
      if (if_block0)
        if_block0.l(div_nodes);
      div_nodes.forEach(detach);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
      this.h();
    },
    h() {
      attr(div2, "draggable", false);
      attr(div2, "class", "svlt-grid-item svelte-1iyj4z4");
      attr(div2, "style", div_style_value = "width: " + /*active*/
      (ctx[13] ? (
        /*newSize*/
        ctx[15].width
      ) : (
        /*width*/
        ctx[0]
      )) + "px; height:" + /*active*/
      (ctx[13] ? (
        /*newSize*/
        ctx[15].height
      ) : (
        /*height*/
        ctx[1]
      )) + "px; " + /*active*/
      (ctx[13] ? `transform: translate(${/*cordDiff*/
      ctx[14].x}px, ${/*cordDiff*/
      ctx[14].y}px);top:${/*rect*/
      ctx[17].top}px;left:${/*rect*/
      ctx[17].left}px;` : (
        /*trans*/
        ctx[16] ? `transform: translate(${/*cordDiff*/
        ctx[14].x}px, ${/*cordDiff*/
        ctx[14].y}px); position:absolute; transition: width 0.2s, height 0.2s;` : `transition: transform 0.2s, opacity 0.2s; transform: translate(${/*left*/
        ctx[2]}px, ${/*top*/
        ctx[3]}px); `
      )));
      toggle_class(
        div2,
        "svlt-grid-active",
        /*active*/
        ctx[13] || /*trans*/
        ctx[16] && /*rect*/
        ctx[17]
      );
      toggle_class(
        div2,
        "touch-none",
        /*draggable*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      append_hydration(div2, t0);
      if (if_block0)
        if_block0.m(div2, null);
      insert_hydration(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(div2, "pointerdown", function() {
          if (is_function(
            /*item*/
            ctx[10] && /*item*/
            ctx[10].customDragger ? null : (
              /*draggable*/
              ctx[5] && /*pointerdown*/
              ctx[18]
            )
          ))
            /*item*/
            (ctx[10] && /*item*/
            ctx[10].customDragger ? null : (
              /*draggable*/
              ctx[5] && /*pointerdown*/
              ctx[18]
            )).apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        134217728)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[27],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[27]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[27],
              dirty,
              get_default_slot_changes$1
            ),
            get_default_slot_context$1
          );
        }
      }
      if (
        /*resizable*/
        ctx[4] && !/*item*/
        ctx[10].customResizer
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_1$2(ctx);
          if_block0.c();
          if_block0.m(div2, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty[0] & /*active, newSize, width, height, cordDiff, rect, trans, left, top*/
      253967 && div_style_value !== (div_style_value = "width: " + /*active*/
      (ctx[13] ? (
        /*newSize*/
        ctx[15].width
      ) : (
        /*width*/
        ctx[0]
      )) + "px; height:" + /*active*/
      (ctx[13] ? (
        /*newSize*/
        ctx[15].height
      ) : (
        /*height*/
        ctx[1]
      )) + "px; " + /*active*/
      (ctx[13] ? `transform: translate(${/*cordDiff*/
      ctx[14].x}px, ${/*cordDiff*/
      ctx[14].y}px);top:${/*rect*/
      ctx[17].top}px;left:${/*rect*/
      ctx[17].left}px;` : (
        /*trans*/
        ctx[16] ? `transform: translate(${/*cordDiff*/
        ctx[14].x}px, ${/*cordDiff*/
        ctx[14].y}px); position:absolute; transition: width 0.2s, height 0.2s;` : `transition: transform 0.2s, opacity 0.2s; transform: translate(${/*left*/
        ctx[2]}px, ${/*top*/
        ctx[3]}px); `
      )))) {
        attr(div2, "style", div_style_value);
      }
      if (!current || dirty[0] & /*active, trans, rect*/
      204800) {
        toggle_class(
          div2,
          "svlt-grid-active",
          /*active*/
          ctx[13] || /*trans*/
          ctx[16] && /*rect*/
          ctx[17]
        );
      }
      if (!current || dirty[0] & /*draggable*/
      32) {
        toggle_class(
          div2,
          "touch-none",
          /*draggable*/
          ctx[5]
        );
      }
      if (
        /*active*/
        ctx[13] || /*trans*/
        ctx[16]
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block$3(ctx);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(if_block1_anchor);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  let { sensor } = $$props;
  let { width: width2 } = $$props;
  let { height } = $$props;
  let { left: left2 } = $$props;
  let { top: top2 } = $$props;
  let { resizable } = $$props;
  let { draggable } = $$props;
  let { id } = $$props;
  let { container } = $$props;
  let { xPerPx } = $$props;
  let { yPerPx } = $$props;
  let { gapX } = $$props;
  let { gapY } = $$props;
  let { item } = $$props;
  let { max: max2 } = $$props;
  let { min: min2 } = $$props;
  let { cols } = $$props;
  let { nativeContainer } = $$props;
  let shadowElement;
  let shadow = {};
  let active = false;
  let initX, initY;
  let capturePos = { x: 0, y: 0 };
  let cordDiff = { x: 0, y: 0 };
  let newSize = { width: width2, height };
  let trans = false;
  let anima;
  const inActivate = () => {
    const shadowBound = shadowElement.getBoundingClientRect();
    const xdragBound = rect.left + cordDiff.x;
    const ydragBound = rect.top + cordDiff.y;
    $$invalidate(14, cordDiff.x = shadow.x * xPerPx + gapX - (shadowBound.x - xdragBound), cordDiff);
    $$invalidate(14, cordDiff.y = shadow.y * yPerPx + gapY - (shadowBound.y - ydragBound), cordDiff);
    $$invalidate(13, active = false);
    $$invalidate(16, trans = true);
    clearTimeout(anima);
    anima = setTimeout(
      () => {
        $$invalidate(16, trans = false);
      },
      100
    );
    dispatch("pointerup", { id });
  };
  let repaint = (cb, isPointerUp) => {
    dispatch("repaint", { id, shadow, isPointerUp, onUpdate: cb });
  };
  let _scrollTop = 0;
  let containerFrame;
  let rect;
  let scrollElement;
  const getContainerFrame = (element2) => {
    if (element2 === document.documentElement || !element2) {
      const { height: height2, top: top3, right: right2, bottom: bottom2, left: left3 } = nativeContainer.getBoundingClientRect();
      return {
        top: Math.max(0, top3),
        bottom: Math.min(window.innerHeight, bottom2)
      };
    }
    return element2.getBoundingClientRect();
  };
  const getScroller = (element2) => !element2 ? document.documentElement : element2;
  const pointerdown = ({ clientX, clientY, target }) => {
    initX = clientX;
    initY = clientY;
    capturePos = { x: left2, y: top2 };
    $$invalidate(12, shadow = {
      x: item.x,
      y: item.y,
      w: item.w,
      h: item.h
    });
    $$invalidate(15, newSize = { width: width2, height });
    containerFrame = getContainerFrame(container);
    scrollElement = getScroller(container);
    $$invalidate(14, cordDiff = { x: 0, y: 0 });
    $$invalidate(17, rect = target.closest(".svlt-grid-item").getBoundingClientRect());
    $$invalidate(13, active = true);
    $$invalidate(16, trans = false);
    _scrollTop = scrollElement.scrollTop;
    window.addEventListener("pointermove", pointermove);
    window.addEventListener("pointerup", pointerup);
  };
  let sign2 = { x: 0, y: 0 };
  let vel = { x: 0, y: 0 };
  let intervalId = 0;
  const stopAutoscroll = () => {
    clearInterval(intervalId);
    intervalId = false;
    sign2 = { x: 0, y: 0 };
    vel = { x: 0, y: 0 };
  };
  const update = () => {
    const _newScrollTop = scrollElement.scrollTop - _scrollTop;
    const boundX = capturePos.x + cordDiff.x;
    const boundY = capturePos.y + (cordDiff.y + _newScrollTop);
    let gridX = Math.round(boundX / xPerPx);
    let gridY = Math.round(boundY / yPerPx);
    $$invalidate(12, shadow.x = Math.max(Math.min(gridX, cols - shadow.w), 0), shadow);
    $$invalidate(12, shadow.y = Math.max(gridY, 0), shadow);
    if (max2.y) {
      $$invalidate(12, shadow.y = Math.min(shadow.y, max2.y), shadow);
    }
    repaint();
  };
  const pointermove = (event) => {
    event.preventDefault();
    event.stopPropagation();
    event.stopImmediatePropagation();
    const { clientX, clientY } = event;
    $$invalidate(14, cordDiff = { x: clientX - initX, y: clientY - initY });
    const Y_SENSOR = sensor;
    let velocityTop = Math.max(0, (containerFrame.top + Y_SENSOR - clientY) / Y_SENSOR);
    let velocityBottom = Math.max(0, (clientY - (containerFrame.bottom - Y_SENSOR)) / Y_SENSOR);
    const topSensor = velocityTop > 0 && velocityBottom === 0;
    const bottomSensor = velocityBottom > 0 && velocityTop === 0;
    sign2.y = topSensor ? -1 : bottomSensor ? 1 : 0;
    vel.y = sign2.y === -1 ? velocityTop : velocityBottom;
    if (vel.y > 0) {
      if (!intervalId) {
        intervalId = setInterval(
          () => {
            scrollElement.scrollTop += 2 * (vel.y + Math.sign(vel.y)) * sign2.y;
            update();
          },
          10
        );
      }
    } else if (intervalId) {
      stopAutoscroll();
    } else {
      update();
    }
  };
  const pointerup = (e2) => {
    stopAutoscroll();
    window.removeEventListener("pointerdown", pointerdown);
    window.removeEventListener("pointermove", pointermove);
    window.removeEventListener("pointerup", pointerup);
    repaint(inActivate, true);
  };
  let resizeInitPos = { x: 0, y: 0 };
  let initSize = { width: 0, height: 0 };
  const resizePointerDown = (e2) => {
    e2.stopPropagation();
    const { pageX, pageY } = e2;
    resizeInitPos = { x: pageX, y: pageY };
    initSize = { width: width2, height };
    $$invalidate(14, cordDiff = { x: 0, y: 0 });
    $$invalidate(17, rect = e2.target.closest(".svlt-grid-item").getBoundingClientRect());
    $$invalidate(15, newSize = { width: width2, height });
    $$invalidate(13, active = true);
    $$invalidate(16, trans = false);
    $$invalidate(12, shadow = {
      x: item.x,
      y: item.y,
      w: item.w,
      h: item.h
    });
    containerFrame = getContainerFrame(container);
    scrollElement = getScroller(container);
    window.addEventListener("pointermove", resizePointerMove);
    window.addEventListener("pointerup", resizePointerUp);
  };
  const resizePointerMove = ({ pageX, pageY }) => {
    $$invalidate(15, newSize.width = initSize.width + pageX - resizeInitPos.x, newSize);
    $$invalidate(15, newSize.height = initSize.height + pageY - resizeInitPos.y, newSize);
    let maxWidth = cols - shadow.x;
    maxWidth = Math.min(max2.w, maxWidth) || maxWidth;
    $$invalidate(15, newSize.width = Math.max(Math.min(newSize.width, maxWidth * xPerPx - gapX * 2), min2.w * xPerPx - gapX * 2), newSize);
    $$invalidate(15, newSize.height = Math.max(newSize.height, min2.h * yPerPx - gapY * 2), newSize);
    if (max2.h) {
      $$invalidate(15, newSize.height = Math.min(newSize.height, max2.h * yPerPx - gapY * 2), newSize);
    }
    $$invalidate(12, shadow.w = Math.round((newSize.width + gapX * 2) / xPerPx), shadow);
    $$invalidate(12, shadow.h = Math.round((newSize.height + gapY * 2) / yPerPx), shadow);
    repaint();
  };
  const resizePointerUp = (e2) => {
    e2.stopPropagation();
    repaint(inActivate, true);
    window.removeEventListener("pointermove", resizePointerMove);
    window.removeEventListener("pointerup", resizePointerUp);
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      shadowElement = $$value;
      $$invalidate(11, shadowElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("sensor" in $$props2)
      $$invalidate(20, sensor = $$props2.sensor);
    if ("width" in $$props2)
      $$invalidate(0, width2 = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(1, height = $$props2.height);
    if ("left" in $$props2)
      $$invalidate(2, left2 = $$props2.left);
    if ("top" in $$props2)
      $$invalidate(3, top2 = $$props2.top);
    if ("resizable" in $$props2)
      $$invalidate(4, resizable = $$props2.resizable);
    if ("draggable" in $$props2)
      $$invalidate(5, draggable = $$props2.draggable);
    if ("id" in $$props2)
      $$invalidate(21, id = $$props2.id);
    if ("container" in $$props2)
      $$invalidate(22, container = $$props2.container);
    if ("xPerPx" in $$props2)
      $$invalidate(6, xPerPx = $$props2.xPerPx);
    if ("yPerPx" in $$props2)
      $$invalidate(7, yPerPx = $$props2.yPerPx);
    if ("gapX" in $$props2)
      $$invalidate(8, gapX = $$props2.gapX);
    if ("gapY" in $$props2)
      $$invalidate(9, gapY = $$props2.gapY);
    if ("item" in $$props2)
      $$invalidate(10, item = $$props2.item);
    if ("max" in $$props2)
      $$invalidate(23, max2 = $$props2.max);
    if ("min" in $$props2)
      $$invalidate(24, min2 = $$props2.min);
    if ("cols" in $$props2)
      $$invalidate(25, cols = $$props2.cols);
    if ("nativeContainer" in $$props2)
      $$invalidate(26, nativeContainer = $$props2.nativeContainer);
    if ("$$scope" in $$props2)
      $$invalidate(27, $$scope = $$props2.$$scope);
  };
  return [
    width2,
    height,
    left2,
    top2,
    resizable,
    draggable,
    xPerPx,
    yPerPx,
    gapX,
    gapY,
    item,
    shadowElement,
    shadow,
    active,
    cordDiff,
    newSize,
    trans,
    rect,
    pointerdown,
    resizePointerDown,
    sensor,
    id,
    container,
    max2,
    min2,
    cols,
    nativeContainer,
    $$scope,
    slots,
    div_binding
  ];
}
class MoveResize extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$3,
      create_fragment$3,
      safe_not_equal,
      {
        sensor: 20,
        width: 0,
        height: 1,
        left: 2,
        top: 3,
        resizable: 4,
        draggable: 5,
        id: 21,
        container: 22,
        xPerPx: 6,
        yPerPx: 7,
        gapX: 8,
        gapY: 9,
        item: 10,
        max: 23,
        min: 24,
        cols: 25,
        nativeContainer: 26
      },
      null,
      [-1, -1]
    );
  }
}
const index_svelte_svelte_type_style_lang = "";
function get_each_context$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[28] = list[i2];
  child_ctx[30] = i2;
  return child_ctx;
}
const get_default_slot_changes = (dirty) => ({
  movePointerDown: dirty[1] & /*movePointerDown*/
  2,
  resizePointerDown: dirty[1] & /*resizePointerDown*/
  1,
  dataItem: dirty[0] & /*items*/
  1,
  item: dirty[0] & /*items, getComputedCols*/
  17,
  index: dirty[0] & /*items*/
  1
});
const get_default_slot_context = (ctx) => ({
  movePointerDown: (
    /*movePointerDown*/
    ctx[32]
  ),
  resizePointerDown: (
    /*resizePointerDown*/
    ctx[31]
  ),
  dataItem: (
    /*item*/
    ctx[28]
  ),
  item: (
    /*item*/
    ctx[28][
      /*getComputedCols*/
      ctx[4]
    ]
  ),
  index: (
    /*i*/
    ctx[30]
  )
});
function create_if_block$2(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*items*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[28].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$1(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$1(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    l(nodes) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(nodes);
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert_hydration(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*items, getComputedCols, xPerPx, yPerPx, gapX, gapY, sensor, scroller, container, handleRepaint, pointerup, $$scope*/
      2105213 | dirty[1] & /*movePointerDown, resizePointerDown*/
      3) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[0]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$1, each_1_anchor, get_each_context$1);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_if_block_1$1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[19].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    get_default_slot_context
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    l(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, items, getComputedCols*/
        2097169 | dirty[1] & /*movePointerDown, resizePointerDown*/
        3)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_default_slot$2(ctx) {
  let t2;
  let current;
  let if_block = (
    /*item*/
    ctx[28][
      /*getComputedCols*/
      ctx[4]
    ] && create_if_block_1$1(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      t2 = space();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      t2 = claim_space(nodes);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, t2, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*item*/
        ctx2[28][
          /*getComputedCols*/
          ctx2[4]
        ]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*items, getComputedCols*/
          17) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_each_block$1(key_1, ctx) {
  let first;
  let moveresize;
  let current;
  moveresize = new MoveResize({
    props: {
      id: (
        /*item*/
        ctx[28].id
      ),
      resizable: (
        /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ] && /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ].resizable
      ),
      draggable: (
        /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ] && /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ].draggable
      ),
      xPerPx: (
        /*xPerPx*/
        ctx[6]
      ),
      yPerPx: (
        /*yPerPx*/
        ctx[10]
      ),
      width: Math.min(
        /*getComputedCols*/
        ctx[4],
        /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ] && /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ].w
      ) * /*xPerPx*/
      ctx[6] - /*gapX*/
      ctx[9] * 2,
      height: (
        /*item*/
        (ctx[28][
          /*getComputedCols*/
          ctx[4]
        ] && /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ].h) * /*yPerPx*/
        ctx[10] - /*gapY*/
        ctx[8] * 2
      ),
      top: (
        /*item*/
        (ctx[28][
          /*getComputedCols*/
          ctx[4]
        ] && /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ].y) * /*yPerPx*/
        ctx[10] + /*gapY*/
        ctx[8]
      ),
      left: (
        /*item*/
        (ctx[28][
          /*getComputedCols*/
          ctx[4]
        ] && /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ].x) * /*xPerPx*/
        ctx[6] + /*gapX*/
        ctx[9]
      ),
      item: (
        /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ]
      ),
      min: (
        /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ] && /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ].min
      ),
      max: (
        /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ] && /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ].max
      ),
      cols: (
        /*getComputedCols*/
        ctx[4]
      ),
      gapX: (
        /*gapX*/
        ctx[9]
      ),
      gapY: (
        /*gapY*/
        ctx[8]
      ),
      sensor: (
        /*sensor*/
        ctx[3]
      ),
      container: (
        /*scroller*/
        ctx[2]
      ),
      nativeContainer: (
        /*container*/
        ctx[5]
      ),
      $$slots: {
        default: [
          create_default_slot$2,
          ({ resizePointerDown, movePointerDown }) => ({
            31: resizePointerDown,
            32: movePointerDown
          }),
          ({ resizePointerDown, movePointerDown }) => [0, (resizePointerDown ? 1 : 0) | (movePointerDown ? 2 : 0)]
        ]
      },
      $$scope: { ctx }
    }
  });
  moveresize.$on(
    "repaint",
    /*handleRepaint*/
    ctx[12]
  );
  moveresize.$on(
    "pointerup",
    /*pointerup*/
    ctx[11]
  );
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(moveresize.$$.fragment);
      this.h();
    },
    l(nodes) {
      first = empty();
      claim_component(moveresize.$$.fragment, nodes);
      this.h();
    },
    h() {
      this.first = first;
    },
    m(target, anchor) {
      insert_hydration(target, first, anchor);
      mount_component(moveresize, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const moveresize_changes = {};
      if (dirty[0] & /*items*/
      1)
        moveresize_changes.id = /*item*/
        ctx[28].id;
      if (dirty[0] & /*items, getComputedCols*/
      17)
        moveresize_changes.resizable = /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ] && /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ].resizable;
      if (dirty[0] & /*items, getComputedCols*/
      17)
        moveresize_changes.draggable = /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ] && /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ].draggable;
      if (dirty[0] & /*xPerPx*/
      64)
        moveresize_changes.xPerPx = /*xPerPx*/
        ctx[6];
      if (dirty[0] & /*getComputedCols, items, xPerPx, gapX*/
      593)
        moveresize_changes.width = Math.min(
          /*getComputedCols*/
          ctx[4],
          /*item*/
          ctx[28][
            /*getComputedCols*/
            ctx[4]
          ] && /*item*/
          ctx[28][
            /*getComputedCols*/
            ctx[4]
          ].w
        ) * /*xPerPx*/
        ctx[6] - /*gapX*/
        ctx[9] * 2;
      if (dirty[0] & /*items, getComputedCols, gapY*/
      273)
        moveresize_changes.height = /*item*/
        (ctx[28][
          /*getComputedCols*/
          ctx[4]
        ] && /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ].h) * /*yPerPx*/
        ctx[10] - /*gapY*/
        ctx[8] * 2;
      if (dirty[0] & /*items, getComputedCols, gapY*/
      273)
        moveresize_changes.top = /*item*/
        (ctx[28][
          /*getComputedCols*/
          ctx[4]
        ] && /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ].y) * /*yPerPx*/
        ctx[10] + /*gapY*/
        ctx[8];
      if (dirty[0] & /*items, getComputedCols, xPerPx, gapX*/
      593)
        moveresize_changes.left = /*item*/
        (ctx[28][
          /*getComputedCols*/
          ctx[4]
        ] && /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ].x) * /*xPerPx*/
        ctx[6] + /*gapX*/
        ctx[9];
      if (dirty[0] & /*items, getComputedCols*/
      17)
        moveresize_changes.item = /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ];
      if (dirty[0] & /*items, getComputedCols*/
      17)
        moveresize_changes.min = /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ] && /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ].min;
      if (dirty[0] & /*items, getComputedCols*/
      17)
        moveresize_changes.max = /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ] && /*item*/
        ctx[28][
          /*getComputedCols*/
          ctx[4]
        ].max;
      if (dirty[0] & /*getComputedCols*/
      16)
        moveresize_changes.cols = /*getComputedCols*/
        ctx[4];
      if (dirty[0] & /*gapX*/
      512)
        moveresize_changes.gapX = /*gapX*/
        ctx[9];
      if (dirty[0] & /*gapY*/
      256)
        moveresize_changes.gapY = /*gapY*/
        ctx[8];
      if (dirty[0] & /*sensor*/
      8)
        moveresize_changes.sensor = /*sensor*/
        ctx[3];
      if (dirty[0] & /*scroller*/
      4)
        moveresize_changes.container = /*scroller*/
        ctx[2];
      if (dirty[0] & /*container*/
      32)
        moveresize_changes.nativeContainer = /*container*/
        ctx[5];
      if (dirty[0] & /*$$scope, items, getComputedCols*/
      2097169 | dirty[1] & /*movePointerDown, resizePointerDown*/
      3) {
        moveresize_changes.$$scope = { dirty, ctx };
      }
      moveresize.$set(moveresize_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(moveresize.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(moveresize.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(moveresize, detaching);
    }
  };
}
function create_fragment$2(ctx) {
  let div2;
  let current;
  let if_block = (
    /*xPerPx*/
    (ctx[6] || !/*fastStart*/
    ctx[1]) && create_if_block$2(ctx)
  );
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div2);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "svlt-grid-container svelte-1k5vgfu");
      set_style(
        div2,
        "height",
        /*containerHeight*/
        ctx[7] + "px"
      );
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      if (if_block)
        if_block.m(div2, null);
      ctx[20](div2);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*xPerPx*/
        ctx2[6] || !/*fastStart*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*xPerPx, fastStart*/
          66) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*containerHeight*/
      128) {
        set_style(
          div2,
          "height",
          /*containerHeight*/
          ctx2[7] + "px"
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block)
        if_block.d();
      ctx[20](null);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let gapX;
  let gapY;
  let containerHeight;
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  let { fillSpace = false } = $$props;
  let { items } = $$props;
  let { rowHeight } = $$props;
  let { cols } = $$props;
  let { gap = [10, 10] } = $$props;
  let { fastStart = false } = $$props;
  let { throttleUpdate = 100 } = $$props;
  let { throttleResize = 100 } = $$props;
  let { scroller = void 0 } = $$props;
  let { sensor = 20 } = $$props;
  let getComputedCols;
  let container;
  let xPerPx = 0;
  let yPerPx = rowHeight;
  let containerWidth;
  const pointerup = (ev) => {
    dispatch("pointerup", { id: ev.detail.id, cols: getComputedCols });
  };
  const onResize = throttle(
    () => {
      $$invalidate(0, items = specifyUndefinedColumns(items, getComputedCols, cols));
      dispatch("resize", {
        cols: getComputedCols,
        xPerPx,
        yPerPx,
        width: containerWidth
      });
    },
    throttleUpdate
  );
  onMount(() => {
    const sizeObserver = new ResizeObserver((entries) => {
      requestAnimationFrame(() => {
        let width2 = entries[0].contentRect.width;
        if (width2 === containerWidth)
          return;
        $$invalidate(4, getComputedCols = getColumn(width2, cols));
        $$invalidate(6, xPerPx = width2 / getComputedCols);
        if (!containerWidth) {
          $$invalidate(0, items = specifyUndefinedColumns(items, getComputedCols, cols));
          dispatch("mount", { cols: getComputedCols, xPerPx, yPerPx });
        } else {
          onResize();
        }
        containerWidth = width2;
      });
    });
    sizeObserver.observe(container);
    return () => sizeObserver.disconnect();
  });
  const updateMatrix = ({ detail }) => {
    let activeItem = getItemById(detail.id, items);
    if (activeItem) {
      activeItem = {
        ...activeItem,
        [getComputedCols]: {
          ...activeItem[getComputedCols],
          ...detail.shadow
        }
      };
      if (fillSpace) {
        $$invalidate(0, items = moveItemsAroundItem(activeItem, items, getComputedCols, getItemById(detail.id, items)));
      } else {
        $$invalidate(0, items = moveItem(activeItem, items, getComputedCols, getItemById(detail.id, items)));
      }
      if (detail.onUpdate)
        detail.onUpdate();
      dispatch("change", {
        unsafeItem: activeItem,
        id: activeItem.id,
        cols: getComputedCols
      });
    }
  };
  const throttleMatrix = throttle(updateMatrix, throttleResize);
  const handleRepaint = ({ detail }) => {
    if (!detail.isPointerUp) {
      throttleMatrix({ detail });
    } else {
      updateMatrix({ detail });
    }
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(5, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("fillSpace" in $$props2)
      $$invalidate(13, fillSpace = $$props2.fillSpace);
    if ("items" in $$props2)
      $$invalidate(0, items = $$props2.items);
    if ("rowHeight" in $$props2)
      $$invalidate(14, rowHeight = $$props2.rowHeight);
    if ("cols" in $$props2)
      $$invalidate(15, cols = $$props2.cols);
    if ("gap" in $$props2)
      $$invalidate(16, gap = $$props2.gap);
    if ("fastStart" in $$props2)
      $$invalidate(1, fastStart = $$props2.fastStart);
    if ("throttleUpdate" in $$props2)
      $$invalidate(17, throttleUpdate = $$props2.throttleUpdate);
    if ("throttleResize" in $$props2)
      $$invalidate(18, throttleResize = $$props2.throttleResize);
    if ("scroller" in $$props2)
      $$invalidate(2, scroller = $$props2.scroller);
    if ("sensor" in $$props2)
      $$invalidate(3, sensor = $$props2.sensor);
    if ("$$scope" in $$props2)
      $$invalidate(21, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*gap*/
    65536) {
      $$invalidate(9, [gapX, gapY] = gap, gapX, ($$invalidate(8, gapY), $$invalidate(16, gap)));
    }
    if ($$self.$$.dirty[0] & /*items, getComputedCols*/
    17) {
      $$invalidate(7, containerHeight = getContainerHeight(items, yPerPx, getComputedCols));
    }
  };
  return [
    items,
    fastStart,
    scroller,
    sensor,
    getComputedCols,
    container,
    xPerPx,
    containerHeight,
    gapY,
    gapX,
    yPerPx,
    pointerup,
    handleRepaint,
    fillSpace,
    rowHeight,
    cols,
    gap,
    throttleUpdate,
    throttleResize,
    slots,
    div_binding,
    $$scope
  ];
}
class Grid extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance$2,
      create_fragment$2,
      safe_not_equal,
      {
        fillSpace: 13,
        items: 0,
        rowHeight: 14,
        cols: 15,
        gap: 16,
        fastStart: 1,
        throttleUpdate: 17,
        throttleResize: 18,
        scroller: 2,
        sensor: 3
      },
      null,
      [-1, -1]
    );
  }
}
function makeItem(item) {
  const { min: min2 = { w: 1, h: 1 }, max: max2 } = item;
  return {
    fixed: false,
    resizable: !item.fixed,
    draggable: !item.fixed,
    customDragger: false,
    customResizer: false,
    min: {
      w: Math.max(1, min2.w),
      h: Math.max(1, min2.h)
    },
    max: { ...max2 },
    ...item
  };
}
const gridHelp = {
  normalize(items, col) {
    getRowsCount(items, col);
    return normalize(items, col);
  },
  adjust(items, col) {
    return adjust(items, col);
  },
  item(obj) {
    return makeItem(obj);
  },
  findSpace(item, items, cols) {
    let matrix = makeMatrixFromItems(items, getRowsCount(items, cols), cols);
    let position = findFreeSpaceForItem(matrix, item[cols]);
    return position;
  }
};
function create_if_block$1(ctx) {
  let div2;
  let dropdown;
  let updating_visible;
  let current;
  function dropdown_visible_binding(value) {
    ctx[8](value);
  }
  let dropdown_props = {
    $$slots: {
      items: [create_items_slot],
      trigger: [create_trigger_slot]
    },
    $$scope: { ctx }
  };
  if (
    /*menuOpen*/
    ctx[1] !== void 0
  ) {
    dropdown_props.visible = /*menuOpen*/
    ctx[1];
  }
  dropdown = new Dropdown({ props: dropdown_props });
  binding_callbacks.push(() => bind(dropdown, "visible", dropdown_visible_binding));
  return {
    c() {
      div2 = element("div");
      create_component(dropdown.$$.fragment);
      this.h();
    },
    l(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      claim_component(dropdown.$$.fragment, div_nodes);
      div_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div2, "class", "absolute -top-4 -left-4 z-10");
    },
    m(target, anchor) {
      insert_hydration(target, div2, anchor);
      mount_component(dropdown, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const dropdown_changes = {};
      if (dirty & /*$$scope, fixed, menuOpen*/
      1027) {
        dropdown_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_visible && dirty & /*menuOpen*/
      2) {
        updating_visible = true;
        dropdown_changes.visible = /*menuOpen*/
        ctx2[1];
        add_flush_callback(() => updating_visible = false);
      }
      dropdown.$set(dropdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dropdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(dropdown);
    }
  };
}
function create_default_slot_2$1(ctx) {
  let button_icon;
  let current;
  button_icon = new Button$1.Icon({ props: { data: mdiMenu } });
  return {
    c() {
      create_component(button_icon.$$.fragment);
    },
    l(nodes) {
      claim_component(button_icon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button_icon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(button_icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button_icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button_icon, detaching);
    }
  };
}
function create_trigger_slot(ctx) {
  let button;
  let current;
  button = new Button$1({
    props: {
      slot: "trigger",
      shape: "circle",
      size: "xs",
      type: "primary",
      $$slots: { default: [create_default_slot_2$1] },
      $$scope: { ctx }
    }
  });
  button.$on(
    "click",
    /*click_handler_1*/
    ctx[7]
  );
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const button_changes = {};
      if (dirty & /*$$scope*/
      1024) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_icon_slot_2(ctx) {
  let dropdown_items_item_icon;
  let current;
  dropdown_items_item_icon = new Dropdown.Items.Item.Icon({ props: { slot: "icon", data: mdiCog } });
  return {
    c() {
      create_component(dropdown_items_item_icon.$$.fragment);
    },
    l(nodes) {
      claim_component(dropdown_items_item_icon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(dropdown_items_item_icon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(dropdown_items_item_icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropdown_items_item_icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dropdown_items_item_icon, detaching);
    }
  };
}
function create_icon_slot_1(ctx) {
  let dropdown_items_item_icon;
  let current;
  dropdown_items_item_icon = new Dropdown.Items.Item.Icon({
    props: {
      slot: "icon",
      data: (
        /*fixed*/
        ctx[0] ? mdiLock : mdiLockOpenVariant
      )
    }
  });
  return {
    c() {
      create_component(dropdown_items_item_icon.$$.fragment);
    },
    l(nodes) {
      claim_component(dropdown_items_item_icon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(dropdown_items_item_icon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dropdown_items_item_icon_changes = {};
      if (dirty & /*fixed*/
      1)
        dropdown_items_item_icon_changes.data = /*fixed*/
        ctx2[0] ? mdiLock : mdiLockOpenVariant;
      dropdown_items_item_icon.$set(dropdown_items_item_icon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dropdown_items_item_icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropdown_items_item_icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dropdown_items_item_icon, detaching);
    }
  };
}
function create_icon_slot(ctx) {
  let dropdown_items_item_icon;
  let current;
  dropdown_items_item_icon = new Dropdown.Items.Item.Icon({
    props: {
      slot: "icon",
      data: mdiDelete,
      color: "red"
    }
  });
  return {
    c() {
      create_component(dropdown_items_item_icon.$$.fragment);
    },
    l(nodes) {
      claim_component(dropdown_items_item_icon.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(dropdown_items_item_icon, target, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(dropdown_items_item_icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropdown_items_item_icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dropdown_items_item_icon, detaching);
    }
  };
}
function create_default_slot_1$1(ctx) {
  let dropdown_items_item0;
  let t0;
  let dropdown_items_item1;
  let t1;
  let dropdown_items_item2;
  let current;
  dropdown_items_item0 = new Dropdown.Items.Item({
    props: {
      label: "Edit",
      $$slots: { icon: [create_icon_slot_2] },
      $$scope: { ctx }
    }
  });
  dropdown_items_item0.$on(
    "click",
    /*onEdit*/
    ctx[3]
  );
  dropdown_items_item1 = new Dropdown.Items.Item({
    props: {
      label: (
        /*fixed*/
        ctx[0] ? "Unlock" : "Lock"
      ),
      $$slots: { icon: [create_icon_slot_1] },
      $$scope: { ctx }
    }
  });
  dropdown_items_item1.$on(
    "click",
    /*onFixed*/
    ctx[4]
  );
  dropdown_items_item2 = new Dropdown.Items.Item({
    props: {
      type: "danger",
      label: "Delete",
      $$slots: { icon: [create_icon_slot] },
      $$scope: { ctx }
    }
  });
  dropdown_items_item2.$on(
    "click",
    /*onDelete*/
    ctx[5]
  );
  return {
    c() {
      create_component(dropdown_items_item0.$$.fragment);
      t0 = space();
      create_component(dropdown_items_item1.$$.fragment);
      t1 = space();
      create_component(dropdown_items_item2.$$.fragment);
    },
    l(nodes) {
      claim_component(dropdown_items_item0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(dropdown_items_item1.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(dropdown_items_item2.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(dropdown_items_item0, target, anchor);
      insert_hydration(target, t0, anchor);
      mount_component(dropdown_items_item1, target, anchor);
      insert_hydration(target, t1, anchor);
      mount_component(dropdown_items_item2, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dropdown_items_item0_changes = {};
      if (dirty & /*$$scope*/
      1024) {
        dropdown_items_item0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropdown_items_item0.$set(dropdown_items_item0_changes);
      const dropdown_items_item1_changes = {};
      if (dirty & /*fixed*/
      1)
        dropdown_items_item1_changes.label = /*fixed*/
        ctx2[0] ? "Unlock" : "Lock";
      if (dirty & /*$$scope, fixed*/
      1025) {
        dropdown_items_item1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropdown_items_item1.$set(dropdown_items_item1_changes);
      const dropdown_items_item2_changes = {};
      if (dirty & /*$$scope*/
      1024) {
        dropdown_items_item2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropdown_items_item2.$set(dropdown_items_item2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dropdown_items_item0.$$.fragment, local);
      transition_in(dropdown_items_item1.$$.fragment, local);
      transition_in(dropdown_items_item2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropdown_items_item0.$$.fragment, local);
      transition_out(dropdown_items_item1.$$.fragment, local);
      transition_out(dropdown_items_item2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
      destroy_component(dropdown_items_item0, detaching);
      destroy_component(dropdown_items_item1, detaching);
      destroy_component(dropdown_items_item2, detaching);
    }
  };
}
function create_items_slot(ctx) {
  let dropdown_items;
  let current;
  dropdown_items = new Dropdown.Items({
    props: {
      slot: "items",
      $$slots: { default: [create_default_slot_1$1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(dropdown_items.$$.fragment);
    },
    l(nodes) {
      claim_component(dropdown_items.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(dropdown_items, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dropdown_items_changes = {};
      if (dirty & /*$$scope, fixed*/
      1025) {
        dropdown_items_changes.$$scope = { dirty, ctx: ctx2 };
      }
      dropdown_items.$set(dropdown_items_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dropdown_items.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dropdown_items.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dropdown_items, detaching);
    }
  };
}
function create_default_slot$1(ctx) {
  let t2;
  let current;
  let if_block = (
    /*$editing*/
    ctx[2] && create_if_block$1(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      t2 = space();
      if (default_slot)
        default_slot.c();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      t2 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, t2, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$editing*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$editing*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t2.parentNode, t2);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      if (if_block)
        if_block.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment$1(ctx) {
  let card;
  let current;
  card = new Card({
    props: {
      class: "h-full w-full overflow-hidden flex flex-col justify-start",
      $$slots: { default: [create_default_slot$1] },
      $$scope: { ctx }
    }
  });
  card.$on(
    "click",
    /*click_handler*/
    ctx[9]
  );
  return {
    c() {
      create_component(card.$$.fragment);
    },
    l(nodes) {
      claim_component(card.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(card, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const card_changes = {};
      if (dirty & /*$$scope, menuOpen, fixed, $editing*/
      1031) {
        card_changes.$$scope = { dirty, ctx: ctx2 };
      }
      card.$set(card_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(card.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(card.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(card, detaching);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $editing;
  component_subscribe($$self, editing, ($$value) => $$invalidate(2, $editing = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  const dispatch = createEventDispatcher();
  let { fixed } = $$props;
  let menuOpen = false;
  function onEdit() {
    $$invalidate(1, menuOpen = false);
    dispatch("edit");
  }
  function onFixed() {
    $$invalidate(1, menuOpen = false);
    dispatch("fixed", !fixed);
  }
  function onDelete() {
    $$invalidate(1, menuOpen = false);
    dispatch("delete");
  }
  const click_handler_1 = (e2) => $$invalidate(1, menuOpen = true);
  function dropdown_visible_binding(value) {
    menuOpen = value;
    $$invalidate(1, menuOpen);
  }
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("fixed" in $$props2)
      $$invalidate(0, fixed = $$props2.fixed);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  return [
    fixed,
    menuOpen,
    $editing,
    onEdit,
    onFixed,
    onDelete,
    slots,
    click_handler_1,
    dropdown_visible_binding,
    click_handler,
    $$scope
  ];
}
class WidgetContainer extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, { fixed: 0 });
  }
}
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[58] = list[i2];
  return child_ctx;
}
function create_if_block(ctx) {
  let editwidgetview;
  let updating_open;
  let t0;
  let div2;
  let t1;
  let grid_1;
  let updating_items;
  let t2;
  let portal;
  let t3;
  let addwidgetdialog;
  let updating_open_1;
  let current;
  function editwidgetview_open_binding(value) {
    ctx[27](value);
  }
  let editwidgetview_props = { item: (
    /*editItem*/
    ctx[7]
  ) };
  if (
    /*editOpen*/
    ctx[6] !== void 0
  ) {
    editwidgetview_props.open = /*editOpen*/
    ctx[6];
  }
  editwidgetview = new EditWidgetView({ props: editwidgetview_props });
  binding_callbacks.push(() => bind(editwidgetview, "open", editwidgetview_open_binding));
  editwidgetview.$on(
    "settings",
    /*settings_handler*/
    ctx[28]
  );
  let if_block = (
    /*$editing*/
    ctx[1] && create_if_block_3(ctx)
  );
  function grid_1_items_binding(value) {
    ctx[37](value);
  }
  let grid_1_props = {
    fastStart: true,
    cols: (
      /*breakpointColumns*/
      ctx[0]
    ),
    gap: (
      /*$grid*/
      ctx[10].gaps
    ),
    rowHeight: 50,
    $$slots: {
      default: [
        create_default_slot_2,
        ({ item, dataItem }) => ({ 56: item, 57: dataItem }),
        ({ item, dataItem }) => [0, (item ? 33554432 : 0) | (dataItem ? 67108864 : 0)]
      ]
    },
    $$scope: { ctx }
  };
  if (
    /*items*/
    ctx[2] !== void 0
  ) {
    grid_1_props.items = /*items*/
    ctx[2];
  }
  grid_1 = new Grid({ props: grid_1_props });
  binding_callbacks.push(() => bind(grid_1, "items", grid_1_items_binding));
  grid_1.$on(
    "mount",
    /*mount_handler*/
    ctx[38]
  );
  grid_1.$on(
    "resize",
    /*resize_handler*/
    ctx[39]
  );
  portal = new Portal({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  function addwidgetdialog_open_binding(value) {
    ctx[41](value);
  }
  let addwidgetdialog_props = {};
  if (
    /*addWidgetOpen*/
    ctx[8] !== void 0
  ) {
    addwidgetdialog_props.open = /*addWidgetOpen*/
    ctx[8];
  }
  addwidgetdialog = new AddWidgetDialog({ props: addwidgetdialog_props });
  binding_callbacks.push(() => bind(addwidgetdialog, "open", addwidgetdialog_open_binding));
  addwidgetdialog.$on(
    "selected",
    /*selected_handler*/
    ctx[42]
  );
  return {
    c() {
      create_component(editwidgetview.$$.fragment);
      t0 = space();
      div2 = element("div");
      if (if_block)
        if_block.c();
      t1 = space();
      create_component(grid_1.$$.fragment);
      t2 = space();
      create_component(portal.$$.fragment);
      t3 = space();
      create_component(addwidgetdialog.$$.fragment);
      this.h();
    },
    l(nodes) {
      claim_component(editwidgetview.$$.fragment, nodes);
      t0 = claim_space(nodes);
      div2 = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div2);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach);
      t1 = claim_space(nodes);
      claim_component(grid_1.$$.fragment, nodes);
      t2 = claim_space(nodes);
      claim_component(portal.$$.fragment, nodes);
      t3 = claim_space(nodes);
      claim_component(addwidgetdialog.$$.fragment, nodes);
      this.h();
    },
    h() {
      attr(div2, "class", "flex justify-center");
    },
    m(target, anchor) {
      mount_component(editwidgetview, target, anchor);
      insert_hydration(target, t0, anchor);
      insert_hydration(target, div2, anchor);
      if (if_block)
        if_block.m(div2, null);
      insert_hydration(target, t1, anchor);
      mount_component(grid_1, target, anchor);
      insert_hydration(target, t2, anchor);
      mount_component(portal, target, anchor);
      insert_hydration(target, t3, anchor);
      mount_component(addwidgetdialog, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const editwidgetview_changes = {};
      if (dirty[0] & /*editItem*/
      128)
        editwidgetview_changes.item = /*editItem*/
        ctx2[7];
      if (!updating_open && dirty[0] & /*editOpen*/
      64) {
        updating_open = true;
        editwidgetview_changes.open = /*editOpen*/
        ctx2[6];
        add_flush_callback(() => updating_open = false);
      }
      editwidgetview.$set(editwidgetview_changes);
      if (
        /*$editing*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$editing*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const grid_1_changes = {};
      if (dirty[0] & /*$grid*/
      1024)
        grid_1_changes.gap = /*$grid*/
        ctx2[10].gaps;
      if (dirty[1] & /*$$scope, item, dataItem*/
      1174405120) {
        grid_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_items && dirty[0] & /*items*/
      4) {
        updating_items = true;
        grid_1_changes.items = /*items*/
        ctx2[2];
        add_flush_callback(() => updating_items = false);
      }
      grid_1.$set(grid_1_changes);
      const portal_changes = {};
      if (dirty[0] & /*viewOpen, viewComponent, viewItem*/
      56 | dirty[1] & /*$$scope*/
      1073741824) {
        portal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      portal.$set(portal_changes);
      const addwidgetdialog_changes = {};
      if (!updating_open_1 && dirty[0] & /*addWidgetOpen*/
      256) {
        updating_open_1 = true;
        addwidgetdialog_changes.open = /*addWidgetOpen*/
        ctx2[8];
        add_flush_callback(() => updating_open_1 = false);
      }
      addwidgetdialog.$set(addwidgetdialog_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(editwidgetview.$$.fragment, local);
      transition_in(if_block);
      transition_in(grid_1.$$.fragment, local);
      transition_in(portal.$$.fragment, local);
      transition_in(addwidgetdialog.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(editwidgetview.$$.fragment, local);
      transition_out(if_block);
      transition_out(grid_1.$$.fragment, local);
      transition_out(portal.$$.fragment, local);
      transition_out(addwidgetdialog.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div2);
        detach(t1);
        detach(t2);
        detach(t3);
      }
      destroy_component(editwidgetview, detaching);
      if (if_block)
        if_block.d();
      destroy_component(grid_1, detaching);
      destroy_component(portal, detaching);
      destroy_component(addwidgetdialog, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let div0;
  let t0;
  let div1;
  let button0;
  let t1;
  let button1;
  let t2;
  let button2;
  let current;
  let each_value = ensure_array_like(widgets);
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block(get_each_context(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  button0 = new Button$1({
    props: {
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  button0.$on(
    "click",
    /*click_handler_1*/
    ctx[30]
  );
  button1 = new Button$1({
    props: {
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  button1.$on(
    "click",
    /*click_handler_2*/
    ctx[31]
  );
  button2 = new Button$1({
    props: {
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  button2.$on(
    "click",
    /*click_handler_3*/
    ctx[32]
  );
  return {
    c() {
      div0 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      div1 = element("div");
      create_component(button0.$$.fragment);
      t1 = space();
      create_component(button1.$$.fragment);
      t2 = space();
      create_component(button2.$$.fragment);
      this.h();
    },
    l(nodes) {
      div0 = claim_element(nodes, "DIV", {});
      var div0_nodes = children(div0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].l(div0_nodes);
      }
      div0_nodes.forEach(detach);
      t0 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(button0.$$.fragment, div1_nodes);
      t1 = claim_space(div1_nodes);
      claim_component(button1.$$.fragment, div1_nodes);
      t2 = claim_space(div1_nodes);
      claim_component(button2.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach);
      this.h();
    },
    h() {
      attr(div1, "class", "ml-4");
    },
    m(target, anchor) {
      insert_hydration(target, div0, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div0, null);
        }
      }
      insert_hydration(target, t0, anchor);
      insert_hydration(target, div1, anchor);
      mount_component(button0, div1, null);
      append_hydration(div1, t1);
      mount_component(button1, div1, null);
      append_hydration(div1, t2);
      mount_component(button2, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*addWidget*/
      2048) {
        each_value = ensure_array_like(widgets);
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div0, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      const button0_changes = {};
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
      const button2_changes = {};
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button2.$set(button2_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button2.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t0);
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button2);
    }
  };
}
function create_default_slot_7(ctx) {
  let icon;
  let t2;
  let current;
  icon = new Icon$7({ props: { data: (
    /*widget*/
    ctx[58].icon
  ) } });
  return {
    c() {
      create_component(icon.$$.fragment);
      t2 = space();
    },
    l(nodes) {
      claim_component(icon.$$.fragment, nodes);
      t2 = claim_space(nodes);
    },
    m(target, anchor) {
      mount_component(icon, target, anchor);
      insert_hydration(target, t2, anchor);
      current = true;
    },
    p: noop$1,
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
      destroy_component(icon, detaching);
    }
  };
}
function create_each_block(ctx) {
  let button;
  let current;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[29](
        /*widget*/
        ctx[58]
      )
    );
  }
  button = new Button$1({
    props: {
      ariaLabel: (
        /*widget*/
        ctx[58].label
      ),
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  button.$on("click", click_handler);
  return {
    c() {
      create_component(button.$$.fragment);
    },
    l(nodes) {
      claim_component(button.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty[1] & /*$$scope*/
      1073741824) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(button, detaching);
    }
  };
}
function create_default_slot_6(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Add");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Add");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_5(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Save");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Save");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_4(ctx) {
  let t2;
  return {
    c() {
      t2 = text("Cancel");
    },
    l(nodes) {
      t2 = claim_text(nodes, "Cancel");
    },
    m(target, anchor) {
      insert_hydration(target, t2, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(t2);
      }
    }
  };
}
function create_default_slot_3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = findWidget(
    /*dataItem*/
    ctx[57].settings.type
  );
  function switch_props(ctx2) {
    return {
      props: { settings: (
        /*dataItem*/
        ctx2[57].settings
      ) }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[1] & /*dataItem*/
      67108864)
        switch_instance_changes.settings = /*dataItem*/
        ctx2[57].settings;
      if (dirty[1] & /*dataItem*/
      67108864 && switch_value !== (switch_value = findWidget(
        /*dataItem*/
        ctx2[57].settings.type
      ))) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let widgetcontainer;
  let current;
  function fixed_handler(...args) {
    return (
      /*fixed_handler*/
      ctx[33](
        /*dataItem*/
        ctx[57],
        ...args
      )
    );
  }
  function edit_handler() {
    return (
      /*edit_handler*/
      ctx[34](
        /*dataItem*/
        ctx[57]
      )
    );
  }
  function delete_handler() {
    return (
      /*delete_handler*/
      ctx[35](
        /*dataItem*/
        ctx[57]
      )
    );
  }
  function click_handler_4() {
    return (
      /*click_handler_4*/
      ctx[36](
        /*dataItem*/
        ctx[57]
      )
    );
  }
  widgetcontainer = new WidgetContainer({
    props: {
      fixed: (
        /*item*/
        ctx[56].fixed ?? false
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  widgetcontainer.$on("fixed", fixed_handler);
  widgetcontainer.$on("edit", edit_handler);
  widgetcontainer.$on("delete", delete_handler);
  widgetcontainer.$on("click", click_handler_4);
  return {
    c() {
      create_component(widgetcontainer.$$.fragment);
    },
    l(nodes) {
      claim_component(widgetcontainer.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(widgetcontainer, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const widgetcontainer_changes = {};
      if (dirty[1] & /*item*/
      33554432)
        widgetcontainer_changes.fixed = /*item*/
        ctx[56].fixed ?? false;
      if (dirty[1] & /*$$scope, dataItem*/
      1140850688) {
        widgetcontainer_changes.$$scope = { dirty, ctx };
      }
      widgetcontainer.$set(widgetcontainer_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(widgetcontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(widgetcontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(widgetcontainer, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let modal;
  let current;
  modal = new Modal({
    props: {
      handleClose: (
        /*func*/
        ctx[40]
      ),
      $$slots: { content: [create_content_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal.$$.fragment);
    },
    l(nodes) {
      claim_component(modal.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_changes = {};
      if (dirty[0] & /*viewOpen*/
      8)
        modal_changes.handleClose = /*func*/
        ctx2[40];
      if (dirty[0] & /*viewComponent, viewItem*/
      48 | dirty[1] & /*$$scope*/
      1073741824) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*viewComponent*/
    ctx[5]
  );
  function switch_props(ctx2) {
    return {
      props: { settings: (
        /*viewItem*/
        ctx2[4].settings
      ) }
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const switch_instance_changes = {};
      if (dirty[0] & /*viewItem*/
      16)
        switch_instance_changes.settings = /*viewItem*/
        ctx2[4].settings;
      if (dirty[0] & /*viewComponent*/
      32 && switch_value !== (switch_value = /*viewComponent*/
      ctx2[5])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*viewItem*/
    ctx[4] !== void 0 && /*viewComponent*/
    ctx[5] !== void 0 && create_if_block_2(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*viewItem*/
        ctx2[4] !== void 0 && /*viewComponent*/
        ctx2[5] !== void 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*viewItem, viewComponent*/
          48) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_body_slot(ctx) {
  let modal_content_body;
  let current;
  modal_content_body = new Modal.Content.Body({
    props: {
      slot: "body",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal_content_body.$$.fragment);
    },
    l(nodes) {
      claim_component(modal_content_body.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal_content_body, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_content_body_changes = {};
      if (dirty[0] & /*viewComponent, viewItem*/
      48 | dirty[1] & /*$$scope*/
      1073741824) {
        modal_content_body_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal_content_body.$set(modal_content_body_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal_content_body.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal_content_body.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal_content_body, detaching);
    }
  };
}
function create_content_slot(ctx) {
  let modal_content;
  let current;
  modal_content = new Modal.Content({
    props: {
      slot: "content",
      $$slots: { body: [create_body_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(modal_content.$$.fragment);
    },
    l(nodes) {
      claim_component(modal_content.$$.fragment, nodes);
    },
    m(target, anchor) {
      mount_component(modal_content, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const modal_content_changes = {};
      if (dirty[0] & /*viewComponent, viewItem*/
      48 | dirty[1] & /*$$scope*/
      1073741824) {
        modal_content_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal_content.$set(modal_content_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(modal_content.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(modal_content.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(modal_content, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*viewOpen*/
    ctx[3] && create_if_block_1(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*viewOpen*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*viewOpen*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_fragment(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$homey*/
    ctx[9] !== void 0 && create_if_block(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*$homey*/
        ctx2[9] !== void 0
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$homey*/
          512) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
const smallBreakpoint = 640;
const mediumBreakpoint = 768;
const largeBreakpoint = 1024;
const xlargeBreakpoint = 1280;
const smallColumns = 6;
const mediumColumns = 12;
const largeColumns = 18;
const xlargeColumns = 24;
function instance($$self, $$props, $$invalidate) {
  let dashboards$2;
  let dashboardId;
  let resolvedDashboard;
  let $homey;
  let $scopes;
  let $devices;
  let $editing;
  let $page;
  let $localDashboards;
  let $homeyDashboards;
  let $grid;
  component_subscribe($$self, homey, ($$value) => $$invalidate(9, $homey = $$value));
  component_subscribe($$self, scopes, ($$value) => $$invalidate(46, $scopes = $$value));
  component_subscribe($$self, devices, ($$value) => $$invalidate(47, $devices = $$value));
  component_subscribe($$self, editing, ($$value) => $$invalidate(1, $editing = $$value));
  component_subscribe($$self, page, ($$value) => $$invalidate(24, $page = $$value));
  component_subscribe($$self, dashboards, ($$value) => $$invalidate(25, $localDashboards = $$value));
  component_subscribe($$self, dashboards$1, ($$value) => $$invalidate(26, $homeyDashboards = $$value));
  component_subscribe($$self, grid, ($$value) => $$invalidate(10, $grid = $$value));
  const breakpoints = [smallBreakpoint, mediumBreakpoint, largeBreakpoint, xlargeBreakpoint];
  const columns = [smallColumns, mediumColumns, largeColumns, xlargeColumns];
  const breakpointColumns = [
    [smallBreakpoint, smallColumns],
    [mediumBreakpoint, mediumColumns],
    [largeBreakpoint, largeColumns],
    [xlargeBreakpoint, xlargeColumns]
  ];
  let items = [];
  let viewOpen = false;
  let viewItem;
  let viewComponent;
  let editOpen = false;
  let editItem;
  let addWidgetOpen = false;
  let dashboard$1;
  let heartbeat;
  onMount(() => {
    heartbeat = setInterval(() => sendHeartbeat(), 30 * 1e3);
  });
  onDestroy(() => {
    if (heartbeat !== void 0) {
      clearInterval(heartbeat);
    }
  });
  function onDashboard(d3) {
    if (d3 !== void 0 && !$editing && d3.items !== items) {
      dashboard.set(d3);
      dashboard$1 = d3;
      $$invalidate(2, items = migrateWidgets(d3.items));
    }
  }
  function onEditing(edit) {
    const result = [...items];
    result.forEach((item) => {
      columns.forEach((column) => {
        item[column].draggable = edit;
        item[column].resizable = edit;
      });
    });
    $$invalidate(2, items = result);
  }
  function migrateWidgets(i2) {
    const result = [];
    let changes = false;
    for (let item of i2) {
      const migration = findMigration(item.settings.type);
      const migrated = migration !== void 0 ? migration(item.settings) : item.settings;
      if (migrated !== item.settings) {
        changes = true;
      }
      result.push({ ...item, settings: migrated });
    }
    if (changes) {
      return result;
    }
    return i2;
  }
  function addWidget(type) {
    if (type === void 0) {
      return;
    }
    const create2 = findCreate(type);
    if (create2 !== void 0) {
      const settings = create2();
      const item = { id: settings == null ? void 0 : settings.id, settings };
      $$invalidate(7, editItem = addItem(item));
      $$invalidate(6, editOpen = true);
    }
  }
  function editWidget(item) {
    $$invalidate(7, editItem = item);
    $$invalidate(6, editOpen = true);
  }
  function saveWidget(settings) {
    $$invalidate(6, editOpen = false);
    setItemSettings(editItem.id, settings);
  }
  function openView(item) {
    if ($editing) {
      return;
    }
    $$invalidate(4, viewItem = item);
    $$invalidate(5, viewComponent = findView(viewItem.settings.type));
    if (viewItem !== void 0 && viewComponent !== void 0) {
      $$invalidate(3, viewOpen = true);
    }
  }
  function addItem(item) {
    const result = [...items, item];
    columns.forEach((column) => {
      item[column] = gridHelp.item({
        x: 0,
        y: 0,
        w: 3,
        h: 3,
        resizable: true,
        draggable: true
      });
      const findOutPosition = gridHelp.findSpace(item, result, column);
      item[column] = { ...item[column], ...findOutPosition };
    });
    $$invalidate(2, items = result);
    return item;
  }
  function removeItem(id) {
    $$invalidate(2, items = items.filter((item) => item.id !== id));
  }
  function setItemFixed(id, fixed) {
    const result = [...items];
    const item = result.find((i2) => i2.id === id);
    if (item) {
      columns.forEach((column) => {
        item[column].fixed = fixed;
        item[column].draggable = !fixed;
        item[column].resizable = !fixed;
      });
    }
    $$invalidate(2, items = result);
  }
  function setItemSettings(id, settings) {
    const result = [...items];
    const item = result.find((i2) => i2.id === id);
    if (item) {
      item.settings = settings;
    }
    $$invalidate(2, items = result);
  }
  async function saveChanges() {
    if (dashboard$1 === void 0) {
      editing.set(false);
      return;
    } else {
      dashboard$1.items = items;
      if (dashboard$1.source === "localstorage") {
        const d3 = { ...dashboard$1, items: stripGrid(items) };
        dashboards.update(d3);
      } else if (dashboard$1.source === "homey") {
        const settings = { items: stripGrid(items) };
        let success = false;
        const dashboardDevice = Object.values($devices).find((device) => device.data.id === dashboard$1.id);
        if (dashboardDevice !== void 0) {
          dashboardDevice.settings = settings;
        }
        try {
          const url = webhookUrl + webhookId + "?homey=" + $homey.id + "&operation=save_dashboard&dashboardId=" + dashboard$1.id;
          const response = await fetch(url, {
            method: "POST",
            body: JSON.stringify(settings)
          });
          if (response.ok) {
            success = true;
          }
        } catch (e2) {
        }
        if (!success) {
          if ($scopes.includes("homey") || $scopes.includes("homey.app")) {
            try {
              const app = await $homey.apps.getApp({ id: "skogsaas.dashboards" });
              if (app !== void 0) {
                await app.put({
                  path: "/dashboards/" + dashboard$1.id,
                  body: settings
                });
                success = true;
              }
            } catch (e2) {
            }
          }
        }
      }
    }
    editing.set(false);
  }
  function cancelChanges() {
    if (dashboard$1 === void 0) {
      return;
    }
    $$invalidate(2, items = migrateWidgets(dashboard$1.items ?? []));
    editing.set(false);
  }
  function stripGrid(i2) {
    const result = [...i2];
    result.forEach((item) => {
      columns.forEach((column) => {
        delete item[column].draggable;
        delete item[column].resizable;
        delete item[column].customDragger;
        delete item[column].customResizer;
      });
    });
    return result;
  }
  async function sendHeartbeat() {
    let success = false;
    try {
      let url = webhookUrl + webhookId + "?homey=" + $homey.id + "&operation=active_dashboard";
      if (dashboard$1 !== void 0) {
        url += "&dashboardId=" + dashboard$1.id;
      }
      const response = await fetch(url, { method: "POST", body: "" });
      if (response.ok) {
        success = true;
      }
    } catch (e2) {
    }
  }
  function editwidgetview_open_binding(value) {
    editOpen = value;
    $$invalidate(6, editOpen);
  }
  const settings_handler = (e2) => saveWidget(e2.detail);
  const click_handler = (widget) => addWidget(widget.type);
  const click_handler_1 = () => $$invalidate(8, addWidgetOpen = true);
  const click_handler_2 = () => saveChanges();
  const click_handler_3 = () => cancelChanges();
  const fixed_handler = (dataItem, e2) => setItemFixed(dataItem.id, e2.detail);
  const edit_handler = (dataItem) => editWidget(dataItem);
  const delete_handler = (dataItem) => removeItem(dataItem.id);
  const click_handler_4 = (dataItem) => openView(dataItem);
  function grid_1_items_binding(value) {
    items = value;
    $$invalidate(2, items);
  }
  const mount_handler = (e2) => grid.updateSize(e2.detail);
  const resize_handler = (e2) => grid.updateSize(e2.detail);
  const func = () => $$invalidate(3, viewOpen = false);
  function addwidgetdialog_open_binding(value) {
    addWidgetOpen = value;
    $$invalidate(8, addWidgetOpen);
  }
  const selected_handler = (e2) => addWidget(e2.detail);
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$homeyDashboards, $localDashboards*/
    100663296) {
      $$invalidate(23, dashboards$2 = { ...$homeyDashboards, ...$localDashboards });
    }
    if ($$self.$$.dirty[0] & /*$page*/
    16777216) {
      $$invalidate(22, dashboardId = $page.url.searchParams.get("id"));
    }
    if ($$self.$$.dirty[0] & /*dashboardId, dashboards*/
    12582912) {
      $$invalidate(21, resolvedDashboard = dashboardId !== null ? dashboards$2[dashboardId] : void 0);
    }
    if ($$self.$$.dirty[0] & /*resolvedDashboard*/
    2097152) {
      onDashboard(resolvedDashboard);
    }
    if ($$self.$$.dirty[0] & /*$editing*/
    2) {
      onEditing($editing);
    }
  };
  return [
    breakpointColumns,
    $editing,
    items,
    viewOpen,
    viewItem,
    viewComponent,
    editOpen,
    editItem,
    addWidgetOpen,
    $homey,
    $grid,
    addWidget,
    editWidget,
    saveWidget,
    openView,
    removeItem,
    setItemFixed,
    saveChanges,
    cancelChanges,
    breakpoints,
    columns,
    resolvedDashboard,
    dashboardId,
    dashboards$2,
    $page,
    $localDashboards,
    $homeyDashboards,
    editwidgetview_open_binding,
    settings_handler,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3,
    fixed_handler,
    edit_handler,
    delete_handler,
    click_handler_4,
    grid_1_items_binding,
    mount_handler,
    resize_handler,
    func,
    addwidgetdialog_open_binding,
    selected_handler
  ];
}
class Page extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        breakpoints: 19,
        columns: 20,
        breakpointColumns: 0
      },
      null,
      [-1, -1]
    );
  }
  get breakpoints() {
    return this.$$.ctx[19];
  }
  get columns() {
    return this.$$.ctx[20];
  }
  get breakpointColumns() {
    return this.$$.ctx[0];
  }
}
export {
  Page as component
};
